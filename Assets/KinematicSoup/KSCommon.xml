<?xml version="1.0"?>
<doc>
    <assembly>
        <name>KSCommon</name>
    </assembly>
    <members>
        <member name="T:KS.Reactor.BitStreamConstants">
            <summary>Bit stream constants. Must match MaticalLib/BitStream.h on the server.</summary>
        </member>
        <member name="F:KS.Reactor.BitStreamConstants.INT32">
            Identifiers for how many bits we use to encode ints.
        </member>
        <member name="F:KS.Reactor.BitStreamConstants.LONG64">
            Identifiers for how many bits we use to encode longs.
        </member>
        <member name="F:KS.Reactor.BitStreamConstants.INT6_MIN">
            Min and max values for integer types
        </member>
        <member name="T:KS.Reactor.JSONParser">
            <summary>JSON parser.</summary>
        </member>
        <member name="P:KS.Reactor.JSONParser.Instance">
            <summary>Singleton instance.</summary>
        </member>
        <member name="M:KS.Reactor.JSONParser.#ctor">
            <summary>Singleton constructor.</summary>
        </member>
        <member name="M:KS.Reactor.JSONParser.Parse(System.String)">
            <summary>Parses a JSON string. Throws an exception if the JSON string is invalid.</summary>
            <param name="str">String to parse.</param>
            <returns>The ksJSON constructed from parsing JSON string.</returns>
        </member>
        <member name="M:KS.Reactor.JSONParser.Parse(System.String,System.Int32@)">
            <summary>Parses a JSON string at an index.</summary>
            <param name="str">String to parse.</param>
            <param name="index">Index to parse at. Will be set to index parsing finishes at plus one.</param>
            <returns>The ksJSON constructed from parsing JSON string.</returns>
        </member>
        <member name="M:KS.Reactor.JSONParser.ParseObject(System.String,System.Int32@)">
            <summary>Parses a JSON object from a JSON string.</summary>
            <param name="str">String to parse.</param>
            <param name="index">Index to parse at. Will be set to index parsing finishes at plus one.</param>
            <returns>The parsed ksJSON of object type.</returns>
        </member>
        <member name="M:KS.Reactor.JSONParser.ParseArray(System.String,System.Int32@)">
            <summary>Parses a JSON array from a JSON string.</summary>
            <param name="str">String to parse.</param>
            <param name="index">Index to parse at. Will be set to index parsing finishes at plus one.</param>
            <returns>The parsed ksJSON of array type.</returns>
        </member>
        <member name="M:KS.Reactor.JSONParser.ParseValue(System.String,System.Int32@)">
            <summary>Parses a JSON value from a JSON string.</summary>
            <param name="str">String to parse.</param>
            <param name="index">Index to parse at. Will be set to index parsing finishes at plus one.</param>
            <returns>The parsed ksJSON of value type.</returns>
        </member>
        <member name="M:KS.Reactor.JSONParser.ParseString(System.String,System.Int32@)">
            <summary>Parses a JSON string from a JSON string.</summary>
            <param name="str">String to parse.</param>
            <param name="index">Index to parse at. Will be set to index parsing finishes at plus one.</param>
            <returns>The parsed ksJSON of string type.</returns>
        </member>
        <member name="M:KS.Reactor.JSONParser.GetToken(System.String,System.Int32@)">
            <summary>
            Scans a string until a white space or delimiter character or the end of the string is encountered, and
            returns the substring between the start (inclusive) and end (exclusive) points of the scan.
            </summary>
            <param name="str">String to get token from.</param>
            <param name="index">Index to look for token at. Will be set to the index after the end of the token.</param>
            <returns>Token.</returns>
        </member>
        <member name="M:KS.Reactor.JSONParser.Consume(System.Char,System.String,System.Int32@)">
            <summary>
            Advances the position in a string until a non-white space character is encountered and checks if that
            character is the expected character.
            </summary>
            <param name="character">Character to check for.</param>
            <param name="str">String to parse.</param>
            <param name="index">
            Index to begin parsing at. Will be set to the index after expected character if found, or the index of the
            first non-white space character.
            </param>
            <returns>If the first non-white space encountered was the expected character.</returns>
        </member>
        <member name="M:KS.Reactor.JSONParser.ConsumeWhiteSpace(System.String,System.Int32@)">
            <summary>Advances the position in a string until a non-white space character is encountered.</summary>
            <param name="str">String to parse.</param>
            <param name="index">
            Index to begin consuming white-space at. Will be set to the index of the first non-white space character.
            </param>
        </member>
        <member name="M:KS.Reactor.JSONParser.IsWhiteSpace(System.Char)">
            <summary>Checks if a character is a white space character.</summary>
            <param name="character">Character to check.</param>
            <returns>True if the character is a white space character.</returns>
        </member>
        <member name="M:KS.Reactor.JSONParser.IsDelimiter(System.Char)">
            <summary>Checks if a character is a delimiter characer.</summary>
            <param name="character">Character to check.</param>
            <returns>True if the character is a delimiter character.</returns>
        </member>
        <member name="M:KS.Reactor.JSONParser.ThrowUnexpectedSymbol(System.String,System.Int32,System.String)">
            <summary>Thows an unexpected symbol exception.</summary>
            <param name="str">String with the unexpected symbol.</param>
            <param name="index">Index of unexpected symbol.</param>
            <param name="expected">Expected symbol (optional).</param>
        </member>
        <member name="M:KS.Reactor.JSONParser.PrintLineAndColumn(System.String,System.Int32)">
            <summary>
            Gets a string with the line and column number of a position in a string, in the format:
            "on line [line] at column [column]"
            </summary>
            <param name="str">String that contains the line and column number.</param>
            <param name="index">Index to get line and column number at.</param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.JSONParser.GetLineNumber(System.String,System.Int32,System.Int32@,System.Int32@)">
            <summary>Gets the line and column number at a position in a string.</summary>
            <param name="str">String that contains the line and column number.</param>
            <param name="index">Index to get line and column number at.</param>
            <param name="lineNumber">Line number to output.</param>
            <param name="column">Colume number to output.</param>
        </member>
        <member name="T:KS.Reactor.JSONPrinter">
            <summary>JSON serializer.</summary>
        </member>
        <member name="P:KS.Reactor.JSONPrinter.Instance">
            <summary>Singleton instance.</summary>
        </member>
        <member name="M:KS.Reactor.JSONPrinter.#ctor">
            <summary>Singleton constructor</summary>
        </member>
        <member name="M:KS.Reactor.JSONPrinter.Print(KS.Reactor.ksJSON,System.Boolean,System.Boolean)">
            <summary>Serializes JSON to a string.</summary>
            <param name="json">JSON to serialize.</param>
            <param name="pretty">If true, will print with indentation and multiple lines.</param>
            <param name="allowNaN">
            If true, will serialize NaN, infinity, and negative infinity to non-string literals that aren't part of the
            JSON standard. Otherwise these values are serialized as null.
            </param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.JSONPrinter.Print(KS.Reactor.ksJSON,System.Text.StringBuilder,System.Collections.Generic.HashSet{KS.Reactor.ksJSON},System.Int32,System.Boolean,System.Boolean)">
            <summary>Serializes JSON to a string.</summary>
            <param name="json">JSON to serialize.</param>
            <param name="builder">Builder to append serialized JSON to.</param>
            <param name="parents">Parents of this JSON. Used for circular reference detection.</param>
            <param name="depth"></param>
            <param name="pretty">If true, will print with indentation and multiple lines.</param>
            <param name="allowNaN">
            If true, will serialize NaN, infinity, and negative infinity to non-string literals that aren't part of the
            JSON standard. Otherwise these values are serialized as null.
            </param>
        </member>
        <member name="M:KS.Reactor.JSONPrinter.PrintObject(KS.Reactor.ksJSON,System.Text.StringBuilder,System.Collections.Generic.HashSet{KS.Reactor.ksJSON},System.Int32,System.Boolean,System.Boolean)">
            <summary>Serializes a JSON object.</summary>
            <param name="json">JSON to serialize.</param>
            <param name="builder">Builder to append serialized JSON to.</param>
            <param name="parents">Parents of this JSON. Used for circular reference detection.</param>
            <param name="depth"></param>
            <param name="pretty">If true, will print with indentation and multiple lines.</param>
            <param name="allowNaN">
            If true, will serialize NaN, infinity, and negative infinity to non-string literals that aren't part of the
            JSON standard. Otherwise these values are serialized as null.
            </param>
        </member>
        <member name="M:KS.Reactor.JSONPrinter.PrintArray(KS.Reactor.ksJSON,System.Text.StringBuilder,System.Collections.Generic.HashSet{KS.Reactor.ksJSON},System.Int32,System.Boolean,System.Boolean)">
            <summary>Serializes a JSON array.</summary>
            <param name="json">JSON to serialize.</param>
            <param name="builder">Builder to append serialized JSON to.</param>
            <param name="parents">Parents of this JSON. Used for circular reference detection.</param>
            <param name="depth"></param>
            <param name="pretty">If true, will print with indentation and multiple lines.</param>
            <param name="allowNaN">
            If true, will serialize NaN, infinity, and negative infinity to non-string literals that aren't part of the
            JSON standard. Otherwise these values are serialized as null.
            </param>
        </member>
        <member name="M:KS.Reactor.JSONPrinter.PrintFloat(System.Single,System.Text.StringBuilder,System.Boolean)">
            <summary>Serializes a float value.</summary>
            <param name="value">Value to serialize.</param>
            <param name="builder">Builder to append serialized JSON to.</param>
            <param name="allowNaN">
            If true, will serialize NaN, infinity, and negative infinity to non-string literals that aren't part of the
            JSON standard. Otherwise these values are serialized as null.
            </param>
        </member>
        <member name="M:KS.Reactor.JSONPrinter.PrintString(System.String,System.Text.StringBuilder)">
            <summary>Serializes a string value.</summary>
            <param name="str">String to serialize.</param>
            <param name="builder">Builder to append serialized JSON to.</param>
        </member>
        <member name="M:KS.Reactor.JSONPrinter.PrintLine(System.Text.StringBuilder,System.Int32,System.Boolean)">
            <summary>Appends a line to the serialized JSON if pretty is true.</summary>
            <param name="builder">Builder to append serialized JSON to.</param>
            <param name="depth">Determines indentation level.</param>
            <param name="pretty">If false, no line is printed.</param>
        </member>
        <member name="M:KS.Reactor.JSONPrinter.CheckCircularReference(KS.Reactor.ksJSON,System.Text.StringBuilder,System.Collections.Generic.HashSet{KS.Reactor.ksJSON})">
            <summary>
            Checks if a json container is in a hash set. If it is, serializes it as a error message string and logs a
            warning. Otherwise adds it to the set.
            </summary>
            <param name="json">JSON to check if we've already serialized.</param>
            <param name="builder">Builder to append serialized JSON to.</param>
            <param name="parents">Parents we've serialized. The json we're checking will be added to this set.</param>
            <returns>If we've already serialized the json container.</returns>
        </member>
        <member name="T:KS.Reactor.ksAsyncResultHandler">
            <summary>Delegate for cluster requests that return no results.</summary>
            <param name="asyncResult">Async result object.</param>
        </member>
        <member name="T:KS.Reactor.ksAsyncResultHandler`1">
            <summary>Delegate for cluster requests that return object results.</summary>
            <typeparam name="T"></typeparam>
            <param name="asyncResult">Async result object with result of type T.</param>
        </member>
        <member name="T:KS.Reactor.ksAsyncResult">
            <summary>Handles the tracking and response handling for asynchronous cluster requests.</summary>
        </member>
        <member name="P:KS.Reactor.ksAsyncResult.Id">
            <summary>Request token.</summary>
        </member>
        <member name="P:KS.Reactor.ksAsyncResult.AsyncState">
            <summary>User state object.</summary>
        </member>
        <member name="P:KS.Reactor.ksAsyncResult.AsyncWaitHandle">
            <summary>Wait Handle.</summary>
        </member>
        <member name="P:KS.Reactor.ksAsyncResult.CompletedSynchronously">
            <summary>Was the request completed immediately.</summary>
        </member>
        <member name="P:KS.Reactor.ksAsyncResult.IsCompleted">
            <summary>Is the request complete.</summary>
        </member>
        <member name="P:KS.Reactor.ksAsyncResult.Error">
            <summary>Error message.</summary>
        </member>
        <member name="P:KS.Reactor.ksAsyncResult.OnComplete">
            <summary>Callback to call when the task completes.</summary>
        </member>
        <member name="M:KS.Reactor.ksAsyncResult.#ctor">
            <summary>Constructor.</summary>
        </member>
        <member name="M:KS.Reactor.ksAsyncResult.#ctor(KS.Reactor.ksAsyncResultHandler,System.Object)">
            <summary>Constructor.</summary>
            <param name="onComplete">Completion handler.</param>
            <param name="asyncState">User state object.</param>
        </member>
        <member name="M:KS.Reactor.ksAsyncResult.Complete(System.String,System.Boolean)">
            <summary>Complete the request and call result handlers.</summary>
            <param name="error">Error message.</param>
            <param name="completedSynchronously">Completed synchronously (Default false)</param>
        </member>
        <member name="T:KS.Reactor.ksAsyncResult`1">
            <summary>
            Handles the tracking and response handling for asynchronous cluster requests that return results.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:KS.Reactor.ksAsyncResult`1.OnComplete">
            <summary>Callback to call when the task completes.</summary>
        </member>
        <member name="P:KS.Reactor.ksAsyncResult`1.Result">
            <summary>Results.</summary>
        </member>
        <member name="M:KS.Reactor.ksAsyncResult`1.#ctor">
            <summary>Constructor.</summary>
        </member>
        <member name="M:KS.Reactor.ksAsyncResult`1.#ctor(KS.Reactor.ksAsyncResultHandler{`0},System.Object)">
            <summary>Constructor.</summary>
            <param name="onComplete">Completion handler.</param>
            <param name="asyncState">User state object.</param>
        </member>
        <member name="M:KS.Reactor.ksAsyncResult`1.Complete(System.String,System.Boolean)">
            <summary>Complete the request with no result and call result handlers.</summary>
            <param name="error">Error message.</param>
            <param name="completedSynchronously">Completed synchronously (Default false).</param>
        </member>
        <member name="M:KS.Reactor.ksAsyncResult`1.Complete(`0,System.String,System.Boolean)">
            <summary>Complete the request and call result handlers.</summary>
            <param name="result">Result object.</param>
            <param name="error">Error message.</param>
            <param name="completedSynchronously">Completed synchronously (Default false).</param>
        </member>
        <member name="T:KS.Reactor.ksAtomic`1">
            <summary>Provides atomic access to a generic type.</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:KS.Reactor.ksAtomic`1.#ctor">
            <summary>Constructor.</summary>
        </member>
        <member name="M:KS.Reactor.ksAtomic`1.#ctor(`0)">
            <summary>Constructor</summary>
            <param name="value">Value to intialize with.</param>
        </member>
        <member name="P:KS.Reactor.ksAtomic`1.Value">
            <summary>Atomic getter/setter.</summary>
        </member>
        <member name="T:KS.Reactor.ksAtomicDictionary`2">
            <summary>Wraps a Dictionary to make all read/write operations thread safe.</summary>
            <typeparam name="Key"></typeparam>
            <typeparam name="Value"></typeparam>
        </member>
        <member name="T:KS.Reactor.ksAtomicDictionary`2.Factory">
            <summary>Factory delegate for creating a <typeparamref name="Value"/>.</summary>
            <returns>Value</returns>
        </member>
        <member name="T:KS.Reactor.ksAtomicDictionary`2.ForEachCallback">
            <summary>For each callback.</summary>
            <param name="pair">Pair being iterated</param>
            <returns>True to remove the pair from the dictionary.</returns>
        </member>
        <member name="P:KS.Reactor.ksAtomicDictionary`2.Item(`0)">
            <summary>Gets/Sets the value for a key.</summary>
            <param name="k">Key.</param>
            <returns>Value.</returns>
        </member>
        <member name="M:KS.Reactor.ksAtomicDictionary`2.Get(`0,`1)">
            <summary>Gets the value for a key.</summary>
            <param name="k">Key to get value for.</param>
            <param name="defaultValue">Default value to return if the key is not in the dictionary.</param>
            <returns>Value for the key.</returns>
        </member>
        <member name="M:KS.Reactor.ksAtomicDictionary`2.TryGetValue(`0,`1@)">
            <summary>Tries to get the value for a key.</summary>
            <param name="k">Key to get value for.</param>
            <param name="outValue">Out value.</param>
            <returns>True if succesful.</returns>
        </member>
        <member name="M:KS.Reactor.ksAtomicDictionary`2.TryAdd(`0,`1)">
            <summary>Tries to add the specified key and value to the dictionary.</summary>
            <param name="k">Key to add.</param>
            <param name="value">Value to add.</param>
            <returns>
            True if the key/value pair was added to the dictionary successfully; false if the key already exists.
            </returns>
        </member>
        <member name="M:KS.Reactor.ksAtomicDictionary`2.GetOrAddValue(`0,KS.Reactor.ksAtomicDictionary{`0,`1}.Factory,`1@)">
            <summary>
            Gets the value of a key from the dictionary. Creates a new value for the key by calling a factory and adds
            it to the dictionary if the key was not found.
            </summary>
            <param name="key">Key to get value for.</param>
            <param name="factory">Factory for creating the value if the key was not found.</param>
            <param name="value">The value for the key</param>
            <returns>True if the key was already in the dictionary, false if it was added with the factory.</returns>
        </member>
        <member name="M:KS.Reactor.ksAtomicDictionary`2.Clear">
            <summary>Removes everything from the dictionary.</summary>
        </member>
        <member name="M:KS.Reactor.ksAtomicDictionary`2.Remove(`0)">
            <summary>Removes a key/value pair from the dictionary.</summary>
            <param name="k">Key to remove.</param>
            <returns>True if they key was found and removed from the dictionary.</returns>
        </member>
        <member name="M:KS.Reactor.ksAtomicDictionary`2.Remove(`0,`1)">
            <summary>Removes a key/value pair from the dictionary if the value for the key matches the given value.</summary>
            <param name="k">Key to remove.</param>
            <param name="v">The key/value pair will only be removed if the value for the key matches this.</param>
            <returns>True if the key/value pair was removed.</returns>
        </member>
        <member name="M:KS.Reactor.ksAtomicDictionary`2.TryRemove(`0,`1@)">
            <summary>Tries to remove and return the value that has the specified key from the dictionary.</summary>
            <param name="k">Key to get value for.</param>
            <param name="outValue">
            The object removed from the dictionary, or the default value of the TValue type if key does not exist.
            </param>
            <returns>True if the object was removed successfully; otherwise, false.</returns>
        </member>
        <member name="M:KS.Reactor.ksAtomicDictionary`2.ContainsKey(`0)">
            <summary>Checks if a key is in the dictionary.</summary>
            <param name="k">Key to check.</param>
            <returns>True if the key is in the dictionary.</returns>
        </member>
        <member name="M:KS.Reactor.ksAtomicDictionary`2.ForEach(KS.Reactor.ksAtomicDictionary{`0,`1}.ForEachCallback)">
            <summary>Call a delegate function on each pair in the dictionary.</summary>
            <param name="callback"></param>
        </member>
        <member name="P:KS.Reactor.ksAtomicDictionary`2.Keys">
            <summary>Gets a collection of all keys.</summary>
        </member>
        <member name="P:KS.Reactor.ksAtomicDictionary`2.Values">
            <summary>Gets a collection of all values.</summary>
        </member>
        <member name="M:KS.Reactor.ksAtomicDictionary`2.ForEachThenClear(KS.Reactor.ksAtomicDictionary{`0,`1}.ForEachCallback)">
            <summary>
            Call a delegate function on each pair in the dictionary and then remove the pair if the callback returns
            true.
            </summary>
            <param name="callback"></param>
        </member>
        <member name="T:KS.Reactor.ksAtomicHashSet`1">
            <summary>Wraps a HashSet to make all read/write operations thread safe.</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:KS.Reactor.ksAtomicHashSet`1.ForEachCallback">
            <summary>
            Callback used when iterating all elements using <see cref="M:KS.Reactor.ksAtomicHashSet`1.ForEach(KS.Reactor.ksAtomicHashSet{`0}.ForEachCallback)"/>
            </summary>
            <param name="element">Element being iterated.</param>
            <returns>True if the iteration should continue after invoking this callback.</returns>
        </member>
        <member name="P:KS.Reactor.ksAtomicHashSet`1.Count">
            <summary>Number of values in the hash set.</summary>
        </member>
        <member name="M:KS.Reactor.ksAtomicHashSet`1.Add(`0)">
            <summary>Adds a value to the set.</summary>
            <param name="value">Value to add.</param>
            <returns>True if the value was not already in the set.</returns>
        </member>
        <member name="M:KS.Reactor.ksAtomicHashSet`1.Remove(`0)">
            <summary>Removes a value from the set.</summary>
            <param name="value">Value to remove.</param>
            <returns>True if the value was in the set.</returns>
        </member>
        <member name="M:KS.Reactor.ksAtomicHashSet`1.Contains(`0)">
            <summary>Checks if a value is in the set.</summary>
            <param name="value">Value to check for.</param>
            <returns>True if the value is in the set.</returns>
        </member>
        <member name="M:KS.Reactor.ksAtomicHashSet`1.Clear">
            <summary>Removes all values from the set.</summary>
        </member>
        <member name="M:KS.Reactor.ksAtomicHashSet`1.ForEach(KS.Reactor.ksAtomicHashSet{`0}.ForEachCallback)">
            <summary>
            Iterate the hash set invoking the callback for each element. If any callback returns false, then iteration
            stops. A read lock is placed on the hashset while iteration is taking place.
            </summary>
            <param name="callback">Callback to invoke for each set element.</param>
            <returns>True if all callbacks were invoked and returned true.</returns>
        </member>
        <member name="T:KS.Reactor.ksAtomicList`1">
            <summary>Wraps a list to make all read/write operations thread safe.</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:KS.Reactor.ksAtomicList`1.ForEachCallback">
            <summary>Iteration callback.</summary>
            <param name="element">Element being iterated.</param>
            <returns>False to stop iteration.</returns>
        </member>
        <member name="P:KS.Reactor.ksAtomicList`1.Count">
            <summary>Number of values in the list.</summary>
        </member>
        <member name="P:KS.Reactor.ksAtomicList`1.Item(System.Int32)">
            <summary>Gets/Sets the value at an index.</summary>
        </member>
        <member name="M:KS.Reactor.ksAtomicList`1.Get(System.Int32,`0)">
            <summary>Gets the value at an index.</summary>
            <param name="index">Index to get value at.</param>
            <param name="defaultValue">Default value to return if the index is outside the bounds of the list.</param>
            <returns>Value at the given index.</returns>
        </member>
        <member name="M:KS.Reactor.ksAtomicList`1.Set(System.Int32,`0)">
            <summary>Sets the value at an index, if that index is within the bounds of the list.</summary>
            <param name="index">Index to set value at.</param>
            <param name="value">Value to set.</param>
            <returns>True if the index was within the bounds of the list.</returns>
        </member>
        <member name="M:KS.Reactor.ksAtomicList`1.Add(`0)">
            <summary>Adds a value to the end of the list.</summary>
            <param name="value">Value to add.</param>
        </member>
        <member name="M:KS.Reactor.ksAtomicList`1.Remove(`0)">
            <summary>Removes a value from the list.</summary>
            <param name="value">Value to remove.</param>
            <returns>True if the value was found and removed.</returns>
        </member>
        <member name="M:KS.Reactor.ksAtomicList`1.RemoveAt(System.Int32)">
            <summary>Removes the value at an index.</summary>
            <param name="index">Index to remove value at.</param>
        </member>
        <member name="M:KS.Reactor.ksAtomicList`1.RemoveRange(System.Int32,System.Int32)">
            <summary>Removes a range of values from the list.</summary>
            <param name="index">Index to remove from.</param>
            <param name="count">Number of values to remove.</param>
        </member>
        <member name="M:KS.Reactor.ksAtomicList`1.RemoveAll(System.Predicate{`0})">
            <summary>Removes all values that match a predicate.</summary>
            <param name="match">Returns true to remove the value.</param>
            <returns>The number of values removed.</returns>
        </member>
        <member name="M:KS.Reactor.ksAtomicList`1.Clear">
            <summary>Clears the list.</summary>
        </member>
        <member name="M:KS.Reactor.ksAtomicList`1.Iterate">
            <summary>
            Returns an iterator that can be used to safely iterate the list while other threads are iterating and/or
            modifying the list.
            
            Example usage:
            
             AtomicIterator &lt;T&gt; iter = list.Iterate();
             while (iter.Next())
             {
                 T value = iter.Value;
                 ... do stuff
             }
            </summary>
            <returns>Iterator.</returns>
        </member>
        <member name="M:KS.Reactor.ksAtomicList`1.ForEach(KS.Reactor.ksAtomicList{`0}.ForEachCallback)">
            <summary>
            Iterates the list invoking the callback for each element. If any callback returns false, then iteration
            stops. A read lock is placed on the list while iteration is taking place.
            </summary>
            <param name="callback">Callback to invoke for each list element.</param>
            <returns>True if all callbacks were invoked and returned true.</returns>
        </member>
        <member name="M:KS.Reactor.ksAtomicList`1.ToArray">
            <summary>Returns an array that contains all elements in the list.</summary>
            <returns>Array that contains all elements in the list.</returns>
        </member>
        <member name="M:KS.Reactor.ksAtomicList`1.RemoveIndex(System.Int32)">
            <summary>Removes the value at an index, and updates the index of all effected active iterators.</summary>
            <param name="index">Index to remove value at.</param>
        </member>
        <member name="M:KS.Reactor.ksAtomicList`1.Next(KS.Reactor.ksAtomicList{`0}.Iterator)">
            <summary>
            Returns the next value in the list. Can be used to safely iterate while other threads are iterating and/or
            modifying the list.
            </summary>
            <param name="iter">Iterator that tracks where we are in the list.</param>
            <returns>False if we reached the end of the list.</returns>
        </member>
        <member name="T:KS.Reactor.ksAtomicList`1.Iterator">
            <summary>Holds index and value data used when iterating an atomic list.</summary>
        </member>
        <member name="F:KS.Reactor.ksAtomicList`1.Iterator.Index">
            <summary>The index being iterated.</summary>
        </member>
        <member name="F:KS.Reactor.ksAtomicList`1.Iterator.Value">
            <summary>The value at the current index.</summary>
        </member>
        <member name="M:KS.Reactor.ksAtomicList`1.Iterator.#ctor(KS.Reactor.ksAtomicList{`0})">
            <summary>Constructor</summary>
            <param name="list"></param>
        </member>
        <member name="M:KS.Reactor.ksAtomicList`1.Iterator.Next">
            <summary>
            Advances to the next value in the list. Can be used to safely iterate while other threads are iterating
            and/or modifying the list.
            </summary>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksAtomicList`1.Iterator.GetEnumerator">
            <summary>
            Iterates the list from the beginning. Can be used to safely iterate while other threads are iterating
            and/or modifying the list.
            </summary>
            <returns>Enumerator</returns>
        </member>
        <member name="M:KS.Reactor.ksAtomicList`1.Iterator.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Iterates the list from the beginning. Can be used to safely iterate while other threads are iterating
            and/or modifying the list.
            </summary>
            <returns>Enumerator</returns>
        </member>
        <member name="T:KS.Reactor.ksAtomicQueue`1">
            <summary>Wraps a Queue to make all read/write operations thread safe.</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:KS.Reactor.ksAtomicQueue`1.Count">
            <summary>Number of values in the queue.</summary>
        </member>
        <member name="M:KS.Reactor.ksAtomicQueue`1.Enqueue(`0)">
            <summary>Adds a value to the end of the queue.</summary>
            <param name="value">Value to add.</param>
        </member>
        <member name="M:KS.Reactor.ksAtomicQueue`1.Dequeue">
            <summary>Removes the first value in the queue.</summary>
            <returns>Value removed from the queue.</returns>
        </member>
        <member name="M:KS.Reactor.ksAtomicQueue`1.TryDequeue(`0@)">
            <summary>Tries to remove and return the object at the beginning of the queue.</summary>
            <param name="outValue">
            If the operation was successful, outValue contains the object removed.
            If no object was available to be removed, the value is the default T value.
            </param>
            <returns>True if an element was removed and returned from the beginning of the queue.</returns>
        </member>
        <member name="M:KS.Reactor.ksAtomicQueue`1.Peek">
            <summary>Returns the first value without removing it from the queue.</summary>
            <returns>First value in queue.</returns>
        </member>
        <member name="M:KS.Reactor.ksAtomicQueue`1.Clear">
            <summary>Removes everything from the queue.</summary>
        </member>
        <member name="M:KS.Reactor.ksAtomicQueue`1.ToArray">
            <summary>Converts the queueto an array.</summary>
            <returns>An array of all the data in the queue.</returns>
        </member>
        <member name="T:KS.Reactor.ksBaseAssetLoader">
            <summary>Abstract base class for asset loaders that load and cache <see cref="T:KS.Reactor.ksScriptAsset"/>s.</summary>
        </member>
        <member name="F:KS.Reactor.ksBaseAssetLoader.m_cache">
            <summary>Cache of loaded assets. Keys are asset ids.</summary>
        </member>
        <member name="F:KS.Reactor.ksBaseAssetLoader.m_paths">
            <summary>
            Map of asset ids to asset paths. It is the responsibility of the derived class to fill this map before
            assets can be loaded.
            </summary>
        </member>
        <member name="F:KS.Reactor.ksBaseAssetLoader.m_pathToIdMap">
            <summary>
            Map of asset paths to asset ids. It is the responsibility of the derived class to fill this map before
            assets can be loaded.
            </summary>
        </member>
        <member name="F:KS.Reactor.ksBaseAssetLoader.m_nameToIdMap">
            <summary>
            Maps asset names to a list of all asset ids with that name. It is the responsibility of the derived class
            to fill this map before assets can be loaded.
            </summary>
        </member>
        <member name="M:KS.Reactor.ksBaseAssetLoader.Load``1(System.UInt32,System.Boolean)">
            <summary>Loads an asset.</summary>
            <typeparam name="T">Type of asset to load.</typeparam>
            <param name="assetId">Id of the asset to load.</param>
            <param name="silent">If true, don't log warnings if the asset isn't found or is the wrong type.</param>
            <returns>The loaded asset, or null if the asset could not be loaded or was the wrong type.</returns>
        </member>
        <member name="M:KS.Reactor.ksBaseAssetLoader.Get``1(System.UInt32,System.Boolean)">
            <summary>Gets an asset from the cache, or loads it if it is not in the cache.</summary>
            <typeparam name="T">Type of asset to get.</typeparam>
            <param name="assetId">Id of the asset to get.</param>
            <param name="silent">If true, don't log warnings if the asset isn't found or is the wrong type.</param>
            <returns>The loaded asset, or null if the asset could not be loaded or was the wrong type.</returns>
        </member>
        <member name="M:KS.Reactor.ksBaseAssetLoader.Get``1(System.String)">
            <summary>
            Gets an asset by path or name. Loads the asset if it is not already loaded. If there are multiple assets
            with the same name, returns the first one that matches the type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">Type of asset to get.</typeparam>
            <param name="pathOrName">Asset path or asset name.</param>
            <returns>The loaded asset, or null if the asset could not be loaded or was the wrong type.</returns>
        </member>
        <member name="M:KS.Reactor.ksBaseAssetLoader.CreateInstance``1(System.UInt32,System.Boolean)">
            <summary>Creates a new instance of an asset.</summary>
            <typeparam name="T">Type of asset</typeparam>
            <param name="assetId">Asset id</param>
            <param name="silent">If true, don't log warnings if the asset isn't found or is the wrong type.</param>
            <returns>Asset instance, or null if the asset could not be loaded or was the wrong type.</returns>
        </member>
        <member name="M:KS.Reactor.ksBaseAssetLoader.CreateInstance``1(System.String)">
            <summary>
            Creates a new instance of an asset. If there are multiple assets with the same name, creates a new instance
            of the first one that matches the type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">Type of asset</typeparam>
            <param name="pathOrName">Asset path or asset name.</param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksBaseAssetLoader.Unload(KS.Reactor.ksScriptAsset)">
            <summary>
            Removes an asset from the cache, allowing it to be garbage collected when there are no more references to
            it. Subsequent calls to <see cref="M:KS.Reactor.ksBaseAssetLoader.Get``1(System.UInt32,System.Boolean)"/> will return a different instance of the asset.
            </summary>
            <param name="asset">Asset to remove from the cache.</param>
            <returns>True if the asset was removed from the cache. False if the asset was not in the cache.</returns>
        </member>
        <member name="M:KS.Reactor.ksBaseAssetLoader.GetId(System.String,System.Boolean)">
            <summary>
            Gets an asset id from an asset path or name. If there is more than one asset with the same name, logs a
            warning and returns zero.
            </summary>
            <param name="pathOrName">Asset path or asset name.</param>
            <param name="fullPathOnly">If true, will only try to get the asset id by asset path.</param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksBaseAssetLoader.GetPath(System.UInt32)">
            <summary>Gets an asset path from an asset id.</summary>
            <param name="assetId">Asset id</param>
            <returns>Asset path, or null if there is no asset with that id.</returns>
        </member>
        <member name="M:KS.Reactor.ksBaseAssetLoader.MapNameToId(System.String,System.UInt32)">
            <summary>Adds a mapping between an asset name and an asset id.</summary>
            <param name="name">Asset name</param>
            <param name="id">Asset id</param>
        </member>
        <member name="M:KS.Reactor.ksBaseAssetLoader.GetCached(System.UInt32)">
            <summary>Gets an asset from the cache.</summary>
            <param name="assetId">Asset id</param>
            <returns>The asset, or null if it was not in the cache.</returns>
        </member>
        <member name="M:KS.Reactor.ksBaseAssetLoader.CacheAsset(System.UInt32,KS.Reactor.ksScriptAsset)">
            <summary>Adds an asset to the cache and sets its id and path.</summary>
            <param name="assetId">Asset id. There must be an associated asset path in <see cref="F:KS.Reactor.ksBaseAssetLoader.m_paths"/>.</param>
            <param name="asset">Asset to cache.</param>
        </member>
        <member name="T:KS.Reactor.ksQueryFlags">
            <summary>Additional flags used to filter physic scene queries.</summary>
        </member>
        <member name="F:KS.Reactor.ksQueryFlags.STATIC">
            <summary>Test static entities.</summary>
        </member>
        <member name="F:KS.Reactor.ksQueryFlags.DYNAMIC">
            <summary>Test dynamic and kinematic entities.</summary>
        </member>
        <member name="F:KS.Reactor.ksQueryFlags.EXCLUDE_OVERLAPS">
            <summary>Exclude results that start overlapping. Ignored for overlap queries.</summary>
        </member>
        <member name="F:KS.Reactor.ksQueryFlags.NO_BLOCK">
            <summary>Blocking hits will not stop the query.</summary>
        </member>
        <member name="F:KS.Reactor.ksQueryFlags.EXCLUDE_TOUCHES">
            <summary>Exclude touching hits from results.</summary>
        </member>
        <member name="F:KS.Reactor.ksQueryFlags.USE_DISABLED_COLLIDERS">
            <summary>
            Use disabled colliders from the query entity in entity or collider queries. Does nothing for shape queries.
            This will not return hits with disabled colliders in the results.
            </summary>
        </member>
        <member name="F:KS.Reactor.ksQueryFlags.DEFAULT">
            <summary>Return all static and dynamic entity hits and exclude initial overlaps.</summary>
        </member>
        <member name="F:KS.Reactor.ksQueryFlags.PHYS_X_FLAGS">
            <summary>
            Bitmask of flags that are defined in PhysX.
            </summary>
        </member>
        <member name="T:KS.Reactor.ksBasePhysics">
            <summary>Base physics class available on client and server.</summary>
        </member>
        <member name="F:KS.Reactor.ksBasePhysics.NEAR_ZERO">
            <summary>
            To fix issues due to rounding point errors, some calculations use this as a tolerance value.
            </summary>
        </member>
        <member name="T:KS.Reactor.ksBasePhysics.DepenetrateCallback">
            <summary>
            Depenetration callback for 
            <see cref="M:KS.Reactor.ksBasePhysics.Depenetrate(KS.Reactor.ksOverlapParams,KS.Reactor.ksVector3@,KS.Reactor.ksBasePhysics.DepenetrateCallback,System.Single)"/>
            </summary>
            <param name="collider">Collider being penetrated.</param>
            <param name="direction">
            Minimum depenetration movement direction. Can be changed to alter movement direction.
            </param>
            <param name="distance">
            Minimum depenetration movement distance. Can be changed to alter the movement distance. Set to zero to
            ignore the penetration.
            </param>
            <returns>False to cancel all depenetrations.</returns>
        </member>
        <member name="P:KS.Reactor.ksBasePhysics.AutoSync">
            <summary>
            If true, transform changes are synced with the physics system and stale inertia tensors and centers of mass
            are recalculated automatically before any physics queries. If this is false, changes are only synced during
            the simulation step, and you are responsible for calling Sync if you want to sync changes sooner.
            </summary>
        </member>
        <member name="P:KS.Reactor.ksBasePhysics.Gravity">
            <summary>Gets the current gravity in the scene.</summary>
        </member>
        <member name="M:KS.Reactor.ksBasePhysics.SyncAll">
            <summary>
            Apply all transform and rigidbody changes to the physics simulation now rather than waiting for the next
            simulation step.
            </summary>
        </member>
        <member name="M:KS.Reactor.ksBasePhysics.SyncTransforms">
            <summary>
            Apply entity transform updates to the physics simulation now rather than
            waiting for the next simulation step.
            </summary>
        </member>
        <member name="M:KS.Reactor.ksBasePhysics.RaycastAny(KS.Reactor.ksRaycastParams)">
            <summary>Raycast query that checks if anything was hit.</summary>
            <param name="args">Raycast parameters</param>
            <returns>True if the raycast hit anything.</returns>
        </member>
        <member name="M:KS.Reactor.ksBasePhysics.RaycastNearest(KS.Reactor.ksRaycastParams,KS.Reactor.ksRaycastResult@)">
            <summary>Raycast query that finds the nearest hit.</summary>
            <param name="args">Raycast parameters</param>
            <param name="hit">Set to the nearest hit.</param>
            <returns>True if the raycast hit anything.</returns>
        </member>
        <member name="M:KS.Reactor.ksBasePhysics.Raycast(KS.Reactor.ksRaycastParams)">
            <summary>
            Raycast query that returns the nearest blocking hit and any touching hits before the blocking hit.
            </summary>
            <param name="args">Raycast parameters</param>
            <returns>Raycast results</returns>
        </member>
        <member name="M:KS.Reactor.ksBasePhysics.SweepAny(KS.Reactor.ksSweepParams)">
            <summary>Sweep query that checks if anything was hit.</summary>
            <param name="args">Sweep arguments</param>
            <returns>True if the sweep hit anything.</returns>
        </member>
        <member name="M:KS.Reactor.ksBasePhysics.SweepNearest(KS.Reactor.ksSweepParams,KS.Reactor.ksSweepResult@)">
            <summary>Sweep query that finds the nearest hit.</summary>
            <param name="args">Sweep arguments</param>
            <param name="hit">Set to the nearest hit.</param>
            <returns>True if the sweep hit anything.</returns>
        </member>
        <member name="M:KS.Reactor.ksBasePhysics.Sweep(KS.Reactor.ksSweepParams)">
            <summary>
            Sweep query that returns the nearest blocking hit and any touching hits before the blocking hit.
            </summary>
            <param name="args">Sweep parameters</param>
            <returns>Sweep results</returns>
        </member>
        <member name="M:KS.Reactor.ksBasePhysics.OverlapAny(KS.Reactor.ksOverlapParams)">
            <summary>Overlap query that checks for any overlap.</summary>
            <param name="args">Overlap parameters</param>
            <returns>True if anything was overlapping.</returns>
        </member>
        <member name="M:KS.Reactor.ksBasePhysics.Overlap(KS.Reactor.ksOverlapParams)">
            <summary>Overlap query.</summary>
            <param name="args">Overlap parameters</param>
            <returns>List of overlap results.</returns>
        </member>
        <member name="M:KS.Reactor.ksBasePhysics.Raycast(KS.Reactor.ksVector3,KS.Reactor.ksVector3,System.Single,System.Boolean,KS.Reactor.ksQueryFlags,System.UInt32,System.UInt32)">
            <summary>Raycast.</summary>
            <param name="origin">Origin point.</param>
            <param name="direction">Direction vector.</param>
            <param name="distance">Ray distance.</param>
            <param name="groupMask">Bit mask of collsion groups.</param>
            <param name="includeOverlaps">Include entities that overlap the origin.</param>
            <param name="flags">Bit flags for filtering static, dynamic, and first hit.</param>
            <param name="maxResults">Unused</param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksBasePhysics.Sweep(KS.Reactor.ksShape,KS.Reactor.ksVector3,KS.Reactor.ksQuaternion,KS.Reactor.ksVector3,System.Single,System.Boolean,KS.Reactor.ksQueryFlags,System.UInt32,System.UInt32)">
            <summary>Shape sweep.</summary>
            <param name="shape">Primitive or convex shape.</param>
            <param name="origin">Origin point.</param>
            <param name="rotation">Shape orientation.</param>
            <param name="direction">Direction vector.</param>
            <param name="distance">Sweep distance.</param>
            <param name="includeOverlaps">Include entities that overlap at the origin.</param>
            <param name="flags">Bit flags for filtering static, dynamic, and first hit.</param>
            <param name="groupMask">Bit mask of collsion groups.</param>
            <param name="maxResults">Unused</param>
            <returns>List of sweep results.</returns>
        </member>
        <member name="M:KS.Reactor.ksBasePhysics.Sweep(KS.Reactor.ksIEntity,KS.Reactor.ksVector3,System.Single,System.Boolean,KS.Reactor.ksQueryFlags,System.UInt32,System.UInt32)">
            <summary>Entity sweep using the current position and rotation as starting points.</summary>
            <param name="entity">Entity.</param>
            <param name="direction">Direction vector.</param>
            <param name="distance">Ray distance.</param>
            <param name="includeOverlaps">Include entities that overlap at the origin.</param>
            <param name="flags">Bit flags for filtering static, dynamic, and first hit.</param>
            <param name="groupMask">Bit mask of collsion groups.</param>
            <param name="maxResults">Unused</param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksBasePhysics.Sweep(KS.Reactor.ksIEntity,KS.Reactor.ksVector3,KS.Reactor.ksQuaternion,KS.Reactor.ksVector3,System.Single,System.Boolean,System.Boolean,KS.Reactor.ksQueryFlags,System.UInt32,System.UInt32)">
            <summary>Entity sweep.</summary>
            <param name="entity">Entity.</param>
            <param name="origin">Origin point.</param>
            <param name="rotation">Entity orientation.</param>
            <param name="direction">Direction vector.</param>
            <param name="distance">Sweep distance.</param>
            <param name="excludeSelf">Exclude this entity in the returned results.</param>
            <param name="includeOverlaps">Include entities that overlap at the origin.</param>
            <param name="flags">Bit flags for filtering static, dynamic, and first hit.</param>
            <param name="groupMask">Bit mask of collsion groups.</param>
            <param name="maxResults">Unused</param>
            <returns>List of sweep results.</returns>
        </member>
        <member name="M:KS.Reactor.ksBasePhysics.Overlap(KS.Reactor.ksShape,KS.Reactor.ksVector3,KS.Reactor.ksQuaternion,KS.Reactor.ksQueryFlags,System.UInt32,System.UInt32)">
            <summary>Shape overlap.</summary>
            <param name="shape">Primitive or convex shape.</param>
            <param name="origin">Origin point.</param>
            <param name="rotation">Shape orientation.</param>
            <param name="flags">Bit flags for filtering static, dynamic, and first hit.</param>
            <param name="groupMask">Bit mask of collsion groups.</param>
            <param name="maxResults">Unused</param>
            <returns>List of overlap results.</returns>
        </member>
        <member name="M:KS.Reactor.ksBasePhysics.Overlap(KS.Reactor.ksIEntity,KS.Reactor.ksVector3,KS.Reactor.ksQuaternion,System.Boolean,KS.Reactor.ksQueryFlags,System.UInt32,System.UInt32)">
            <summary>Entity overlap.</summary>
            <param name="entity">Entity.</param>
            <param name="origin">Entity point.</param>
            <param name="rotation">Entity orientation.</param>
            <param name="excludeSelf">Exclude this entity in the returned results.</param>
            <param name="flags">Bit flags for filtering static, dynamic, and first hit.</param>
            <param name="groupMask">Bit mask of collsion groups.</param>
            <param name="maxResults">Unused</param>
            <returns>List of overlap results.</returns>
        </member>
        <member name="M:KS.Reactor.ksBasePhysics.ComputePenetration(KS.Reactor.ksICollider,KS.Reactor.ksVector3,KS.Reactor.ksQuaternion,KS.Reactor.ksICollider,KS.Reactor.ksVector3,KS.Reactor.ksQuaternion,KS.Reactor.ksVector3@,System.Single@)">
            <summary>
            Compute the minimal translation required to separate the given colliders apart at specified poses.
            </summary>
            <param name="collider0">First collider to test.</param>
            <param name="position0">Position of collider 0.</param>
            <param name="rotation0">Rotation of collider 0.</param>
            <param name="collider1">Secoond collider to test.</param>
            <param name="position1">Position of collider 1.</param>
            <param name="rotation1">Rotation of collider 1.</param>
            <param name="direction">
            Direction along which the translation required to separate <paramref name="collider0"/> from
            <paramref name="collider1"/> is minimal.
            </param>
            <param name="distance">
            The distance along the direction that is required to separate <paramref name="collider0"/> from
            <paramref name="collider1"/>.
            </param>
            <returns>True if the colliders were overlapping.</returns>
        </member>
        <member name="M:KS.Reactor.ksBasePhysics.GetClosestPoint(KS.Reactor.ksVector3,KS.Reactor.ksICollider)">
            <summary>
            Get the closest point on a collider to another point.
            Currently supported colliders: box, sphere, capsule, convexmesh.
            </summary>
            <param name="point">Point to measure from.</param>
            <param name="collider">Collider to get the closest point from.</param>
            <returns>Closest point on the collider.</returns>
        </member>
        <member name="M:KS.Reactor.ksBasePhysics.GetClosestPoint(KS.Reactor.ksVector3,KS.Reactor.ksICollider,KS.Reactor.ksVector3,KS.Reactor.ksQuaternion)">
            <summary>
            Get the closest point on a collider to another point.
            Currently supported colliders: box, sphere, capsule, convexmesh.
            </summary>
            <param name="point">Point to measure from.</param>
            <param name="collider">Collider to get the closest point from.</param>
            <param name="position">Collider position</param>
            <param name="rotation">Collider rotation</param>
            <returns>Closest point on the collider.</returns>
        </member>
        <member name="M:KS.Reactor.ksBasePhysics.CreateSimulationQueryParams(KS.Reactor.ksIEntity,System.Boolean)">
            <summary>
            Creates <see cref="T:KS.Reactor.ksSweepSlideParams"/> for an entity configured to use simulation rules. Anything the
            entity would collide with are blocking hits and optionally anything it would receive overlap events with
            are touching hits. This sets the <see cref="F:KS.Reactor.ksBaseQueryParams.Filter"/> and 
            <see cref="F:KS.Reactor.ksOverlapParams.EntityColliderFilter"/> to a <see cref="T:KS.Reactor.ksSimulationFilter"/>, and sets the
            <see cref="F:KS.Reactor.ksBaseQueryParams.ExcludeEntity"/> to the <paramref name="entity"/>.
            </summary>
            <param name="entity">Query entity</param>
            <param name="excludeTouches">If true, sets the <see cref="F:KS.Reactor.ksQueryFlags.EXCLUDE_TOUCHES"/> flag.</param>
            <returns>Overlap params using simulation rules.</returns>
        </member>
        <member name="M:KS.Reactor.ksBasePhysics.Depenetrate(KS.Reactor.ksOverlapParams,KS.Reactor.ksVector3@,KS.Reactor.ksBasePhysics.DepenetrateCallback,System.Single)">
            <summary>
            Does an overlap query and calcuates a depenetration delta to attempt to depenetrate from overlapping
            geometry. If the overlap query returns multiple results the depenetration vector from the previous overlap
            will be added to the position when computing the depenetration vector for the next overlap. This may result
            in pushing the object back into the first overlapping geometry. Geometry that the object gets pushed into
            by the depenetration vector that was not initially overlapping will not be considered.
            </summary>
            <param name="args">Overlap query parameters. The query object cannot be a shape.</param>
            <param name="delta">Depenetration delta</param>
            <param name="callback">
            Callback to call for each overlapping collider. Can be used to alter the depenetration vector for each
            collider, or to cancel the entire depenetration by returning false.
            </param>
            <param name="separationOffset">
            Amount to add to the depenetration distance for each overlapping collider. Helps prevent penetrations when
            sweeping.
            </param>
            <returns>True if there was a penetration.</returns>
        </member>
        <member name="M:KS.Reactor.ksBasePhysics.SweepAndSlide(KS.Reactor.ksSweepSlideParams,KS.Reactor.ksVector3@)">
            <summary>
            Does sweep-and-slide movement. When a sweep hits something, the remaining movement vector is projected onto
            the plane perpendicuar to the surface normal to get a new movement vector which is used to sweep 
            recursively.
            </summary>
            <param name="args">Sweep parameters</param>
            <param name="position">Position at the end of the sweep-and-slide movement.</param>
            <returns>True if the sweep and slide hit anything.</returns>
        </member>
        <member name="M:KS.Reactor.ksBasePhysics.SweepAndSlide(KS.Reactor.ksSweepSlideParams,KS.Reactor.ksVector3,KS.Reactor.ksVector3@,System.Int32,KS.Reactor.ksVector3)">
            <summary>
            Does sweep-and-slide movement. When a sweep hits something, the remaining movement vector is projected onto
            the plane perpendicuar to the surface normal to get a new movement vector which is used to sweep 
            recursively.
            </summary>
            <param name="args">Sweep parameters</param>
            <param name="originalDirection">Orginal direction of movement.</param>
            <param name="position">Position at the end of the sweep-and-slide movement.</param>
            <param name="iterations">Number of sweep-and-slide iterations remaining.</param>
            <param name="otherContactNormal">
            If the previous sweep didn't cause any movement, this is the contact normal from the previous sweep. We
            know we are still in contact with this surface and will use it to calculate a new slide direction and
            prevent getting stuck if this sweep hits a different surface before we can move.
            </param>
            <returns>True if the sweep and slide hit anything.</returns>
        </member>
        <member name="T:KS.Reactor.ksQueryTypes">
            <summary>Types of queries</summary>
        </member>
        <member name="T:KS.Reactor.ksQueryObjectTypes">
            <summary>Types of query objects</summary>
        </member>
        <member name="T:KS.Reactor.ksBaseQueryParams">
            <summary>Base class containing parameters used in all physics queries.</summary>
        </member>
        <member name="P:KS.Reactor.ksBaseQueryParams.Origin">
            <summary>The starting position of the physics query.</summary>
        </member>
        <member name="F:KS.Reactor.ksBaseQueryParams.Filter">
            <summary>Query filter for filtering results. If null, all hits are touching.</summary>
        </member>
        <member name="F:KS.Reactor.ksBaseQueryParams.ExcludeEntity">
            <summary>This entity is excluded from results.</summary>
        </member>
        <member name="F:KS.Reactor.ksBaseQueryParams.Flags">
            <summary>Query flags for filtering results.</summary>
        </member>
        <member name="P:KS.Reactor.ksBaseQueryParams.QueryType">
            <summary>Query type</summary>
        </member>
        <member name="P:KS.Reactor.ksBaseQueryParams.ObjectType">
            <summary>The object type used in the query.</summary>
        </member>
        <member name="M:KS.Reactor.ksBaseQueryParams.Validate(System.Boolean)">
            <summary>Checks if the parameters are valid. The base implementation is always valid.</summary>
            <param name="log">If true, logs warnings describing what is invalid if anything is invalid.</param>
            <returns>True if the params are valid.</returns>
        </member>
        <member name="M:KS.Reactor.ksBaseQueryParams.CopyTo(KS.Reactor.ksBaseQueryParams)">
            <summary>
            Copies the values from this object to the <paramref name="target"/>. <see cref="P:KS.Reactor.ksBaseQueryParams.Origin"/> is not copied. To copy
            <see cref="P:KS.Reactor.ksBaseQueryParams.Origin"/>, use one of the derived class CopyTo methods.
            </summary>
            <param name="target">Target to copy to.</param>
        </member>
        <member name="T:KS.Reactor.ksBitIStream">
            <summary>Bit stream writer</summary>
        </member>
        <member name="M:KS.Reactor.ksBitIStream.#ctor(System.Collections.Generic.IList{System.Byte})">
            <summary>Constructor</summary>
            <param name="data">data to read from.</param>
        </member>
        <member name="M:KS.Reactor.ksBitIStream.ReadBits(System.Int32)">
            <summary>Reads up to 32 bits from the buffer.</summary>
            <param name="bits">Number of bits to read.</param>
            <returns>Value</returns>
        </member>
        <member name="M:KS.Reactor.ksBitIStream.ReadBits64(System.Int32)">
            <summary>Reads up to 64 bits from the buffer.</summary>
            <param name="bits">Number of bits to read.</param>
            <returns>Value</returns>
        </member>
        <member name="M:KS.Reactor.ksBitIStream.ReadBits(System.UInt32@,System.Int32)">
            <summary>Reads up to 32 bits from the buffer.</summary>
            <param name="output">Output to write value to.</param>
            <param name="bits">Number of bits to read.</param>
        </member>
        <member name="M:KS.Reactor.ksBitIStream.ReadBits64(System.UInt64@,System.Int32)">
            <summary>Reads up to 64 bits from the buffer.</summary>
            <param name="output">Output to write value to.</param>
            <param name="bits">Number of bits to read.</param>
        </member>
        <member name="M:KS.Reactor.ksBitIStream.ReadEncodedUInt">
            <summary>Reads a uint.</summary>
            <returns>Value.</returns>
        </member>
        <member name="M:KS.Reactor.ksBitIStream.ReadEncodedInt">
            <summary>Reads an int converted from a uint.</summary>
            <returns>Value.</returns>
        </member>
        <member name="M:KS.Reactor.ksBitIStream.ReadEncodedULong">
            <summary>Reads a ulong.V</summary>
            <returns>Value.</returns>
        </member>
        <member name="M:KS.Reactor.ksBitIStream.ReadEncodedLong">
            <summary>Reads a long converted from a ulong.</summary>
            <returns>Value.</returns>
        </member>
        <member name="M:KS.Reactor.ksBitIStream.ReadEncodedString">
            <summary>Reads a string.</summary>
            <returns>Value.</returns>
        </member>
        <member name="M:KS.Reactor.ksBitIStream.ReadMultiType">
            <summary>Reads a multi type.</summary>
            <returns>Value.</returns>
        </member>
        <member name="M:KS.Reactor.ksBitIStream.Align">
            <summary>Advances the position to the next byte if the position is not at a byte boundary.</summary>
        </member>
        <member name="M:KS.Reactor.ksBitIStream.SeekOffset(System.Int32)">
            <summary>Adds an offset to the current position.</summary>
            <param name="offset">Offset to add in bytes.</param>
        </member>
        <member name="M:KS.Reactor.ksBitIStream.Seek(System.Int32)">
            <summary>Seeks to a byte position.</summary>
            <param name="position">Position to seek to.</param>
        </member>
        <member name="M:KS.Reactor.ksBitIStream.SeekBit(System.Int32)">
            <summary>Seeks to a bit position.</summary>
            <param name="bit">Bit to seek to.</param>
        </member>
        <member name="M:KS.Reactor.ksBitIStream.GetPosition">
            <summary>Gets tje current byte position.</summary>
            <returns>Current byte position.</returns>
        </member>
        <member name="M:KS.Reactor.ksBitIStream.GetBitPosition">
            <summary>Gets the current bit position.</summary>
            <returns>Current bit position.</returns>
        </member>
        <member name="M:KS.Reactor.ksBitIStream.GetRemaining">
            <summary>Gets the number of bytes in the buffer after the current position.</summary>
            <returns>Number of bytes in the buffer after the current position.</returns>
        </member>
        <member name="T:KS.Reactor.ksBitOStream">
            <summary>Bit stream reader</summary>
        </member>
        <member name="M:KS.Reactor.ksBitOStream.#ctor(System.Collections.Generic.List{System.Byte})">
            <summary>Constructor</summary>
            <param name="buffer">buffer to write to.</param>
        </member>
        <member name="M:KS.Reactor.ksBitOStream.WriteBits(System.UInt32,System.Int32)">
            <summary>Writes up to 32 bits into the buffer.</summary>
            <param name="input">input to write bits from.</param>
            <param name="bits">number of bits from input to write.</param>
        </member>
        <member name="M:KS.Reactor.ksBitOStream.WriteBits64(System.UInt64,System.Int32)">
            <summary>Writes up to 64 bits into the buffer.</summary>
            <param name="input">input to write bits from.</param>
            <param name="bits">number of bits from input to write.</param>
        </member>
        <member name="M:KS.Reactor.ksBitOStream.WriteEncodedValue(System.UInt32)">
            <summary>Writes a uint.</summary>
            <param name="input">input to write.</param>
        </member>
        <member name="M:KS.Reactor.ksBitOStream.WriteEncodedValue(System.Int32)">
            <summary>Writes an int converted to a uint.</summary>
            <param name="input">input to write.</param>
        </member>
        <member name="M:KS.Reactor.ksBitOStream.WriteEncodedValue(System.UInt64)">
            <summary>Writes a ulong.</summary>
            <param name="input">input to write.</param>
        </member>
        <member name="M:KS.Reactor.ksBitOStream.WriteEncodedValue(System.Int64)">
            <summary>Writes a long converted to a ulong.</summary>
            <param name="input">input to write.</param>
        </member>
        <member name="M:KS.Reactor.ksBitOStream.WriteEncodedValue(System.String)">
            <summary>Writes a string. Serializes null as empty string.</summary>
            <param name="input">input to write.</param>
        </member>
        <member name="M:KS.Reactor.ksBitOStream.WriteMultiType(KS.Reactor.ksMultiType)">
            <summary>Writes a <see cref="T:KS.Reactor.ksMultiType"/>.</summary>
            <param name="input">input to write.</param>
        </member>
        <member name="M:KS.Reactor.ksBitOStream.Align">
            <summary>Advances the position to the next byte if the position is not at a byte boundary.</summary>
        </member>
        <member name="M:KS.Reactor.ksBitOStream.SeekOffset(System.Int32)">
            <summary>Adds an offset to the current position.</summary>
            <param name="offset">Offset to add in bytes.</param>
        </member>
        <member name="M:KS.Reactor.ksBitOStream.Seek(System.Int32)">
            <summary>Seeks to a byte position.</summary>
            <param name="position">Position to seek to.</param>
        </member>
        <member name="M:KS.Reactor.ksBitOStream.SeekBit(System.Int32)">
            <summary>Seeks to a bit position.</summary>
            <param name="bit">Bit to seek to.</param>
        </member>
        <member name="M:KS.Reactor.ksBitOStream.GetPosition">
            <summary>Gets the byte position.</summary>
            <returns>byte position.</returns>
        </member>
        <member name="M:KS.Reactor.ksBitOStream.GetBitPosition">
            <summary>Gets the bit position.</summary>
            <returns>bit position.</returns>
        </member>
        <member name="T:KS.Reactor.ksBounds">
            <summary>A struct that defines an axis aligned bounding box (AABB).</summary>
            <summary>A struct that defines an axis aligned bounding box (AABB).</summary>
        </member>
        <member name="M:KS.Reactor.ksBounds.#ctor(KS.Reactor.ksVector3,KS.Reactor.ksVector3)">
            <summary>Constructor.</summary>
            <param name="min">Min value.</param>
            <param name="max">Max value.</param>
        </member>
        <member name="P:KS.Reactor.ksBounds.Min">
            <summary>
            Get/Set the minimum coordinates contained by the bounds.
            The max value of the bounds will extend to accomodate the new min value when it
            contains larger values than the current max values.
            </summary>
        </member>
        <member name="P:KS.Reactor.ksBounds.Max">
            <summary>
            Get the maxmimum coordinates contained by the bounds.
            The min value of the bounds will extend to accomodate the new max value when it is
            contains smaller values than the current min values.
            </summary>
        </member>
        <member name="P:KS.Reactor.ksBounds.Size">
            <summary>
            Get/Set the size of the bounds.
            The new size will recalculate the min and max values from the existing bounds center.
            </summary>
        </member>
        <member name="P:KS.Reactor.ksBounds.Center">
            <summary>
            Get/Set the center of the bounds
            </summary>
        </member>
        <member name="P:KS.Reactor.ksBounds.IsEmpty">
            <summary>
            The bounds are empty if any of the size dimensions are less than or equal to 0.
            </summary>
        </member>
        <member name="M:KS.Reactor.ksBounds.Contains(KS.Reactor.ksVector3)">
            <summary>
            Check if a point is contained by the bounds.
            </summary>
            <param name="point">Point to test.</param>
            <returns>True if the point is contained or on the edge of the bounds.</returns>
        </member>
        <member name="M:KS.Reactor.ksBounds.Contains(KS.Reactor.ksBounds)">
            <summary>
            Check if another set of bounds is contained by the bounds.
            </summary>
            <param name="bounds">Bounds to test.</param>
            <returns>True if the other bounds are contained.</returns>
        </member>
        <member name="M:KS.Reactor.ksBounds.Intersects(KS.Reactor.ksBounds)">
            <summary>
            Check if another bounds intersects this bounds.
            </summary>
            <param name="bounds">Bounds to test against.</param>
            <returns>True if the bounds overlap.</returns>
        </member>
        <member name="M:KS.Reactor.ksBounds.Encapsulate(KS.Reactor.ksVector3)">
            <summary>
            Expand the volume to include a point.
            </summary>
            <param name="point">Point to encapsulate.</param>
        </member>
        <member name="M:KS.Reactor.ksBounds.Encapsulate(KS.Reactor.ksBounds)">
            <summary>
            Expand the volume to include another set of bounds.
            </summary>
            <param name="bounds">Bounds to encapsulate.</param>
        </member>
        <member name="M:KS.Reactor.ksBounds.op_Equality(KS.Reactor.ksBounds,KS.Reactor.ksBounds)">
            <summary>Check if two bounds are equal</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns>True if the bounds have the same min and max values.</returns>
        </member>
        <member name="M:KS.Reactor.ksBounds.op_Inequality(KS.Reactor.ksBounds,KS.Reactor.ksBounds)">
            <summary>Check if two bounds are not equal</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns>True if the bounds have different min or max values.</returns>
        </member>
        <member name="M:KS.Reactor.ksBounds.Equals(KS.Reactor.ksBounds)">
            <summary>Check if this bounds is equal to another bounds.</summary>
            <param name="other">Other bounds to compare with this bounds.</param>
            <returns>True if the bounds have the same min and max values.</returns>
        </member>
        <member name="M:KS.Reactor.ksBounds.Equals(System.Object)">
            <summary>Check if this bounds is equal to an object.</summary>
            <param name="obj">Object to compare with this bounds.</param>
            <returns>True if the object is a <see cref="T:KS.Reactor.ksBounds"/> and they have the same min and max values.</returns>
        </member>
        <member name="M:KS.Reactor.ksBounds.GetHashCode">
            <summary>Get the hash code for the bounds.</summary>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksBounds.ToString">
            <summary>Construct a string the describes the bounds.</summary>
            <returns>String describing the min and max coordinates of the bounds.</returns>
        </member>
        <member name="M:KS.Reactor.ksBounds.op_Implicit(KS.Reactor.ksBounds)~UnityEngine.Bounds">
            <summary>
            Implicit conversion from ksBounds to Unity Bounds.
            </summary>
            <param name="value">Reactor bounds to convert to Unity bounds.</param>
        </member>
        <member name="M:KS.Reactor.ksBounds.op_Implicit(UnityEngine.Bounds)~KS.Reactor.ksBounds">
            <summary>
            Implicit conversion from Unity Bounds to ksBounds.
            </summary>
            <param name="value">Unity bounds to convert to Reactor bounds</param>
        </member>
        <member name="M:KS.Reactor.ksBounds.op_Equality(KS.Reactor.ksBounds,UnityEngine.Bounds)">
            <summary>
            Equality comparison between Reactor bounds and Unity bounds.
            </summary>
            <param name="lhs">Reactor bounds</param>
            <param name="rhs">Unity bounds</param>
            <returns>True if the bounds are equal.</returns>
        </member>
        <member name="M:KS.Reactor.ksBounds.op_Equality(UnityEngine.Bounds,KS.Reactor.ksBounds)">
            <summary>
            Equality comparison between Unity bounds and Reactor bounds.
            </summary>
            <param name="lhs">Unity bounds</param>
            <param name="rhs">Reactor bounds</param>
            <returns>True if the bounds are equal.</returns>
        </member>
        <member name="M:KS.Reactor.ksBounds.op_Inequality(KS.Reactor.ksBounds,UnityEngine.Bounds)">
            <summary>
            Inequality comparison between Reactor bounds and Unity bounds.
            </summary>
            <param name="lhs">Reactor bounds</param>
            <param name="rhs">Unity bounds</param>
            <returns>True if the bounds are not equal.</returns>
        </member>
        <member name="M:KS.Reactor.ksBounds.op_Inequality(UnityEngine.Bounds,KS.Reactor.ksBounds)">
            <summary>
            Inequality comparison between Unity bounds and Reactor bounds.
            </summary>
            <param name="lhs">Unity bounds</param>
            <param name="rhs">Reactor bounds</param>
            <returns>True if the bounds are not equal.</returns>
        </member>
        <member name="T:KS.Reactor.ksIBufferable">
            <summary>
            Interface required by objects that should be written to, and read from, the ksOutputBuffers and ksInputBufers.
            </summary>
        </member>
        <member name="M:KS.Reactor.ksIBufferable.GetBytes">
            <summary>Serialize the object into a byte array.</summary>
            <returns>Byte array represeting the serialized object.</returns>
        </member>
        <member name="M:KS.Reactor.ksIBufferable.FromBytes(System.Byte[])">
            <summary>Deserialize a byte array and update the object.</summary>
            <param name="buffer">Byte array to deserialze.</param>
        </member>
        <member name="T:KS.Reactor.ksInputBuffer">
            <summary>This input buffer reads data written to a byte array by a ksOutputBuffer.</summary>
        </member>
        <member name="P:KS.Reactor.ksInputBuffer.EndOfData">
            <summary>Check if the internal position has reached the end of the buffer.</summary>
        </member>
        <member name="M:KS.Reactor.ksInputBuffer.#ctor(System.Byte[])">
            <summary>Construct an input buffer from a byte array.</summary>
            <param name="data">Data source.</param>
        </member>
        <member name="M:KS.Reactor.ksInputBuffer.Reset">
            <summary>Reset the internal position to the beginning of the array.</summary>
        </member>
        <member name="M:KS.Reactor.ksInputBuffer.GetBytes(System.Int32)">
            <summary>Gets bytes from the buffer.</summary>
            <param name="length">Length of byte array to get.</param>
            <returns>Byte array.</returns>
        </member>
        <member name="M:KS.Reactor.ksInputBuffer.Get``1">
            <summary>Gets a struct of type T from the buffer.</summary>
            <typeparam name="T"></typeparam>
            <returns>Struct value.</returns>
        </member>
        <member name="M:KS.Reactor.ksInputBuffer.GetBool">
            <summary>Gets a bool from the buffer.</summary>
            <returns>Bool value.</returns>
        </member>
        <member name="M:KS.Reactor.ksInputBuffer.GetByte">
            <summary>Gets a byte from the buffer.</summary>
            <returns>Byte value.</returns>
        </member>
        <member name="M:KS.Reactor.ksInputBuffer.GetChar">
            <summary>Gets a char from the buffer.</summary>
            <returns>Char value.</returns>
        </member>
        <member name="M:KS.Reactor.ksInputBuffer.GetShort">
            <summary>Gets a short from the buffer.</summary>
            <returns>Short value.</returns>
        </member>
        <member name="M:KS.Reactor.ksInputBuffer.GetUShort">
            <summary>Gets a ushort from the buffer.</summary>
            <returns>Ushort value.</returns>
        </member>
        <member name="M:KS.Reactor.ksInputBuffer.GetInt">
            <summary>Gets an int from the buffer.</summary>
            <returns>Int value.</returns>
        </member>
        <member name="M:KS.Reactor.ksInputBuffer.GetUInt">
            <summary>Gets a uint from the buffer.</summary>
            <returns>Uint value.</returns>
        </member>
        <member name="M:KS.Reactor.ksInputBuffer.GetLong">
            <summary>Gets a long from the buffer.</summary>
            <returns>Long value.</returns>
        </member>
        <member name="M:KS.Reactor.ksInputBuffer.GetULong">
            <summary>Gets a ulong from the buffer.</summary>
            <returns>Ulong value.</returns>
        </member>
        <member name="M:KS.Reactor.ksInputBuffer.GetFloat">
            <summary>Gets a float from the buffer.</summary>
            <returns>Float value.</returns>
        </member>
        <member name="M:KS.Reactor.ksInputBuffer.GetDouble">
            <summary>Gets a double from the buffer.</summary>
            <returns>Double value.</returns>
        </member>
        <member name="M:KS.Reactor.ksInputBuffer.GetString">
            <summary>Gets a string from the buffer.</summary>
            <returns>String value.</returns>
        </member>
        <member name="M:KS.Reactor.ksInputBuffer.GetBoolArray">
            <summary>Get an array of bools from the buffer.</summary>
            <returns>Bool array.</returns>
        </member>
        <member name="M:KS.Reactor.ksInputBuffer.GetByteArray">
            <summary>Get an array of bytes from the buffer.</summary>
            <returns>Byte array.</returns>
        </member>
        <member name="M:KS.Reactor.ksInputBuffer.GetCharArray">
            <summary>Get an array of chars from the buffer.</summary>
            <returns>Char array.</returns>
        </member>
        <member name="M:KS.Reactor.ksInputBuffer.GetShortArray">
            <summary>Get an array of shorts from the buffer.</summary>
            <returns>Short array.</returns>
        </member>
        <member name="M:KS.Reactor.ksInputBuffer.GetUShortArray">
            <summary>Get an array of ushorts from the buffer.</summary>
            <returns>Ushort array.</returns>
        </member>
        <member name="M:KS.Reactor.ksInputBuffer.GetIntArray">
            <summary>Get an array of ints from the buffer.</summary>
            <returns>Int array.</returns>
        </member>
        <member name="M:KS.Reactor.ksInputBuffer.GetUIntArray">
            <summary>Get an array of uints from the buffer.</summary>
            <returns>Uint array.</returns>
        </member>
        <member name="M:KS.Reactor.ksInputBuffer.GetLongArray">
            <summary>Get an array of longs from the buffer.</summary>
            <returns>Long array.</returns>
        </member>
        <member name="M:KS.Reactor.ksInputBuffer.GetULongArray">
            <summary>Get an array of ulongs from the buffer.</summary>
            <returns>Ulong array.</returns>
        </member>
        <member name="M:KS.Reactor.ksInputBuffer.GetFloatArray">
            <summary>Get an array of floats from the buffer.</summary>
            <returns>Float array.</returns>
        </member>
        <member name="M:KS.Reactor.ksInputBuffer.GetDoubleArray">
            <summary>Get an array of doubles from the buffer.</summary>
            <returns>Double array.</returns>
        </member>
        <member name="M:KS.Reactor.ksInputBuffer.GetStringArray">
            <summary>Get an array of strings from the buffer.</summary>
            <returns>String array.</returns>
        </member>
        <member name="M:KS.Reactor.ksInputBuffer.GetBufferable``1">
            <summary>Get a ksIBufferable object from the buffer.</summary>
            <returns>ksIBufferable object.</returns>
        </member>
        <member name="M:KS.Reactor.ksInputBuffer.GetMultiType">
            <summary>Get a ksMultitype from the buffer.</summary>
            <returns>ksMultitype value.</returns>
        </member>
        <member name="M:KS.Reactor.ksInputBuffer.GetArray``1(System.Int32)">
            <summary>Get an array of primitive types from the buffer.</summary>
            <typeparam name="T"></typeparam>
            <param name="sizeOf">Size of type.</param>
            <returns>Array.</returns>
        </member>
        <member name="T:KS.Reactor.ksOutputBuffer">
            <summary>
            This output buffer converts each written element into one or two byte arrays and adds them to a list.
            When the output is requested, by calls to GetBytes() or Flush(), the list of byte arrays is copied to
            a single byte array. This approach is significatly faster for large amounts of data when compared to using
            memory streams or resizing an array for each write operation.
            </summary>
        </member>
        <member name="P:KS.Reactor.ksOutputBuffer.Subbuffers">
            <summary>Gets the list of subbuffers(byte[]) that make up the buffer.</summary>
        </member>
        <member name="P:KS.Reactor.ksOutputBuffer.Length">
            <summary>Gets the current byte length of the buffer.</summary>
        </member>
        <member name="M:KS.Reactor.ksOutputBuffer.WriteBytes(System.Byte[])">
            <summary>Writes bytes to the buffer.</summary>
            <param name="bytes">Bytes to write.</param>
        </member>
        <member name="M:KS.Reactor.ksOutputBuffer.Write(System.Boolean)">
            <summary>Writes a bool to the buffer.</summary>
            <param name="value">Bool to write.</param>
        </member>
        <member name="M:KS.Reactor.ksOutputBuffer.Write``1(``0)">
            <summary>Writes a struct of type T to the buffer.</summary>
            <typeparam name="T"></typeparam>
            <param name="value">Struct to write.</param>
        </member>
        <member name="M:KS.Reactor.ksOutputBuffer.Write(System.Byte)">
            <summary>Writes a byte to the buffer.</summary>
            <param name="value">Byte to write.</param>
        </member>
        <member name="M:KS.Reactor.ksOutputBuffer.Write(System.Char)">
            <summary>Writes a char to the buffer.</summary>
            <param name="value">Char to write.</param>
        </member>
        <member name="M:KS.Reactor.ksOutputBuffer.Write(System.Int16)">
            <summary>Writes a short to the buffer.</summary>
            <param name="value">Short to write.</param>
        </member>
        <member name="M:KS.Reactor.ksOutputBuffer.Write(System.UInt16)">
            <summary>Writes a ushort to the buffer.</summary>
            <param name="value">Ushort to write.</param>
        </member>
        <member name="M:KS.Reactor.ksOutputBuffer.Write(System.Int32)">
            <summary>Writes a int to the buffer.</summary>
            <param name="value">Int to write.</param>
        </member>
        <member name="M:KS.Reactor.ksOutputBuffer.Write(System.UInt32)">
            <summary>Writes a uint to the buffer.</summary>
            <param name="value">Uint to write.</param>
        </member>
        <member name="M:KS.Reactor.ksOutputBuffer.Write(System.Int64)">
            <summary>Writes a long to the buffer.</summary>
            <param name="value">Long to write.</param>
        </member>
        <member name="M:KS.Reactor.ksOutputBuffer.Write(System.UInt64)">
            <summary>Writes a ulong to the buffer.</summary>
            <param name="value">Ulong to write.</param>
        </member>
        <member name="M:KS.Reactor.ksOutputBuffer.Write(System.Single)">
            <summary>Writes a float to the buffer.</summary>
            <param name="value">Float to write.</param>
        </member>
        <member name="M:KS.Reactor.ksOutputBuffer.Write(System.Double)">
            <summary>Writes a double to the buffer.</summary>
            <param name="value">Double to write.</param>
        </member>
        <member name="M:KS.Reactor.ksOutputBuffer.Write(System.String)">
            <summary>Writes a string to the buffer.</summary>
            <param name="value">String to write.</param>
        </member>
        <member name="M:KS.Reactor.ksOutputBuffer.Write(System.Boolean[])">
            <summary>
            Writes an array of bools to the buffer. Values are first converted to a bit array before writing.
            If the array is null, then a length of -1 is written.
            </summary>
            <param name="value">Bool array to write.</param>
        </member>
        <member name="M:KS.Reactor.ksOutputBuffer.Write(System.Byte[])">
            <summary>
            Writes an array of bytes to the buffer.
            </summary>
            <param name="value">Byte array to write.</param>
        </member>
        <member name="M:KS.Reactor.ksOutputBuffer.Write(System.Char[])">
            <summary>
            Writes an array of chars to the buffer.
            </summary>
            <param name="value">Char array to write.</param>
        </member>
        <member name="M:KS.Reactor.ksOutputBuffer.Write(System.Int16[])">
            <summary>
            Writes an array of shorts to the buffer.
            </summary>
            <param name="value">Short array to write.</param>
        </member>
        <member name="M:KS.Reactor.ksOutputBuffer.Write(System.UInt16[])">
            <summary>
            Writes an array of ushort to the buffer.
            </summary>
            <param name="value">Ushort array to write.</param>
        </member>
        <member name="M:KS.Reactor.ksOutputBuffer.Write(System.Int32[])">
            <summary>
            Writes an array of ints to the buffer.
            </summary>
            <param name="value">Int array to write.</param>
        </member>
        <member name="M:KS.Reactor.ksOutputBuffer.Write(System.UInt32[])">
            <summary>
            Writes an array of uints to the buffer.
            </summary>
            <param name="value">Uint array to write.</param>
        </member>
        <member name="M:KS.Reactor.ksOutputBuffer.Write(System.Int64[])">
            <summary>
            Writes an array of longs to the buffer.
            </summary>
            <param name="value">Long array to write.</param>
        </member>
        <member name="M:KS.Reactor.ksOutputBuffer.Write(System.UInt64[])">
            <summary>
            Write an array of ulongs to the buffer.
            </summary>
            <param name="value">Ulong array to write.</param>
        </member>
        <member name="M:KS.Reactor.ksOutputBuffer.Write(System.Single[])">
            <summary>
            Writes an array of floats to the buffer.
            </summary>
            <param name="value">Float array to write.</param>
        </member>
        <member name="M:KS.Reactor.ksOutputBuffer.Write(System.Double[])">
            <summary>
            Writes an array of doubles to the buffer.
            </summary>
            <param name="value">Double array to write.</param>
        </member>
        <member name="M:KS.Reactor.ksOutputBuffer.Write(System.String[])">
            <summary>
            Writes an array of strings to the buffer. Writes the length of the array followed by each string.
            If the array is null, then a length of -1 is written.
            </summary>
            <param name="value">String array to write.</param>
        </member>
        <member name="M:KS.Reactor.ksOutputBuffer.Write(KS.Reactor.ksOutputBuffer)">
            <summary>Appends the contents of another output buffer.</summary>
            <param name="value">Value to write.</param>
        </member>
        <member name="M:KS.Reactor.ksOutputBuffer.Write(KS.Reactor.ksIBufferable)">
            <summary>
            Writes the bytes of an object that implemented ksIBufferable.
            If the object is null write a length value of -1.
            </summary>
            <param name="value">Value to write.</param>
        </member>
        <member name="M:KS.Reactor.ksOutputBuffer.Write(KS.Reactor.ksMultiType)">
            <summary>Writes a ksMultitype to the buffer.</summary>
            <param name="value">Value to write.</param>
        </member>
        <member name="M:KS.Reactor.ksOutputBuffer.Clear">
            <summary>Clears the buffer.</summary>
        </member>
        <member name="M:KS.Reactor.ksOutputBuffer.GetBytes">
            <summary>Copies and returns the contents of the buffer as a single byte array.</summary>
            <returns>Byte array.</returns>
        </member>
        <member name="M:KS.Reactor.ksOutputBuffer.Flush">
            <summary>Gets the buffer bytes then clear the buffer.</summary>
            <returns>Byte array.</returns>
        </member>
        <member name="M:KS.Reactor.ksOutputBuffer.Write(System.Array,System.Int32)">
            <summary>
            Writes an array of primitives to the buffer. This writes the number of elements in the array followed by a
            single byte array from an block copy. If the array is null, then a length of -1 is written.
            </summary>
            <param name="value">Array object to write.</param>
            <param name="sizeOf">Size of data type in bytes</param>
        </member>
        <member name="T:KS.Reactor.ksCharacterControllerColliderHit">
            <summary>
            This class is used by <see cref="E:KS.Reactor.ksICharacterController.OnColliderHit"/> to give information about the
            collision.
            </summary>
        </member>
        <member name="P:KS.Reactor.ksCharacterControllerColliderHit.Collider">
            <summary>The collider that was hit by the controller.</summary>
        </member>
        <member name="P:KS.Reactor.ksCharacterControllerColliderHit.Point">
            <summary>The impact point in world space.</summary>
        </member>
        <member name="P:KS.Reactor.ksCharacterControllerColliderHit.Normal">
            <summary>The normal of the surface the controller collided with in world space.</summary>
        </member>
        <member name="P:KS.Reactor.ksCharacterControllerColliderHit.MoveDirection">
            <summary>The direction the CharacterController was moving in when the collision occured.</summary>
        </member>
        <member name="P:KS.Reactor.ksCharacterControllerColliderHit.MoveLength">
            <summary>How far the character travelled until it hit the collider.</summary>
        </member>
        <member name="M:KS.Reactor.ksCharacterControllerColliderHit.#ctor">
            <summary>Constructor.</summary>
        </member>
        <member name="M:KS.Reactor.ksCharacterControllerColliderHit.#ctor(KS.Reactor.ksICollider,KS.Reactor.ksVector3,KS.Reactor.ksVector3,KS.Reactor.ksVector3,System.Single)">
            <summary>
            Constructor.
            </summary>
            <param name="hitCollider">Collider hit by the character controller.</param>
            <param name="point">The impact point in world space.</param>
            <param name="normal">The normal of the surface the controller collided with in world space.</param>
            <param name="moveDirection">
            The direction the CharacterController was moving in when the collision occured.
            </param>
            <param name="moveLength">How far the character travelled until it hit the collider.</param>
        </member>
        <member name="T:KS.Reactor.ksCharacterControllerCollisionFlags">
            <summary>Collision flags is a bitmask returned by character controller's Move method.</summary>
        </member>
        <member name="F:KS.Reactor.ksCharacterControllerCollisionFlags.NONE">
            <summary>No collisions detected.</summary>
        </member>
        <member name="F:KS.Reactor.ksCharacterControllerCollisionFlags.SIDES">
            <summary>Collision detected on the side of the character controller.</summary>
        </member>
        <member name="F:KS.Reactor.ksCharacterControllerCollisionFlags.ABOVE">
            <summary>Collision detected on the top of the character controller.</summary>
        </member>
        <member name="F:KS.Reactor.ksCharacterControllerCollisionFlags.BELOW">
            <summary>Collision detected on the bottom of the character controller.</summary>
        </member>
        <member name="T:KS.Reactor.ksCharacterControllerEvents">
            <summary>Contains event handler delegates for the character controller.</summary>
        </member>
        <member name="T:KS.Reactor.ksCharacterControllerEvents.ColliderHitHandler">
            <summary>Character controller collider hit event handler.</summary>
            <param name="hit">hit data for the collision.</param>
        </member>
        <member name="T:KS.Reactor.ksCloneableAttribute">
            <summary>
            Tags non-editable fields and properties in server scripts to make them copy when the script is cloned.
            </summary>
        </member>
        <member name="T:KS.Reactor.ksClusterProperty">
            <summary>
            A hierarchy of dictionary objects that store hierarchy-type and value-type cluster properties.
            Properties can be accessed from any level of the property hierarchy by providing a path (a list of keys
            joined by the path separator '.')
            </summary>
        </member>
        <member name="T:KS.Reactor.ksClusterProperty.ActionTypes">
            <summary>Types of actions to perform on cluster properties.  Used by the property event handlers.</summary>
        </member>
        <member name="F:KS.Reactor.ksClusterProperty.ActionTypes.UNKNOWN">
            <summary>Unknown cluster property action.</summary>
        </member>
        <member name="F:KS.Reactor.ksClusterProperty.ActionTypes.GET">
            <summary>Property was fetched.</summary>
        </member>
        <member name="F:KS.Reactor.ksClusterProperty.ActionTypes.SET">
            <summary>Prpperty was set.</summary>
        </member>
        <member name="F:KS.Reactor.ksClusterProperty.ActionTypes.DELETE">
            <summary>Property was deleted.</summary>
        </member>
        <member name="T:KS.Reactor.ksClusterProperty.ReadCache">
            <summary>Read cache enum.</summary>
        </member>
        <member name="F:KS.Reactor.ksClusterProperty.ReadCache.CACHE">
            <summary>Read from the cache. On a cache miss, a null result is returned.</summary>
        </member>
        <member name="F:KS.Reactor.ksClusterProperty.ReadCache.STORE">
            <summary>Read from the store and update the cache.</summary>
        </member>
        <member name="F:KS.Reactor.ksClusterProperty.ReadCache.HIT">
            <summary>Read from the cache. On a cache miss, read from the store and update the cache.</summary>
        </member>
        <member name="T:KS.Reactor.ksClusterProperty.WriteCache">
            <summary>Write cache enum.</summary>
        </member>
        <member name="F:KS.Reactor.ksClusterProperty.WriteCache.CACHE">
            <summary>Write to the cache.</summary>
        </member>
        <member name="F:KS.Reactor.ksClusterProperty.WriteCache.STORE">
            <summary>Write to the store and update the cache.</summary>
        </member>
        <member name="T:KS.Reactor.ksClusterProperty.DeleteCache">
            <summary>Delete cache enum.</summary>
        </member>
        <member name="F:KS.Reactor.ksClusterProperty.DeleteCache.CACHE">
            <summary>Delete from the cache.</summary>
        </member>
        <member name="F:KS.Reactor.ksClusterProperty.DeleteCache.STORE">
            <summary>Delete from the store and cache.</summary>
        </member>
        <member name="P:KS.Reactor.ksClusterProperty.Key">
            <summary>Get the property key.</summary>
        </member>
        <member name="P:KS.Reactor.ksClusterProperty.Expiry">
            <summary>Expiry.</summary>
        </member>
        <member name="P:KS.Reactor.ksClusterProperty.IsPersistent">
            <summary>Is this a persistent property?</summary>
        </member>
        <member name="P:KS.Reactor.ksClusterProperty.Path">
            <summary>Gets the property path.</summary>
        </member>
        <member name="P:KS.Reactor.ksClusterProperty.HasValue">
            <summary>Checks if a value has been assigned to this cluster property.</summary>
        </member>
        <member name="P:KS.Reactor.ksClusterProperty.Parent">
            <summary>Gets the parent property.</summary>
        </member>
        <member name="P:KS.Reactor.ksClusterProperty.Children">
            <summary>Gets the children of this property.</summary>
        </member>
        <member name="P:KS.Reactor.ksClusterProperty.Value">
            <summary>Gets the property value.</summary>
        </member>
        <member name="P:KS.Reactor.ksClusterProperty.Item(System.String)">
            <summary>
            Gets a cluster property. A null value is returned if a property does not exist at the end of the path.
            </summary>
        </member>
        <member name="P:KS.Reactor.ksClusterProperty.ChildCount">
            <summary>Number children this property has.</summary>
        </member>
        <member name="M:KS.Reactor.ksClusterProperty.#ctor">
            <summary>Constructor.</summary>
        </member>
        <member name="M:KS.Reactor.ksClusterProperty.#ctor(System.String)">
            <summary>Constructor.</summary>
            <param name="key">Key.</param>
        </member>
        <member name="M:KS.Reactor.ksClusterProperty.#ctor(System.String,KS.Reactor.ksMultiType)">
            <summary>Constructor.</summary>
            <param name="key">Key.</param>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksClusterProperty.Update(KS.Reactor.ksClusterProperty)">
            <summary>
            Updates this property using the data from another property. After updating, increments the update count.
            </summary>
            <param name="property"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksClusterProperty.GetProperty(System.String)">
            <summary>
            Fetch a property from the hierarchy below this property. Properties can be accessed from any level of the
            property hierarchy by providing a path (a list of keys joined by the path separator '/')
            </summary>
            <param name="path"></param>
            <returns>Property or null if no property found.</returns>
        </member>
        <member name="M:KS.Reactor.ksClusterProperty.GetProperty(System.String[],System.Int32)">
            <summary>Fetches a property from the hierarchy below this property.</summary>
            <param name="keys">List of keys.</param>
            <param name="depth">Iteration depth.</param>
            <returns>Property or null if no property found.</returns>
        </member>
        <member name="M:KS.Reactor.ksClusterProperty.SetProperty(KS.Reactor.ksClusterProperty)">
            <summary>
            Adds or updates a property in the hierarchy below this property. The provided property's key will be parsed
            as the path to the property to update.
            </summary>
            <param name="property">Property to set.</param>
            <returns>Set property or null if no property was removed.</returns>
        </member>
        <member name="M:KS.Reactor.ksClusterProperty.SetProperty(System.String,KS.Reactor.ksClusterProperty)">
            <summary>
            Adds or updates a property in the hierarchy below this property. Properties can be accessed from any level
            of the property hierarchy by providing a path (a list of keys joined by the path separator '/')
            </summary>
            <param name="path"></param>
            <param name="property">Property to set.</param>
            <returns>Set property or null if no property was removed.</returns>
        </member>
        <member name="M:KS.Reactor.ksClusterProperty.ParsePath(System.String,System.Collections.Generic.List{System.String}@)">
            <summary>
            Parses a property path into a list of strings and tracks the depth of the first object separator.
            </summary>
            <param name="path"></param>
            <param name="keys"></param>
            <returns>True if the path could be parsed.</returns>
        </member>
        <member name="M:KS.Reactor.ksClusterProperty.SetProperty(System.Collections.Generic.List{System.String},KS.Reactor.ksClusterProperty,System.Int32)">
            <summary>Adds or updates a property in the hierarchy below this property.</summary>
            <param name="keys">List of keys.</param>
            <param name="property">Property to set.</param>
            <param name="depth">Iteration depth.</param>
            <returns>Set property or null if no property was removed.</returns>
        </member>
        <member name="M:KS.Reactor.ksClusterProperty.RemoveProperty(System.String)">
            <summary>
            Removes a property from the hierarchy below this property. Properties can be accessed from any level of the
            property hierarchy by providing a path (a list of keys joined by the path separator '/')
            </summary>
            <param name="path"></param>
            <returns>Removed property or null if no property was removed.</returns>
        </member>
        <member name="M:KS.Reactor.ksClusterProperty.RemoveProperty(System.String[],System.Int32)">
            <summary>Removes a property from the hierarchy below this property.</summary>
            <param name="keys">List of keys.</param>
            <param name="depth">Iteration depths.</param>
            <returns>Removed property or null if no property was removed.</returns>
        </member>
        <member name="M:KS.Reactor.ksClusterProperty.Prune">
            <summary>Removes all branches that do not contain value children</summary>
        </member>
        <member name="M:KS.Reactor.ksClusterProperty.ForEachChild">
            <summary>Iterates each child of this property.</summary>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksClusterProperty.ForEachDescendant">
            <summary>Iterates each descendant of this property.</summary>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksClusterProperty.ForEachAncestor">
            <summary>Iterates each ancestor of this property.</summary>
            <returns></returns>
        </member>
        <member name="T:KS.Reactor.ksClusterRPCAttribute">
            <summary>Attribute used to mark cluster RPC handlers on room and entity scripts.</summary>
        </member>
        <member name="M:KS.Reactor.ksClusterRPCAttribute.#ctor(System.UInt32,System.Boolean)">
            <summary>Constructor.</summary>
            <param name="id">RPC ID</param>
            <param name="executeOnMainThread">When true, the RPC will be excuted on the main thread.</param>
        </member>
        <member name="T:KS.Reactor.ksCollisionFilter">
            <summary>
            The collsion filter uses 3 mask properties (Group, Notify, Collide) to determine interaction and notifications
            during the physics simulation. This class is immutable.
            </summary>
        </member>
        <member name="P:KS.Reactor.ksCollisionFilter.Default">
            <summary>
            The default collision filter. Setting this to a new instance will not affect any existing colliders using
            the old default filter, but will change the filter used by new colliders that don't have a filter
            assigned.
            </summary>
        </member>
        <member name="P:KS.Reactor.ksCollisionFilter.Group">
            <summary>Groups that this filter belongs to.</summary>
        </member>
        <member name="P:KS.Reactor.ksCollisionFilter.Notify">
            <summary>Groups that this filter reports collision and overlap events with.</summary>
        </member>
        <member name="P:KS.Reactor.ksCollisionFilter.Collide">
            <summary>Groups that this filter will simulate collisions with.</summary>
        </member>
        <member name="M:KS.Reactor.ksCollisionFilter.#ctor">
            <summary>Constructor. Belongs to all groups, collides with all groups, and notifies with none.</summary>
        </member>
        <member name="M:KS.Reactor.ksCollisionFilter.#ctor(System.UInt32,System.UInt32,System.UInt32)">
            <summary>Constructor</summary>
            <param name="group">Groups that this filter belongs to.</param>
            <param name="notify">Groups that this filter reports collision and overlap events with.</param>
            <param name="collide">Groups that this filter will simulate collisions with.</param>
        </member>
        <member name="M:KS.Reactor.ksCollisionFilter.WithGroup(System.UInt32)">
            <summary>Creates a copy of this filter with <see cref="P:KS.Reactor.ksCollisionFilter.Group"/> set to <paramref name="group"/>.</summary>
            <param name="group">Group to set on the copy.</param>
            <returns>Copied filter with a different <see cref="P:KS.Reactor.ksCollisionFilter.Group"/>.</returns>
        </member>
        <member name="M:KS.Reactor.ksCollisionFilter.WithNotify(System.UInt32)">
            <summary>
            Creates a copy of this filter with <see cref="P:KS.Reactor.ksCollisionFilter.Notify"/> set to <paramref name="notify"/>.
            </summary>
            <param name="notify">Notify to set on the copy.</param>
            <returns>Copied filter with a different <see cref="P:KS.Reactor.ksCollisionFilter.Notify"/>.</returns>
        </member>
        <member name="M:KS.Reactor.ksCollisionFilter.WithCollide(System.UInt32)">
            <summary>
            Creates a copy of this filter with <see cref="P:KS.Reactor.ksCollisionFilter.Collide"/> set to <paramref name="collide"/>.
            </summary>
            <param name="collide">Collide to set on the copy.</param>
            <returns>Copied filter with a different <see cref="P:KS.Reactor.ksCollisionFilter.Collide"/>.</returns>
        </member>
        <member name="M:KS.Reactor.ksCollisionFilter.Filter(KS.Reactor.ksICollider,KS.Reactor.ksICollider,KS.Reactor.ksQueryResultTypes,KS.Reactor.ksBaseQueryParams)">
            <summary>
            Determines if a potential collider hit should be included in query results and whether it is a blocking or
            touching hit.
            </summary>
            <param name="queryCollider">The collider used in the query. Null for shape queries.</param>
            <param name="hitCollider">The collider being evaluated for a hit.</param>
            <param name="resultType">What kind of results the query returns</param>
            <param name="args">Query parameters</param>
            <returns>Hit type</returns>
        </member>
        <member name="M:KS.Reactor.ksCollisionFilter.ToString">
            <summary>Converts the collision filter to a string.</summary>
            <returns>The filter converted to a string.</returns>
        </member>
        <member name="M:KS.Reactor.ksCollisionFilter.op_Equality(KS.Reactor.ksCollisionFilter,KS.Reactor.ksCollisionFilter)">
            <summary>
            Checks if two collision filters are equal.
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns>True if the collision filters are equal.</returns>
        </member>
        <member name="M:KS.Reactor.ksCollisionFilter.op_Inequality(KS.Reactor.ksCollisionFilter,KS.Reactor.ksCollisionFilter)">
            <summary>
            Checks if two collision filters are not equal.
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns>True if the collision filters are not equal.</returns>
        </member>
        <member name="M:KS.Reactor.ksCollisionFilter.Equals(System.Object)">
            <summary>
            Checks if this collision filter is equal to an object.
            </summary>
            <param name="obj"></param>
            <returns>True if this collision filter is equal to the object.</returns>
        </member>
        <member name="M:KS.Reactor.ksCollisionFilter.GetHashCode">
            <summary> Gets a hash code from this collision filter.</summary>
            <returns>Hash code</returns>
        </member>
        <member name="T:KS.Reactor.ksColor">
            <summary>
            Partial ksColor struct. This part is the major part that contains members that does not depend on UnityEngine.
            </summary>
            <summary>
            Patial color struct. This part contains methods that support operations between <see cref="T:KS.Reactor.ksColor"/> and
            <see cref="T:UnityEngine.Color"/>.
            </summary>
        </member>
        <member name="M:KS.Reactor.ksColor.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>Constructor.</summary>
            <param name="r">Red value.</param>
            <param name="g">Green value.</param>
            <param name="b">Blue value.</param>
            <param name="a">Alpha value.</param>
        </member>
        <member name="M:KS.Reactor.ksColor.#ctor(System.Single,System.Single,System.Single)">
            <summary>Constructor that takes 3 floats and set a to 1.0f.</summary>
            <param name="r">Red value.</param>
            <param name="g">Green value.</param>
            <param name="b">Blue value.</param>
        </member>
        <member name="M:KS.Reactor.ksColor.#ctor(KS.Reactor.ksVector3)">
            <summary>Constructor that takes a ksVector3 and set a to 1.0f.</summary>
            <param name="rgb">Red, green and blue values.</param>
        </member>
        <member name="M:KS.Reactor.ksColor.#ctor(System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>Constructor.</summary>
            <param name="r">Red value.</param>
            <param name="g">Green value.</param>
            <param name="b">Blue value.</param>
            <param name="a">Alpha value.</param>
        </member>
        <member name="M:KS.Reactor.ksColor.#ctor(System.Byte,System.Byte,System.Byte)">
            <summary>Constructor that takes 3 floats and set a to 1.0f.</summary>
            <param name="r">Red value.</param>
            <param name="g">Green value.</param>
            <param name="b">Blue value.</param>
        </member>
        <member name="M:KS.Reactor.ksColor.#ctor(System.String)">
            <summary>
            Constructor with a string that contains a hex number.
            Its format must be one of "#RRGGBB", "RRGGBB", "#RRGGBBAA" or "RRGGBBAA".
            </summary>
            <param name="hex">Hex string.</param>
        </member>
        <member name="M:KS.Reactor.ksColor.#ctor(System.UInt32)">
            <summary>Constructor with a uint.</summary>
            <param name="color">
            First byte (most significant byte) represents r.
            Second byte represents g.
            Third byte represents b.
            Last byte represents a.
            </param>
        </member>
        <member name="P:KS.Reactor.ksColor.White">
            <summary>White (1f, 1f, 1f, 1f)</summary>
        </member>
        <member name="P:KS.Reactor.ksColor.Black">
            <summary>Black (0f, 0f, 0f, 1f)</summary>
        </member>
        <member name="P:KS.Reactor.ksColor.Zero">
            <summary>Zero (0f, 0f, 0f, 0f)</summary>
        </member>
        <member name="P:KS.Reactor.ksColor.Red">
            <summary>Red (1f, 0f, 0f, 1f)</summary>
        </member>
        <member name="P:KS.Reactor.ksColor.Green">
            <summary>Green (0f, 1f, 0f, 1f)</summary>
        </member>
        <member name="P:KS.Reactor.ksColor.Blue">
            <summary>Blue (0f, 0f, 1f, 1f)</summary>
        </member>
        <member name="P:KS.Reactor.ksColor.Yellow">
            <summary>Yellow (1f, 1f, 0f, 1f)</summary>
        </member>
        <member name="P:KS.Reactor.ksColor.Cyan">
            <summary>Cyan (0f, 1f, 1f, 1f)</summary>
        </member>
        <member name="P:KS.Reactor.ksColor.Magenta">
            <summary>Magenta (1f, 0f, 1f, 1f)</summary>
        </member>
        <member name="P:KS.Reactor.ksColor.Gray">
            <summary>Gray (0.5f, 0.5f, 0.5f, 1f)</summary>
        </member>
        <member name="M:KS.Reactor.ksColor.op_Implicit(KS.Reactor.ksColor)~System.Single[]">
            <summary>Implicit conversion from ksColor to float[4]. </summary>
            <param name="value">ksColor value.</param>
        </member>
        <member name="M:KS.Reactor.ksColor.op_Implicit(System.Single[])~KS.Reactor.ksColor">
            <summary>Implicit conversion from float[] to ksColor.</summary>
            <param name="value">Float array value.</param>
        </member>
        <member name="P:KS.Reactor.ksColor.R">
            <summary>Red value.</summary>
        </member>
        <member name="P:KS.Reactor.ksColor.G">
            <summary>Green value.</summary>
        </member>
        <member name="P:KS.Reactor.ksColor.B">
            <summary>Blue value.</summary>
        </member>
        <member name="P:KS.Reactor.ksColor.A">
            <summary>Alpha value.</summary>
        </member>
        <member name="P:KS.Reactor.ksColor.RByte">
            <summary>Red byte value.</summary>
        </member>
        <member name="P:KS.Reactor.ksColor.GByte">
            <summary>Green byte value.</summary>
        </member>
        <member name="P:KS.Reactor.ksColor.BByte">
            <summary>Red byte value.</summary>
        </member>
        <member name="P:KS.Reactor.ksColor.AByte">
            <summary>Red byte value.</summary>
        </member>
        <member name="M:KS.Reactor.ksColor.Luma">
            <summary>Gets the luma value of this color.</summary>
            <returns>Luma value of this color.</returns>
        </member>
        <member name="P:KS.Reactor.ksColor.Item(System.Int32)">
            <summary>Indexer.</summary>
            <param name="index"></param>
            <returns>Value at the given index.</returns>
        </member>
        <member name="M:KS.Reactor.ksColor.FromHSV(System.Single,System.Single,System.Single)">
            <summary>Gets RGB color from HSV values.</summary>
            <param name="h">Hue value.</param>
            <param name="s">Saturation value.</param>
            <param name="v">Brightness value.</param>
            <returns>ksColor value.</returns>
        </member>
        <member name="M:KS.Reactor.ksColor.ToHexString(System.Boolean)">
            <summary>Gets the hex number string that represents this color.</summary>
            <param name="withAlpha">Includes alpha value if true.</param>
            <returns>Hex string.</returns>
        </member>
        <member name="M:KS.Reactor.ksColor.ToUInt">
            <summary>Returns a uint that represents this color.</summary>
            <returns>
            First byte (most significant byte) represents the red value.
            Second byte represents the green value.
            Third byte represents the blue value.
            Last byte represents the alpha value.
            </returns>
        </member>
        <member name="M:KS.Reactor.ksColor.Max(KS.Reactor.ksColor,KS.Reactor.ksColor)">
            <summary>Returns a color with max RGBA values of lhs and rhs.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksColor.Min(KS.Reactor.ksColor,KS.Reactor.ksColor)">
            <summary>Returns a color with min RGBA values of lhs and rhs.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksColor.Lerp(KS.Reactor.ksColor,KS.Reactor.ksColor,System.Single)">
            <summary>Linearly interpolates between colors lhs and rhs by t.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksColor.MoveTowards(KS.Reactor.ksColor,KS.Reactor.ksColor,System.Single)">
            <summary>Moves a color towards a target color.</summary>
            <param name="start">Start color.</param>
            <param name="target">Target to move towards.</param>
            <param name="delta">
            Distance to move. It will not overshoot the target. Negative values will move away from the target.
            </param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksColor.Magnitude">
            <summary>Gets the magnitude</summary>
            <returns>Magnitude.</returns>
        </member>
        <member name="M:KS.Reactor.ksColor.Clamp(System.Single,System.Single)">
            <summary>Clamps RGBA values to be between min and max.</summary>
            <param name="min">Min value.</param>
            <param name="max">Max value.</param>
        </member>
        <member name="M:KS.Reactor.ksColor.Clamped(System.Single,System.Single)">
            <summary>Returns clamped color.</summary>
            <param name="min">Min value.</param>
            <param name="max">Max value.</param>
            <returns>Clamped color.</returns>
        </member>
        <member name="M:KS.Reactor.ksColor.op_Implicit(KS.Reactor.ksVector3)~KS.Reactor.ksColor">
            <summary>Implicitly converts ksVector3 to ksColor.</summary>
            <param name="vector"></param>
        </member>
        <member name="M:KS.Reactor.ksColor.op_Implicit(KS.Reactor.ksColor)~KS.Reactor.ksVector3">
            <summary>Implicitly converts ksColor to ksVector3.</summary>
            <param name="color"></param>
        </member>
        <member name="M:KS.Reactor.ksColor.op_Addition(KS.Reactor.ksColor,KS.Reactor.ksColor)">
            <summary>Componentwise addition.</summary>
            <param name="color1"></param>
            <param name="color2"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksColor.op_Subtraction(KS.Reactor.ksColor,KS.Reactor.ksColor)">
            <summary>Componentwise subtraction.</summary>
            <param name="color1"></param>
            <param name="color2"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksColor.op_Multiply(KS.Reactor.ksColor,KS.Reactor.ksColor)">
            <summary>Componentwise multiplication.</summary>
            <param name="color1"></param>
            <param name="color2"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksColor.op_Multiply(KS.Reactor.ksColor,System.Single)">
            <summary>Multiplies each component of color by scale.</summary>
            <param name="color"></param>
            <param name="scale"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksColor.op_Multiply(System.Single,KS.Reactor.ksColor)">
            <summary>Multiplies each component of color by scale.</summary>
            <param name="scale"></param>
            <param name="color"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksColor.op_Division(KS.Reactor.ksColor,System.Single)">
            <summary>Divides each component of color by scale.</summary>
            <param name="color"></param>
            <param name="scale"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksColor.op_UnaryNegation(KS.Reactor.ksColor)">
            <summary>Multipleis each component with -1f.</summary>
            <param name="color"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksColor.op_Equality(KS.Reactor.ksColor,KS.Reactor.ksColor)">
            <summary>Equality comparison of color1 and color2.</summary>
            <param name="color1"></param>
            <param name="color2"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksColor.op_Inequality(KS.Reactor.ksColor,KS.Reactor.ksColor)">
            <summary>Inequality comparison of color1 and color2.</summary>
            <param name="color1"></param>
            <param name="color2"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksColor.Equals(System.Object)">
            <summary>Checks if this color is equal to an object.</summary>
            <param name="obj">Object to compare with this color.</param>
            <returns>True if this color is equal to the object.</returns>
        </member>
        <member name="M:KS.Reactor.ksColor.Equals(KS.Reactor.ksColor)">
            <summary>Checks if this color is equal to another.</summary>
            <param name="other">Other color to compare with.</param>
            <returns>True if the colors are equal.</returns>
        </member>
        <member name="M:KS.Reactor.ksColor.ToString">
            <summary>Returns a string that represents the current ksColor.</summary>
            <returns>A string that represents the current ksColor.</returns>
        </member>
        <member name="M:KS.Reactor.ksColor.ToString(System.String)">
            <summary>Returns a string respresentation of the ksColor.</summary>
            <param name="format">Format.</param>
            <returns>String representation of the ksColor.</returns>
        </member>
        <member name="M:KS.Reactor.ksColor.ToString(System.IFormatProvider)">
            <summary>Returns a string respresentation of the ksColor.</summary>
            <param name="provider">Provider.</param>
            <returns>String representation of the ksColor.</returns>
        </member>
        <member name="M:KS.Reactor.ksColor.GetHashCode">
            <summary>Gets the hash code for this color.</summary>
            <returns>Hash code for this color.</returns>
        </member>
        <member name="M:KS.Reactor.ksColor.op_Implicit(KS.Reactor.ksColor)~UnityEngine.Color">
            <summary>Implicit conversion from <see cref="T:KS.Reactor.ksColor"/> to Unity <see cref="T:UnityEngine.Color"/>.</summary>
            <param name="value">Reactor color</param>
            <returns>Unity color</returns>
        </member>
        <member name="M:KS.Reactor.ksColor.op_Implicit(UnityEngine.Color)~KS.Reactor.ksColor">
            <summary>Implicit conversion from Unity <see cref="T:UnityEngine.Color"/> to <see cref="T:KS.Reactor.ksColor"/>.</summary>
            <param name="value">Unity color</param>
            <returns>Reactor color</returns>
        </member>
        <member name="M:KS.Reactor.ksColor.op_Addition(KS.Reactor.ksColor,UnityEngine.Color)">
            <summary>Color addition with <see cref="T:KS.Reactor.ksColor"/> and Unity <see cref="T:UnityEngine.Color"/>.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns><paramref name="lhs"/> + <paramref name="rhs"/></returns>
        </member>
        <member name="M:KS.Reactor.ksColor.op_Addition(UnityEngine.Color,KS.Reactor.ksColor)">
            <summary>Color addition with Unity <see cref="T:UnityEngine.Color"/> and <see cref="T:KS.Reactor.ksColor"/>.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns><paramref name="lhs"/> + <paramref name="rhs"/></returns>
        </member>
        <member name="M:KS.Reactor.ksColor.op_Subtraction(KS.Reactor.ksColor,UnityEngine.Color)">
            <summary>Color subtraction with <see cref="T:KS.Reactor.ksColor"/> and Unity <see cref="T:UnityEngine.Color"/>.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns><paramref name="lhs"/> - <paramref name="rhs"/></returns>
        </member>
        <member name="M:KS.Reactor.ksColor.op_Subtraction(UnityEngine.Color,KS.Reactor.ksColor)">
            <summary>Color subtraction with Unity <see cref="T:UnityEngine.Color"/> and <see cref="T:KS.Reactor.ksColor"/>.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns><paramref name="lhs"/> - <paramref name="rhs"/></returns>
        </member>
        <member name="M:KS.Reactor.ksColor.op_Multiply(KS.Reactor.ksColor,UnityEngine.Color)">
            <summary>Color multiplication with <see cref="T:KS.Reactor.ksColor"/> and Unity <see cref="T:UnityEngine.Color"/>.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns><paramref name="lhs"/> * <paramref name="rhs"/></returns>
        </member>
        <member name="M:KS.Reactor.ksColor.op_Multiply(UnityEngine.Color,KS.Reactor.ksColor)">
            <summary>Color multiplication with Unity <see cref="T:UnityEngine.Color"/> and <see cref="T:KS.Reactor.ksColor"/>.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns><paramref name="lhs"/> * <paramref name="rhs"/></returns>
        </member>
        <member name="M:KS.Reactor.ksColor.op_Equality(KS.Reactor.ksColor,UnityEngine.Color)">
            <summary>Equality comparison with with <see cref="T:KS.Reactor.ksColor"/> and Unity <see cref="T:UnityEngine.Color"/>.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns><paramref name="lhs"/> == <paramref name="rhs"/></returns>
        </member>
        <member name="M:KS.Reactor.ksColor.op_Equality(UnityEngine.Color,KS.Reactor.ksColor)">
            <summary>Equality comparison with Unity <see cref="T:UnityEngine.Color"/> and <see cref="T:KS.Reactor.ksColor"/>.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns><paramref name="lhs"/> == <paramref name="rhs"/></returns>
        </member>
        <member name="M:KS.Reactor.ksColor.op_Inequality(KS.Reactor.ksColor,UnityEngine.Color)">
            <summary>Inequality comparison with with <see cref="T:KS.Reactor.ksColor"/> and Unity <see cref="T:UnityEngine.Color"/>.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns><paramref name="lhs"/> != <paramref name="rhs"/></returns>
        </member>
        <member name="M:KS.Reactor.ksColor.op_Inequality(UnityEngine.Color,KS.Reactor.ksColor)">
            <summary>Inequality comparison with Unity <see cref="T:UnityEngine.Color"/> and <see cref="T:KS.Reactor.ksColor"/>.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns><paramref name="lhs"/> != <paramref name="rhs"/></returns>
        </member>
        <member name="T:KS.Reactor.ksCompressionConstants">
            <summary>Defines compression related constants.</summary>
        </member>
        <member name="F:KS.Reactor.ksCompressionConstants.DEFAULT_POSITION_PRECISION">
            <summary>Default position precision.</summary>
        </member>
        <member name="F:KS.Reactor.ksCompressionConstants.DEFAULT_ROTATION_PRECISION">
            <summary>
            Default rotation precision.
            Rotation precision is the smallest increment in degrees.
            </summary>
        </member>
        <member name="F:KS.Reactor.ksCompressionConstants.DEFAULT_SCALE_PRECISION">
            <summary>Default scale precision.</summary>
        </member>
        <member name="F:KS.Reactor.ksCompressionConstants.MAX_ROTATION_PRESITION">
            <summary>Biggest number that can be set for rotation precision.</summary>
        </member>
        <member name="T:KS.Reactor.ksConstList`1">
            <summary>Wraps an IList and provides read-only access to it.</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:KS.Reactor.ksConstList`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>Constructor.</summary>
            <param name="list"></param>
        </member>
        <member name="P:KS.Reactor.ksConstList`1.Count">
            <summary>Number of elements in the list.</summary>
        </member>
        <member name="P:KS.Reactor.ksConstList`1.Item(System.Int32)">
            <summary>Access the list by index.</summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksConstList`1.IndexOf(`0)">
            <summary>Finds the index of the first occurence of a value.</summary>
            <param name="value">Value to search for.</param>
            <returns>Index of the value, or -1 if the value was not found.</returns>
        </member>
        <member name="M:KS.Reactor.ksConstList`1.Contains(`0)">
            <summary>Checks if a value is in the list.</summary>
            <param name="value">Value to check for.</param>
            <returns>True if the value is in the list.</returns>
        </member>
        <member name="M:KS.Reactor.ksConstList`1.CopyTo(`0[],System.Int32)">
            <summary>Copies the contents of the list to an array.</summary>
            <param name="array">Array to copy to.</param>
            <param name="arrayIndex">Array index to start copying to.</param>
        </member>
        <member name="M:KS.Reactor.ksConstList`1.GetEnumerator">
            <summary>Gets the enumerator for the list.</summary>
            <returns>Enumerator for the list.</returns>
        </member>
        <member name="M:KS.Reactor.ksConstList`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Gets the enumerator for the list.</summary>
            <returns>Enumerator for the list.</returns>
        </member>
        <member name="T:KS.Reactor.ksConstMap`2">
            <summary>Wraps a dictionary and provides read-only access to it.</summary>
            <typeparam name="Key"></typeparam>
            <typeparam name="Value"></typeparam>
        </member>
        <member name="P:KS.Reactor.ksConstMap`2.Count">
            <summary>Number of entries in the map.</summary>
        </member>
        <member name="M:KS.Reactor.ksConstMap`2.#ctor(System.Collections.Generic.Dictionary{`0,`1})">
            <summary>Constructor.</summary>
            <param name="map"></param>
        </member>
        <member name="P:KS.Reactor.ksConstMap`2.Item(`0)">
            <summary>Gets a value from the map.</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksConstMap`2.Contains(`0)">
            <summary>Checks if a key is in the map.</summary>
            <param name="key">Key to check.</param>
            <returns>True if the key is in the map.</returns>
        </member>
        <member name="M:KS.Reactor.ksConstMap`2.TryGetValue(`0,`1@)">
            <summary>Tries to get a value from the map.</summary>
            <param name="key">Key to get value for.</param>
            <param name="value">Value for the key.</param>
            <returns>True if the key was found.</returns>
        </member>
        <member name="M:KS.Reactor.ksConstMap`2.GetEnumerator">
            <summary>Gets the enumerator for the map.</summary>
            <returns>Enumerator for the map.</returns>
        </member>
        <member name="M:KS.Reactor.ksConstMap`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>Gets the enumerator for the map.</summary>
            <returns>Enumerator for the map.</returns>
        </member>
        <member name="T:KS.Reactor.ksCoroutine">
            <summary>
            Wrapper for an IEnumerator function.  Each update frame, KSCoroutines started on a script will advance to the
            next return yield statement.
            </summary>
        </member>
        <member name="P:KS.Reactor.ksCoroutine.IsPaused">
            <summary>Returns the paused state of this coroutine.</summary>
        </member>
        <member name="P:KS.Reactor.ksCoroutine.IsComplete">
            <summary>Returns true if the coroutine is complete.</summary>
        </member>
        <member name="M:KS.Reactor.ksCoroutine.#ctor(System.Collections.IEnumerator)">
            <summary>Constructor.</summary>
            <param name="func">Coroutine function.</param>
        </member>
        <member name="M:KS.Reactor.ksCoroutine.Pause">
            <summary>Pauses processing of the coroutine.</summary>
        </member>
        <member name="M:KS.Reactor.ksCoroutine.Resume">
            <summary>Resumes processing of the coroutine.</summary>
        </member>
        <member name="M:KS.Reactor.ksCoroutine.Kill">
            <summary>Stops and destroy this coroutine.</summary>
        </member>
        <member name="M:KS.Reactor.ksCoroutine.RunToEnd">
            <summary>Repeatedly calls the coroutine until it is complete.</summary>
        </member>
        <member name="M:KS.Reactor.ksCoroutine.Step">
            <summary>Checks the coroutine stack, and process the top element.</summary>
            <returns>True if there is more work to do next frame, otherwise false.</returns>
        </member>
        <member name="T:KS.Reactor.ksCoroutineManager">
            <summary>
            Store and manage advancement of coroutines.
            
            Predefined Coroutines
                Sleep
            </summary>
        </member>
        <member name="T:KS.Reactor.ksCoroutineManager.CoroutineCallback">
            <summary>
            Callback invoked when the coroutine manager processes <see cref="T:KS.Reactor.ksCoroutine"/>.
            </summary>
            <param name="coroutine"><see cref="T:KS.Reactor.ksCoroutine"/> being processed</param>
            <returns>Return false to remove the coroutine from the manager.</returns>
        </member>
        <member name="M:KS.Reactor.ksCoroutineManager.#ctor">
            <summary>Constructor.</summary>
        </member>
        <member name="M:KS.Reactor.ksCoroutineManager.UpdateCoroutines(System.Single,System.Single)">
            <summary>Advances all managed coroutines.</summary>
            <param name="deltaTime">
            Simulated delta time in seconds since the last update.
            </param>
            <param name="realDeltaTime">
            Real delta time in seconds since the last update.
            </param>
        </member>
        <member name="M:KS.Reactor.ksCoroutineManager.Start(System.Collections.IEnumerator)">
            <summary>Creates a new coroutine from an IEnumerator function.</summary>
            <param name="routine">Function that will be processed once per frame.</param>
            <returns>ksCoroutine</returns>
        </member>
        <member name="M:KS.Reactor.ksCoroutineManager.Pause">
            <summary>
            Stops all coroutines.
            Warning: This will override all existing coroutine pause states.
            </summary>
        </member>
        <member name="M:KS.Reactor.ksCoroutineManager.Resume">
            <summary>
            Resumes all coroutines.
            Warning: This will override all existing coroutine pause states.
            </summary>
        </member>
        <member name="M:KS.Reactor.ksCoroutineManager.Kill">
            <summary>Kills all of the coroutines.</summary>
        </member>
        <member name="M:KS.Reactor.ksCoroutineManager.ForEach(KS.Reactor.ksCoroutineManager.CoroutineCallback)">
            <summary>
            Makes a callback for each coroutine. If the callback returns false, removes the coroutine.
            </summary>
            <param name="coroutineCallback"></param>
        </member>
        <member name="M:KS.Reactor.ksCoroutineManager.Sleep(System.Single,System.Boolean)">
            <summary>Waits for a period of time.</summary>
            <param name="time">Time in seconds.</param>
            <param name="sleepRealTime">Should the sleep time be tracked in real time</param>
            <returns>IEnumerator</returns>
        </member>
        <member name="T:KS.Reactor.ksCurve">
            <summary>
            Describes a curve defined by keyframes. Each key frame contains information to create two points
            of a cubic Bezier curve. For a given segement between keyframe k0 and k1 the bezier points are defined to be
            0, k0.Value),
            (k0.OutWeight, k0.OutTangent * t * k0.OutWeight + k0.Value),
            (1 - k1.InWeight, -k1.InTangent * t * k1.InWeight + k0.Value),
            (1, k1.Value)
            where t is k1.time - k0.time
            </summary>
        </member>
        <member name="T:KS.Reactor.ksCurve.Keyframe">
            <summary>Key frame data use to determine Bezier points.</summary>
        </member>
        <member name="F:KS.Reactor.ksCurve.Keyframe.Time">
            <summary>Keyframe time.</summary>
        </member>
        <member name="F:KS.Reactor.ksCurve.Keyframe.Value">
            <summary>Keyframe value.</summary>
        </member>
        <member name="F:KS.Reactor.ksCurve.Keyframe.InTangent">
            <summary>Normalized slope of the line leading into the keyframe.</summary>
        </member>
        <member name="F:KS.Reactor.ksCurve.Keyframe.OutTangent">
            <summary>Normalized slope of the line leading out of the keyframe.</summary>
        </member>
        <member name="F:KS.Reactor.ksCurve.Keyframe.InWeight">
            <summary>Weight to apply to the inbound tangent.</summary>
        </member>
        <member name="F:KS.Reactor.ksCurve.Keyframe.OutWeight">
            <summary>Weight to apply to the outbound tangent.</summary>
        </member>
        <member name="M:KS.Reactor.ksCurve.Keyframe.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>Constructor.</summary>
            <param name="time">Time.</param>
            <param name="value">Value.</param>
            <param name="inTangent">Normalized slope of the line leading into the keyframe.</param>
            <param name="outTangent">Normalized slope of the line leading out of the keyframe.</param>
            <param name="inWeight">Weight to apply to the inbound tangent.</param>
            <param name="outWeight">Weight to apply to the outbound tangent.</param>
        </member>
        <member name="T:KS.Reactor.ksCurve.WrapModes">
            <summary>Affects how the curve is evaluated when the time falls outside the curve duration.</summary>
        </member>
        <member name="F:KS.Reactor.ksCurve.WrapModes.First">
            <summary>Return the first keyframe value.</summary>
        </member>
        <member name="F:KS.Reactor.ksCurve.WrapModes.Last">
            <summary>Return the last keyframe value.</summary>
        </member>
        <member name="F:KS.Reactor.ksCurve.WrapModes.Loop">
            <summary>Evaluate as if the curve loops.</summary>
        </member>
        <member name="F:KS.Reactor.ksCurve.WrapModes.PingPong">
            <summary>Evaluate as if the curve loops and alternates direction.</summary>
        </member>
        <member name="T:KS.Reactor.ksCurve.EvalModes">
            <summary>Affects how the keyframes are used when evaluating a curve.</summary>
        </member>
        <member name="F:KS.Reactor.ksCurve.EvalModes.Curve">
            <summary>Evaulate by solving the y component of the bezier curve defined by the key frames.</summary>
        </member>
        <member name="F:KS.Reactor.ksCurve.EvalModes.Linear">
            <summary>Evaulate using linear interpolation between keyframe values.</summary>
        </member>
        <member name="F:KS.Reactor.ksCurve.EvalModes.Constant">
            <summary>Evaulate using the value of the keyframe that proceeds the evaluation time.</summary>
        </member>
        <member name="P:KS.Reactor.ksCurve.PreWrapMode">
            <summary>Gets/Sets the wrap mode to use when evaluating times before the start of the curve.</summary>
        </member>
        <member name="P:KS.Reactor.ksCurve.PostWrapMode">
            <summary>Gets/Sets the wrap mode to use when evaluating times past the duration of the curve.</summary>
        </member>
        <member name="P:KS.Reactor.ksCurve.Duration">
            <summary>Returns the duration of the curve. Sum of all keyframe times.</summary>
        </member>
        <member name="P:KS.Reactor.ksCurve.StartTime">
            <summary>Gets the time this curve starts.</summary>
        </member>
        <member name="P:KS.Reactor.ksCurve.EndTime">
            <summary>Gets the time this curve ends.</summary>
        </member>
        <member name="P:KS.Reactor.ksCurve.KeyFrameCount">
            <summary>Returns the number of keyframes in the curve.</summary>
        </member>
        <member name="M:KS.Reactor.ksCurve.Clear">
            <summary>Removes all keyframes from the curve.</summary>
        </member>
        <member name="M:KS.Reactor.ksCurve.AddKeyframe(KS.Reactor.ksCurve.Keyframe)">
            <summary>
            Adds a keyframe to the curve.
            Places keyframe at correct position in the keyframe list based on time.
            </summary>
            <param name="keyframe">Keyframe.</param>
            <returns>Index.</returns>
        </member>
        <member name="M:KS.Reactor.ksCurve.RemoveKeyframe(System.Int32)">
            <summary>Removes a keyframe from the curve.</summary>
            <param name="index">Keyframe index.</param>
        </member>
        <member name="M:KS.Reactor.ksCurve.Evaluate(System.Single,KS.Reactor.ksCurve.EvalModes)">
            <summary>Gets the curve value at a specific time.</summary>
            <param name="time">Time.</param>
            <param name="evalMode">Evaluation mode (Default EvalModes.Curve).</param>
            <returns>Curve value.</returns>
        </member>
        <member name="M:KS.Reactor.ksCurve.ClampTime(System.Single)">
            <summary>
            Adjusts the time to return a value within the time range of the curve.
            If the time is between the StartTime and EndTime then time is returned unmodified.
            If the time is greater than EndTime, then the PostWrapMode is applied.
            If the time is less than StartTime, then the PreWrapMode is applied.
            </summary>
            <param name="time">Unclamped time.</param>
            <returns>Clamped time.</returns>
        </member>
        <member name="M:KS.Reactor.ksCurve.GetParametricTime(System.Single,System.Single,System.Single)">
            <summary>
            Solves for the parametric value t where the following equation resolves for x.
                x = w0(1-t)^3 + 3w1t(1-t)^2 + 3w2(1-t)t^2 + wt^3
                w0 = 0, w1 = in weight, w2 = out weight, w3 = 1
            </summary>
            <param name="x"></param>
            <param name="w1"></param>
            <param name="w2"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksCurve.FromJSON(KS.Reactor.ksJSON)">
            <summary>Creates an instance of a ksCurve using JSON data.</summary>
            <param name="json">JSON data.</param>
            <returns>ksCurve value.</returns>
        </member>
        <member name="T:KS.Reactor.ksEditableAttribute">
            <summary>
            Tags fields and properties in server scripts with this to expose them to the editor.
            </summary>
        </member>
        <member name="T:KS.Reactor.ksEntityPhysics">
            <summary>Properties used by entities which have colliders in the physics system.</summary>
        </member>
        <member name="T:KS.Reactor.ksEntityPhysics.DirtyFlags">
            <summary>Flags used to indicate that a field has changed.</summary>
        </member>
        <member name="M:KS.Reactor.ksEntityPhysics.#ctor">
            <summary>Default constructor.</summary>
        </member>
        <member name="M:KS.Reactor.ksEntityPhysics.SetDirty(KS.Reactor.ksEntityPhysics.DirtyFlags)">
            <summary>Set a dirty flag bit.</summary>
            <param name="flag">Dirty flag to set.</param>
        </member>
        <member name="P:KS.Reactor.ksEntityPhysics.UpdateContacts">
            <summary>
            True if we need to generate contact data every frame this entity remains in contact with other entities.
            </summary>
        </member>
        <member name="T:KS.Reactor.ksEvent`1">
            <summary>Wraps a C# event for the delegate T to allow event references.</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:KS.Reactor.ksEvent`1.Execute">
            <summary>Gets a delegate that invokes all event handlers. Returns null if no handlers are register.</summary>
        </member>
        <member name="M:KS.Reactor.ksEvent`1.op_Addition(KS.Reactor.ksEvent{`0},`0)">
            <summary>Adds an event handler to the event.</summary>
            <param name="lhs">Event to add handler to.</param>
            <param name="rhs">handler to add.</param>
            <returns>lhs</returns>
        </member>
        <member name="M:KS.Reactor.ksEvent`1.op_Subtraction(KS.Reactor.ksEvent{`0},`0)">
            <summary>Adds an event handler to the event.</summary>
            <param name="lhs">Event to add handler to.</param>
            <param name="rhs">Handler to add.</param>
            <returns>lhs</returns>
        </member>
        <member name="T:KS.Reactor.ksEventMap`1">
            <summary>
            A dictionary of events.
            Example Usage:
            
             // Add an event handl
             map[key] += handler;
             
             // Remove an event ha
             map[key] -= handler;
             </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:KS.Reactor.ksEventMap`1.Item(System.UInt32)">
            <summary>Gets the event for a key.</summary>
        </member>
        <member name="M:KS.Reactor.ksEventMap`1.Clear">
            <summary>Unregisters all events.</summary>
        </member>
        <member name="M:KS.Reactor.ksEventMap`1.GetHandlers(System.UInt32)">
            <summary>Gets all handlers for a key.</summary>
            <param name="key">Key to get handlers for.</param>
            <returns>Handlers.</returns>
        </member>
        <member name="T:KS.Reactor.ksExceptionHandler">
            <summary>Exception handlers.</summary>
        </member>
        <member name="F:KS.Reactor.ksExceptionHandler.RethrowExceptions">
            <summary> By default don't rethrow exceptions in Unity</summary>
        </member>
        <member name="T:KS.Reactor.ksExceptionHandler.ExceptionHandler">
            <summary>Exception handler.</summary>
            <param name="message">Message.</param>
            <param name="ex">Exception.</param>
        </member>
        <member name="E:KS.Reactor.ksExceptionHandler.OnException">
            <summary>Invoked when a exception is caught in developer code.</summary>
        </member>
        <member name="M:KS.Reactor.ksExceptionHandler.Handle(System.String,System.Exception)">
            <summary>
            Handle an exception by invoking the OnException event. Logs the exception if no event handlers are
            registered. Marks the exception as handled by adding a KSReactor object to the exception data if rethrowing
            is enabled.
            </summary>
            <param name="message">Message.</param>
            <param name="ex">Exceptions.</param>
        </member>
        <member name="T:KS.Reactor.ksFixedDataParser">
            <summary>A class that parses byte array to uint or struct.</summary>
        </member>
        <member name="M:KS.Reactor.ksFixedDataParser.ParseEncodedUInt(System.Byte[],System.Int32@)">
            <summary>
            Read out an encoded uint from a byte array.
            The lowest bit positions of the encoded value signal the number of bytes to read.
            If the first bit is 0, then the value is in bits 1 to 7.
            If the first two bits are 01, then value is in bits 2 to 15.
            If the first two bits are 11, then value is in bits 2 to 31.
            </summary>
            <param name="data">Input byte array.</param>
            <param name="offset">Offset to begin reading from.</param>
            <returns>The uint read out.</returns>
        </member>
        <member name="M:KS.Reactor.ksFixedDataParser.ParseFromBytes``1(System.Byte[],System.Int32)">
            <summary>Read a struct from a byte array</summary>
            <typeparam name="T">Type of the struct to read out.</typeparam>
            <param name="inputdata">Input byte array.</param>
            <param name="offset">Offset to begin reading from.</param>
            <returns>Output struct</returns>
        </member>
        <member name="M:KS.Reactor.ksFixedDataParser.ParseFromUInt``1(System.UInt32)">
            <summary>Convert the bytes of a uint into another struct.</summary>
            <typeparam name="T">Type of the struct to convert to.</typeparam>
            <param name="inputData">Input uint data.</param>
            <returns>Output struct.</returns>
        </member>
        <member name="T:KS.Reactor.ksFixedDataWriter">
            <summary>A class that writes uint or struct to a byte array.</summary>
        </member>
        <member name="M:KS.Reactor.ksFixedDataWriter.WriteEncodedUInt(System.Byte[],System.Int32,System.Int32,System.UInt32)">
            <summary>
            Write a uint as an encoded value.  This value must be less than 2^30
            The lowest bit positions of the encoded value signal the number of bytes to read.
            If the value is less than or equal to  2^7-1, the first bit is a 0 and the value is placed in bits 1 to 7.
            If the value is less than or equal to  2^14-1, the first two bits are 01 and the value is placed in bits 2 to 15.
            If the value is less than or equal to  2^30-1, the first two bits are 11 and the value is placed in bits 2 to 31.
            </summary>
            <param name="output">Output byte array.</param>
            <param name="spaceAvailable">Amount of space available for writing.</param>
            <param name="offset">Offset to begin writing at.</param>
            <param name="value">Value to write.</param>
            <returns>Number of bytes written, or -1 on an error</returns>
        </member>
        <member name="M:KS.Reactor.ksFixedDataWriter.WriteData``1(System.Byte[],System.Int32,System.Int32,``0)">
            <summary>Write data to a byte array.</summary>
            <typeparam name="T">Type of data to write.</typeparam>
            <param name="output">Output byte array.</param>
            <param name="spaceAvailable">Amount of space available for writing.</param>
            <param name="offset">Offset to begin writing at.</param>
            <param name="data">Data to write.</param>
            <returns>Number of bytes written, or -1 on an error.</returns>
        </member>
        <member name="T:KS.Reactor.ksGroupMaskFilter">
            <summary>
            A query filter that looks for colliders that belong to one of the collision groups in the
            <see cref="P:KS.Reactor.ksGroupMaskFilter.GroupMask"/>. All hits <see cref="F:KS.Reactor.ksQueryHitTypes.TOUCH"/>.
            </summary>
        </member>
        <member name="P:KS.Reactor.ksGroupMaskFilter.GroupMask">
            <summary>
            Queries only hit colliders that belong to at least one of the collision groups in this mask.
            </summary>
        </member>
        <member name="M:KS.Reactor.ksGroupMaskFilter.#ctor(System.UInt32)">
            <summary>Constructor</summary>
            <param name="groupMask">
            Queries only hit colliders that belong to at least one of the collision groups in this mask.
            </param>
        </member>
        <member name="M:KS.Reactor.ksGroupMaskFilter.Filter(KS.Reactor.ksICollider,KS.Reactor.ksICollider,KS.Reactor.ksQueryResultTypes,KS.Reactor.ksBaseQueryParams)">
            <summary>
            Determines if a potential collider hit should be included in query results and whether it is a blocking or
            touching hit.
            </summary>
            <param name="queryCollider">The collider used in the query. Null for shape queries.</param>
            <param name="hitCollider">The collider being evaluated for a hit.</param>
            <param name="resultType">What kind of results the query returns</param>
            <param name="args">Query parameters</param>
            <returns>Hit type</returns>
        </member>
        <member name="T:KS.Reactor.ksHashSet`1">
            <summary>A hash set with an event that fires when the hash set is modified.</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:KS.Reactor.ksHashSet`1.ModifyHandler">
            <summary>Set that was modified.</summary>
            <param name="set"></param>
        </member>
        <member name="F:KS.Reactor.ksHashSet`1.OnModify">
            <summary>Invoked when the hash set is modified.</summary>
        </member>
        <member name="P:KS.Reactor.ksHashSet`1.Count">
            <summary>The number of elements in the set.</summary>
        </member>
        <member name="P:KS.Reactor.ksHashSet`1.IsReadOnly">
            <summary>Is this collection read-only? Always false.</summary>
        </member>
        <member name="M:KS.Reactor.ksHashSet`1.#ctor">
            <summary>Constructor.</summary>
        </member>
        <member name="M:KS.Reactor.ksHashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>Constructor.</summary>
            <param name="elements">Elements to initialize the set with.</param>
        </member>
        <member name="M:KS.Reactor.ksHashSet`1.Add(`0)">
            <summary>Adds an element to the set if it is not already in the set.</summary>
            <param name="element">Element to add.</param>
            <returns>True if the element was added. False if it was already in the set.</returns>
        </member>
        <member name="M:KS.Reactor.ksHashSet`1.Add(`0[])">
            <summary>Adds elements to the set.</summary>
            <param name="elements">Elements to add.</param>
        </member>
        <member name="M:KS.Reactor.ksHashSet`1.Add(System.Collections.Generic.IEnumerable{`0})">
            <summary>Adds elements to the set.</summary>
            <param name="elements">Elements to add.</param>
        </member>
        <member name="M:KS.Reactor.ksHashSet`1.Remove(`0)">
            <summary>Removes an element from the set.</summary>
            <param name="element">Element to remove.</param>
            <returns>True if the element was removed. False if the element was not in the set.</returns>
        </member>
        <member name="M:KS.Reactor.ksHashSet`1.Remove(`0[])">
            <summary>Removes elements from the set.</summary>
            <param name="elements">Elements to remove.</param>
        </member>
        <member name="M:KS.Reactor.ksHashSet`1.Remove(System.Collections.Generic.IEnumerable{`0})">
            <summary>Removes elements from the set.</summary>
            <param name="elements">Elements to remove.</param>
        </member>
        <member name="M:KS.Reactor.ksHashSet`1.Set(`0[])">
            <summary>Clears the set and adds the given elements.</summary>
            <param name="elements"></param>
        </member>
        <member name="M:KS.Reactor.ksHashSet`1.Set(System.Collections.Generic.IEnumerable{`0})">
            <summary>Clears the set and adds the given elements.</summary>
            <param name="elements"></param>
        </member>
        <member name="M:KS.Reactor.ksHashSet`1.Clear">
            <summary>Clears the set.</summary>
        </member>
        <member name="M:KS.Reactor.ksHashSet`1.Contains(`0)">
            <summary>Checks if the set contains an element?</summary>
            <param name="element">Element to check for.</param>
            <returns>True if the element is in the set.</returns>
        </member>
        <member name="M:KS.Reactor.ksHashSet`1.ContainsAll(`0[])">
            <summary>Checks if the set contains all of the given elements.</summary>
            <param name="elements">Elements to check for.</param>
            <returns>True if all of the elements are in the set.</returns>
        </member>
        <member name="M:KS.Reactor.ksHashSet`1.ContainsAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>Checks if the set contains all of the given elements.</summary>
            <param name="elements">Elements to check for.</param>
            <returns>True if all of the elements are in the set.</returns>
        </member>
        <member name="M:KS.Reactor.ksHashSet`1.ContainsAny(`0[])">
            <summary>Checks if the set contains any of the given elements.</summary>
            <param name="elements">Elements to check for.</param>
            <returns>True if any of the elements are in the set.</returns>
        </member>
        <member name="M:KS.Reactor.ksHashSet`1.ContainsAny(System.Collections.Generic.IEnumerable{`0})">
            <summary>Checks if the set contains any of the given elements.</summary>
            <param name="elements">Elements to check for.</param>
            <returns>True if any of the elements are in the set.</returns>
        </member>
        <member name="M:KS.Reactor.ksHashSet`1.CopyTo(`0[],System.Int32)">
            <summary>Copies the set elements into an array.</summary>
            <param name="array">Array to copy elements into.</param>
            <param name="arrayIndex">Array index to start copying to.</param>
        </member>
        <member name="M:KS.Reactor.ksHashSet`1.GetEnumerator">
            <summary>Gets the enumerator.</summary>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksHashSet`1.System#Collections#Generic#ICollection{T}#Add(`0)">
            <summary>Adds an element to the set.</summary>
            <param name="element">Element to add.</param>
        </member>
        <member name="M:KS.Reactor.ksHashSet`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
            <summary>Get the enumerator.</summary>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksHashSet`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Get the enumerator.</summary>
            <returns></returns>
        </member>
        <member name="T:KS.Reactor.ksHierarchyObject`1">
            <summary>
            Templated base class for hierarchy objects that have a parent and list of children of type T. There is also a
            non-templated variant of ksHierarchyObject.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:KS.Reactor.ksHierarchyObject`1.ForEachCallback">
            <summary>Callback for depth-first searches.</summary>
            <param name="obj">Object being iterated.</param>
            <returns>True to iterate the children of the object.</returns>
        </member>
        <member name="P:KS.Reactor.ksHierarchyObject`1.Parent">
            <summary>Parent.</summary>
        </member>
        <member name="P:KS.Reactor.ksHierarchyObject`1.Children">
            <summary>Children</summary>
        </member>
        <member name="P:KS.Reactor.ksHierarchyObject`1.Descendants">
            <summary>Iterator for descendants.</summary>
        </member>
        <member name="P:KS.Reactor.ksHierarchyObject`1.SelfAndDescendants">
            <summary>Iterator for this object and its descendants.</summary>
        </member>
        <member name="P:KS.Reactor.ksHierarchyObject`1.Ancestors">
            <summary>Iterator for ancestors.</summary>
        </member>
        <member name="P:KS.Reactor.ksHierarchyObject`1.SelfAndAncestors">
            <summary>Iterator for this object and its ancestors.</summary>
        </member>
        <member name="M:KS.Reactor.ksHierarchyObject`1.#ctor">
            <summary>Constructor.</summary>
        </member>
        <member name="M:KS.Reactor.ksHierarchyObject`1.AddChild(`0)">
            <summary>
            Adds a child to the object if that does not create a circular reference. If the child has another parent,
            removes it from its parent first. Throws ArgumentNullException if the child is null.
            </summary>
            <param name="child">Child to add.</param>
            <returns>
            True if the child was added. False if it could not be added, either because it was already added or adding
            it would create a circular reference.
            </returns>
        </member>
        <member name="M:KS.Reactor.ksHierarchyObject`1.PerformAddChild(`0)">
            <summary>
            Protected implementation of AddChild. The public AddChild calls this one. Derived classes can override
            either to change public or internal behaviour.
            
            Adds a child to the object if that does not create a circular reference. If the child has another parent,
             removes it from its parent first. Throws ArgumentNullException if the child is null.
            </summary>
            <param name="child">Child to add.</param>
            <returns>
            True if the child was added. False if it could not be added, either because it was already added or adding
            it would create a circular reference.
            </returns>
        </member>
        <member name="M:KS.Reactor.ksHierarchyObject`1.InsertChild(System.Int32,`0)">
            <summary>
            Inserts a child at an index if that does not create a circular reference. If the child has another parent,
            removes it from its parent first. Throws ArgumentNullException if the child is null.
            </summary>
            <param name="index">Index to insert at.</param>
            <param name="child">Child to insert.</param>
            <returns>
            True if the child was inserted. False if it could not be inserted, either because it was already added,
            adding it would create a circular reference, or the index was out of bounds.
            </returns>
        </member>
        <member name="M:KS.Reactor.ksHierarchyObject`1.PerformInsertChild(System.Int32,`0)">
            <summary>
            Protected implementation of InsertChild. The public InsertChild calls this one. Derived classes can override
            either to change public or internal behaviour.
            
            Inserts a child at an index if that does not create a circular reference. If the child has another parent,
            removes it from its parent first. Throws ArgumentNullException if the child is null.
            </summary>
            <param name="index">Index to insert at.</param>
            <param name="child">Child to insert.</param>
            <returns>
            True if the child was inserted. False if it could not be inserted, either because it was already added,
            adding it would create a circular reference, or the index was out of bounds.
            </returns>
        </member>
        <member name="M:KS.Reactor.ksHierarchyObject`1.RemoveChild(`0)">
            <summary>Removes a child from this object. Throws ArgumentNullException if child is null.</summary>
            <param name="child">Child to remove.</param>
            <returns>True if the child was found and removed.</returns>
        </member>
        <member name="M:KS.Reactor.ksHierarchyObject`1.PerformRemoveChild(`0)">
            <summary>
            Protected implementation of RemoveChild. The public RemoveChild calls this one. Derived classes can
            override either to change public or internal behaviour.
            
            Removes a child from this object. Throws ArgumentNullException if child is null.
            </summary>
            <param name="child">Child to remove.</param>
            <returns>True if the child was found and removed.</returns>
        </member>
        <member name="M:KS.Reactor.ksHierarchyObject`1.Detach">
            <summary>Removes the object from its parent. Does nothing if the object has no parent.</summary>
        </member>
        <member name="M:KS.Reactor.ksHierarchyObject`1.PerformDetach">
            <summary>
            Protected implementation of Detach.
            
            Removes the object from its parent. Does nothing if the object has no parent.
            </summary>
        </member>
        <member name="M:KS.Reactor.ksHierarchyObject`1.IsDescendantOf(`0)">
            <summary>Checks if an object is a descendant of this object.</summary>
            <param name="obj">Object to check.</param>
            <returns>True if obj is a descendant of this object.</returns>
        </member>
        <member name="M:KS.Reactor.ksHierarchyObject`1.ForEachDescendant(KS.Reactor.ksHierarchyObject{`0}.ForEachCallback)">
            <summary>Iterates the descendants using depth-first search.</summary>
            <param name="callback">
            Callback to call on descendants. If it returns false, will not iterate children.
            </param>
        </member>
        <member name="M:KS.Reactor.ksHierarchyObject`1.ForSelfAndDescendants(KS.Reactor.ksHierarchyObject{`0}.ForEachCallback)">
            <summary>Iterates this object and its descendants using depth-first search.</summary>
            <param name="callback">
            Callback to call on descendants. If it returns false, will not iterate children.
            </param>
        </member>
        <member name="T:KS.Reactor.ksHierarchyObject">
            <summary>
            Non-templated base class for hierarchy objects with a parent and children. There is also a templated variant
            that enforces all objects in the hierarchy derive the templated type.
            </summary>
        </member>
        <member name="T:KS.Reactor.ksICharacterController">
            <summary>
            Character controller interface.
            </summary>
        </member>
        <member name="P:KS.Reactor.ksICharacterController.SlopeLimit">
            <summary>
            Slope limit in degrees.
            </summary>
        </member>
        <member name="P:KS.Reactor.ksICharacterController.StepOffset">
            <summary>
            Step offset.
            </summary>
        </member>
        <member name="P:KS.Reactor.ksICharacterController.SkinWidth">
            <summary>
            Collision skin width.
            </summary>
        </member>
        <member name="P:KS.Reactor.ksICharacterController.MinMoveDistance">
            <summary>
            Minimum move distance of the character controller. If travelled distance is smaller, the character doesn't
            move. This is used to stop the recursive motion algorithm when remaining distance to travel is small.
            </summary>
        </member>
        <member name="P:KS.Reactor.ksICharacterController.Offset">
            <summary>
            The offset of the character's collider relative to the transform's position.
            </summary>
        </member>
        <member name="P:KS.Reactor.ksICharacterController.Radius">
            <summary>
            The radius of the character's capsule.
            </summary>
        </member>
        <member name="P:KS.Reactor.ksICharacterController.Height">
            <summary>
            The height of the character's capsule.
            </summary>
        </member>
        <member name="P:KS.Reactor.ksICharacterController.EnableOverlapRecovery">
            <summary>
            Enables or disables overlap recovery. Used to depenetrate character controllers from static objects when an
            overlap is detected.
            </summary>
        </member>
        <member name="P:KS.Reactor.ksICharacterController.DetectCollisions">
            <summary>
            Determines whether other rigidbodies or character controllers collide with this character controller.
            </summary>
        </member>
        <member name="P:KS.Reactor.ksICharacterController.CollisionFlags">
            <summary>
            What part of the capsule collided with the environment during the last CharacterController.Move call.
            </summary>
        </member>
        <member name="P:KS.Reactor.ksICharacterController.IsGrounded">
            <summary>
            Was the CharacterController touching the ground during the last move?
            </summary>
        </member>
        <member name="P:KS.Reactor.ksICharacterController.Velocity">
            <summary>
            The current relative velocity of the character.
            </summary>
        </member>
        <member name="E:KS.Reactor.ksICharacterController.OnColliderHit">
            <summary>
            Invoked when the character controller hit a collider.
            </summary>
        </member>
        <member name="M:KS.Reactor.ksICharacterController.SimpleMove(KS.Reactor.ksVector3)">
            <summary>
            Moves the character with velocity. Gravity is automatically applied. Returns if the character is grounded.
            </summary>
            <param name="velocity"></param>
            <returns>True if the character is grounded.</returns>
        </member>
        <member name="M:KS.Reactor.ksICharacterController.Move(KS.Reactor.ksVector3)">
            <summary>
            Moves the character with a displacement vector. Users are responsible for applying gravity to characters.
            </summary>
            <param name="motion"></param>
            <returns></returns>
        </member>
        <member name="T:KS.Reactor.ksICollider">
            <summary>
            Collider interface used in common scripts that run on server and client
            </summary>
        </member>
        <member name="P:KS.Reactor.ksICollider.Entity">
            <summary>Entity the collider is attached to</summary>
        </member>
        <member name="P:KS.Reactor.ksICollider.ContactOffset">
            <summary>Get/Set contact offset on a collider</summary>
        </member>
        <member name="P:KS.Reactor.ksICollider.IsEnabled">
            <summary>Get/Set the enabled state of a collider</summary>
        </member>
        <member name="P:KS.Reactor.ksICollider.IsQueryCollider">
            <summary>Get/Set if this collider is used in scene queries.</summary>
        </member>
        <member name="P:KS.Reactor.ksICollider.IsSimulationCollider">
            <summary>Get/Set if this collider is used in physics simulations.</summary>
        </member>
        <member name="P:KS.Reactor.ksICollider.IsTrigger">
            <summary>Get/Set if this collider is a trigger.</summary>
        </member>
        <member name="P:KS.Reactor.ksICollider.CollisionFilter">
            <summary>Get/Set the collision filter on the collider.</summary>
        </member>
        <member name="P:KS.Reactor.ksICollider.Bounds">
            <summary>
            Get the bounds of a collider at the position of its attached entity or at the origin
            if the collider is not attached to an entity.
            </summary>
        </member>
        <member name="T:KS.Reactor.ksIEntity">
            <summary>Entity interface that both client and server entities implement.</summary>
        </member>
        <member name="P:KS.Reactor.ksIEntity.Id">
            <summary>Entity id.</summary>
        </member>
        <member name="P:KS.Reactor.ksIEntity.Type">
            <summary>Entity type.</summary>
        </member>
        <member name="P:KS.Reactor.ksIEntity.IsDestroyed">
            <summary>Is the entity destroyed?</summary>
        </member>
        <member name="P:KS.Reactor.ksIEntity.Transform">
            <summary>Transform</summary>
        </member>
        <member name="P:KS.Reactor.ksIEntity.Transform2D">
            <summary>2D Transform</summary>
        </member>
        <member name="P:KS.Reactor.ksIEntity.Properties">
            <summary>Entity properties.</summary>
        </member>
        <member name="P:KS.Reactor.ksIEntity.CollisionFilter">
            <summary>Determines which entities to collide with and notify of collision/overlap events.</summary>
        </member>
        <member name="T:KS.Reactor.ksInput">
            <summary>Class for querying player inputs.</summary>
        </member>
        <member name="T:KS.Reactor.ksInput.State">
            <summary>Button states.</summary>
        </member>
        <member name="P:KS.Reactor.ksInput.IsUsed">
            <summary>Has this input been used?</summary>
        </member>
        <member name="P:KS.Reactor.ksInput.CanDestroy">
            <summary>
            If false, calls to CleanUp will do nothing instead of clearing the state and returning the object to the
            object pool.
            </summary>
        </member>
        <member name="P:KS.Reactor.ksInput.MultiButtonStateEnabled">
            <summary>
            If true and multiple client frames are combined into one input frame, a button can be both pressed and
            released in the same frame if it's up/down state changed multiple times in the same frame. If false, the
            up/down state of a button can only change once in one input frame.
            
            Eg. Three client frames are combined into one input frame. The button is up on the first frame, down on the
            second, and up again on the third. If MultiButtonStateEnabled is true, this produces one input frame
            where Input.IsDown returns false, and Input.IsPressed and Input.IsReleased return true. If
            MultiButtonStateEnabled is false, this produces one input frame where Input.IsDown and Input.IsPressed
            return true and Input.IsReleased returns false. If the button up/down state does not change again during
            the next input frame, Input.IsDown will return false and Input.IsReleased will return true on the next
            input frame.
            </summary>
        </member>
        <member name="P:KS.Reactor.ksInput.Updated">
            <summary>Have we updated inputs since the last input frame?</summary>
        </member>
        <member name="M:KS.Reactor.ksInput.#ctor">
            <summary>Constructor</summary>
        </member>
        <member name="M:KS.Reactor.ksInput.IsDown(System.UInt32)">
            <summary>Checks if a button is down.</summary>
            <param name="button">Button to check.</param>
            <returns>True if the button is down.</returns>
        </member>
        <member name="M:KS.Reactor.ksInput.IsPressed(System.UInt32)">
            <summary>
            Checks if a button was pressed. This will be true for one frame when a button is pressed.
            </summary>
            <param name="button">Button to check.</param>
            <returns>True if the button was pressed.</returns>
        </member>
        <member name="M:KS.Reactor.ksInput.IsReleased(System.UInt32)">
            <summary>
            Checks if a button was released. This will be true for one frame when a button is released.
            </summary>
            <param name="button">Button to check.</param>
            <returns>True if the button was released.</returns>
        </member>
        <member name="M:KS.Reactor.ksInput.GetAxis(System.UInt32)">
            <summary>Gets the value of an axis.</summary>
            <param name="axis">Axis to get value for.</param>
            <returns>Value of the axis.</returns>
        </member>
        <member name="M:KS.Reactor.ksInput.Use">
            <summary>Marks the input as used.</summary>
        </member>
        <member name="M:KS.Reactor.ksInput.CleanUp">
            <summary>
            Clears the state and returns the object to the pool. It is recommended you call this when you are done with
            an input.
            </summary>
        </member>
        <member name="M:KS.Reactor.ksInput.Clone">
            <summary>Creates a copy of this object.</summary>
            <returns>A copy of this object.</returns>
        </member>
        <member name="M:KS.Reactor.ksInput.GetState(System.UInt32)">
            <summary>Gets the state of a button.</summary>
            <param name="button">Button to get state for.</param>
            <returns>State of the button.</returns>
        </member>
        <member name="M:KS.Reactor.ksInput.SetButton(System.UInt32,System.Boolean)">
            <summary>Updates a button's state.</summary>
            <param name="button">Button to update.</param>
            <param name="down">True if the button is down.</param>
            <returns>True if the button's state changed.</returns>
        </member>
        <member name="M:KS.Reactor.ksInput.SetAxis(System.UInt32,System.Single)">
            <summary>Sets the value of an axis.</summary>
            <param name="axis">Axis to set value of.</param>
            <param name="value">Value to set.</param>
            <returns>True if the axis's value changed.</returns>
        </member>
        <member name="M:KS.Reactor.ksInput.SetState(System.UInt32,KS.Reactor.ksInput.State)">
            <summary>Sets the state of a button.</summary>
            <param name="button">Button to set state of.</param>
            <param name="state">State to set.</param>
        </member>
        <member name="T:KS.Reactor.ksInputRegistrar">
            <summary>
            Buttons, axes, and controllers are registered with an ksInputRegistrar while they are in use so we know which
            inputs to send over the network.
            </summary>
        </member>
        <member name="P:KS.Reactor.ksInputRegistrar.Buttons">
            <summary>Buttons that are registered.</summary>
        </member>
        <member name="P:KS.Reactor.ksInputRegistrar.Axes">
            <summary>Axes that are registered.</summary>
        </member>
        <member name="P:KS.Reactor.ksInputRegistrar.Controllers">
            <summary>Controller types that are registered.</summary>
        </member>
        <member name="P:KS.Reactor.ksInputRegistrar.StateDirty">
            <summary>True if input has changed since the last time we sent input to the server.</summary>
        </member>
        <member name="P:KS.Reactor.ksInputRegistrar.NumReportedControllers">
            <summary>Number of controller types we sent input for last update.</summary>
        </member>
        <member name="M:KS.Reactor.ksInputRegistrar.#ctor">
            <summary>Constructor.</summary>
        </member>
        <member name="M:KS.Reactor.ksInputRegistrar.RegisterButtons(System.UInt32[])">
            <summary>Registers buttons used by a ksPlayerController.</summary>
            <param name="buttons">Buttons to register.</param>
        </member>
        <member name="M:KS.Reactor.ksInputRegistrar.RegisterAxes(System.UInt32[])">
            <summary>Registers axes used by a ksPlayerController.</summary>
            <param name="axes">Axes to register.</param>
        </member>
        <member name="M:KS.Reactor.ksInputRegistrar.RegisterController(KS.Reactor.ksPlayerController)">
            <summary>Registers a controller.</summary>
            <param name="controller">Controller to register.</param>
        </member>
        <member name="M:KS.Reactor.ksInputRegistrar.UnregisterController(KS.Reactor.ksPlayerController)">
            <summary>Unregisters a controller.</summary>
            <param name="controller">Controller to unregister.</param>
        </member>
        <member name="M:KS.Reactor.ksInputRegistrar.CheckControllersDirty">
            <summary>
            Checks if registered controller types have changes since the last time we sent input to the server.
            </summary>
            <returns>True if registered controllers have changed.</returns>
        </member>
        <member name="M:KS.Reactor.ksInputRegistrar.RecordControllers">
            <summary>
            Records the list of registered controllers so we can later compare with it to see if controllers have
            changed.
            </summary>
        </member>
        <member name="M:KS.Reactor.ksInputRegistrar.Clear">
            <summary>Unregisters everything.</summary>
        </member>
        <member name="M:KS.Reactor.ksInputRegistrar.IsButtonRegistered(System.UInt32)">
            <summary>Checks if a button is registered.</summary>
            <param name="button">Button to check.</param>
            <returns>True if the button is registered.</returns>
        </member>
        <member name="M:KS.Reactor.ksInputRegistrar.IsAxisRegistered(System.UInt32)">
            <summary>Checks if an axis is registered.</summary>
            <param name="axis">Axis to check.</param>
            <returns>True if the axis is registered.</returns>
        </member>
        <member name="M:KS.Reactor.ksInputRegistrar.IsControllerRegistered(System.UInt32)">
            <summary>Checks if a controller type is registered.</summary>
            <param name="controller">Controller type to check.</param>
            <returns>True if the controller type is registred.</returns>
        </member>
        <member name="M:KS.Reactor.ksInputRegistrar.AddButton(System.UInt32)">
            <summary>Adds a button to the registrar.</summary>
            <param name="button">Button to add.</param>
        </member>
        <member name="M:KS.Reactor.ksInputRegistrar.RemoveButton(System.UInt32)">
            <summary>Removes a button from the registrar.</summary>
            <param name="button">Button to remove.</param>
        </member>
        <member name="M:KS.Reactor.ksInputRegistrar.AddAxis(System.UInt32)">
            <summary>Adds an axis to the registrar.</summary>
            <param name="axis">Axis to add.</param>
        </member>
        <member name="M:KS.Reactor.ksInputRegistrar.RemoveAxis(System.UInt32)">
            <summary>Removes an axis from the registrar.</summary>
            <param name="axis">Axis to remove.</param>
        </member>
        <member name="T:KS.Reactor.ksQueryHitTypes">
            <summary>Types of hits.</summary>
        </member>
        <member name="F:KS.Reactor.ksQueryHitTypes.NONE">
            <summary>Ignore the hit.</summary>
        </member>
        <member name="F:KS.Reactor.ksQueryHitTypes.TOUCH">
            <summary>Include the hit without blocking further hits.</summary>
        </member>
        <member name="F:KS.Reactor.ksQueryHitTypes.BLOCK">
            <summary>Include the hit and block further hits (does not block overlap queries).</summary>
        </member>
        <member name="T:KS.Reactor.ksQueryResultTypes">
            <summary>Type of results the query will return.</summary>
        </member>
        <member name="F:KS.Reactor.ksQueryResultTypes.ANY">
            <summary>The query will return any blocking hit.</summary>
        </member>
        <member name="F:KS.Reactor.ksQueryResultTypes.NEAREST">
            <summary>The query will return the nearest blocking hit.</summary>
        </member>
        <member name="F:KS.Reactor.ksQueryResultTypes.MULTIPLE">
            <summary>
            The query will return the nearest blocking hit and any touching hits before the nearest blocking hit.
            </summary>
        </member>
        <member name="T:KS.Reactor.ksIQueryFilter">
            <summary>Interface for query filters that filter colliders from scene queries.</summary>
        </member>
        <member name="M:KS.Reactor.ksIQueryFilter.Filter(KS.Reactor.ksICollider,KS.Reactor.ksICollider,KS.Reactor.ksQueryResultTypes,KS.Reactor.ksBaseQueryParams)">
            <summary>
            Determines if a potential collider hit should be included in query results and whether it is a blocking or
            touching hit.
            </summary>
            <param name="queryCollider">The collider used in the query. Null for shape queries.</param>
            <param name="hitCollider">The collider being evaluated for a hit.</param>
            <param name="resultType">What kind of results the query returns</param>
            <param name="args">Query parameters</param>
            <returns>Hit type</returns>
        </member>
        <member name="T:KS.Reactor.ksIEntityQueryColliderFilter">
            <summary>
            Interface for query collider filters that are used with entity queries to decide which of the entity's
            colliders to run queries for.
            </summary>
        </member>
        <member name="M:KS.Reactor.ksIEntityQueryColliderFilter.Filter(KS.Reactor.ksICollider,KS.Reactor.ksOverlapParams)">
            <summary>Determines if we should run a query with a <paramref name="queryCollider"/>.</summary>
            <param name="queryCollider">The collider we are checking if we should run a query for.</param>
            <param name="args">Query parameters</param>
            <returns>True to run the query, or false not to.</returns>
        </member>
        <member name="T:KS.Reactor.ksIQueryHitResult">
            <summary>Interface for <see cref="T:KS.Reactor.ksSweepResult"/> and <see cref="T:KS.Reactor.ksRaycastResult"/>.</summary>
        </member>
        <member name="P:KS.Reactor.ksIQueryHitResult.Entity">
            <summary>Entity hit by the query.</summary>
        </member>
        <member name="P:KS.Reactor.ksIQueryHitResult.Collider">
            <summary>Collider hit by the query.</summary>
        </member>
        <member name="P:KS.Reactor.ksIQueryHitResult.Point">
            <summary>Point on the surface of the entity where the hit instersected</summary>
        </member>
        <member name="P:KS.Reactor.ksIQueryHitResult.Normal">
            <summary>Normal of the surface where the hit point is.</summary>
        </member>
        <member name="P:KS.Reactor.ksIQueryHitResult.Distance">
            <summary>Distance along the query when the intersection was detected.</summary>
        </member>
        <member name="P:KS.Reactor.ksIQueryHitResult.IsValid">
            <summary>A hit result is only valid if it includes an entity reference.</summary>
        </member>
        <member name="P:KS.Reactor.ksIQueryHitResult.IsInitialOverlap">
            <summary>Is the entity/collider overlapping with the query origin?</summary>
        </member>
        <member name="T:KS.Reactor.ksIReadOnlyTransform">
            <summary>Read-only transform interface.</summary>
        </member>
        <member name="P:KS.Reactor.ksIReadOnlyTransform.Position">
            <summary>Position</summary>
        </member>
        <member name="P:KS.Reactor.ksIReadOnlyTransform.Rotation">
            <summary>Rotation</summary>
        </member>
        <member name="P:KS.Reactor.ksIReadOnlyTransform.Scale">
            <summary>Scale</summary>
        </member>
        <member name="T:KS.Reactor.ksReadOnlyTransformExtension">
            <summary>Extension methods for <see cref="T:KS.Reactor.ksIReadOnlyTransform"/></summary>
        </member>
        <member name="M:KS.Reactor.ksReadOnlyTransformExtension.Forward(KS.Reactor.ksIReadOnlyTransform)">
            <summary>Gets the local forward direction.</summary>
            <returns>Forward</returns>
        </member>
        <member name="M:KS.Reactor.ksReadOnlyTransformExtension.Up(KS.Reactor.ksIReadOnlyTransform)">
            <summary>Gets the local up direction.</summary>
            <returns>Up</returns>
        </member>
        <member name="M:KS.Reactor.ksReadOnlyTransformExtension.Right(KS.Reactor.ksIReadOnlyTransform)">
            <summary>Gets the local right direction.</summary>
            <returns>Right</returns>
        </member>
        <member name="M:KS.Reactor.ksReadOnlyTransformExtension.Backwards(KS.Reactor.ksIReadOnlyTransform)">
            <summary>Gets the local backwards direction.</summary>
            <returns>Backwards</returns>
        </member>
        <member name="M:KS.Reactor.ksReadOnlyTransformExtension.Down(KS.Reactor.ksIReadOnlyTransform)">
            <summary>Gets the local down direction.</summary>
            <returns>Down</returns>
        </member>
        <member name="M:KS.Reactor.ksReadOnlyTransformExtension.Left(KS.Reactor.ksIReadOnlyTransform)">
            <summary>Gets the local left direction.</summary>
            <returns>Left</returns>
        </member>
        <member name="M:KS.Reactor.ksReadOnlyTransformExtension.ToWorld(KS.Reactor.ksIReadOnlyTransform,KS.Reactor.ksVector3)">
            <summary>Converts a point from local space to world space.</summary>
            <param name="localPosition">Point in local space.</param>
            <returns>Point in world space.</returns>
        </member>
        <member name="M:KS.Reactor.ksReadOnlyTransformExtension.ToLocal(KS.Reactor.ksIReadOnlyTransform,KS.Reactor.ksVector3)">
            <summary>Converts a point from world space to local space.</summary>
            <param name="worldPosition">Point in world space.</param>
            <returns>Point in local space.</returns>
        </member>
        <member name="T:KS.Reactor.ksIReadOnlyTransform2D">
            <summary>Read-only 2D transform interface.</summary>
        </member>
        <member name="P:KS.Reactor.ksIReadOnlyTransform2D.Position">
            <summary>Position</summary>
        </member>
        <member name="P:KS.Reactor.ksIReadOnlyTransform2D.Rotation">
            <summary>Rotation in degrees.</summary>
        </member>
        <member name="P:KS.Reactor.ksIReadOnlyTransform2D.RotationRadians">
            <summary>Rotation in radians.</summary>
        </member>
        <member name="P:KS.Reactor.ksIReadOnlyTransform2D.Scale">
            <summary>Scale</summary>
        </member>
        <member name="T:KS.Reactor.ksReadOnlyTransform2DExtension">
            <summary>Extension methods for <see cref="T:KS.Reactor.ksIReadOnlyTransform2D"/></summary>
        </member>
        <member name="M:KS.Reactor.ksReadOnlyTransform2DExtension.Forward(KS.Reactor.ksIReadOnlyTransform2D)">
            <summary>Returns the local forward direction. At 0 rotation this is (1, 0).</summary>
            <returns>Forward</returns>
        </member>
        <member name="M:KS.Reactor.ksReadOnlyTransform2DExtension.Left(KS.Reactor.ksIReadOnlyTransform2D)">
            <summary>Returns the local left direction. At 0 rotation this is (0, 1).</summary>
            <returns>Left</returns>
        </member>
        <member name="M:KS.Reactor.ksReadOnlyTransform2DExtension.Right(KS.Reactor.ksIReadOnlyTransform2D)">
            <summary>Returns the local right direction. At 0 rotation this is (0, -1).</summary>
            <returns>Right</returns>
        </member>
        <member name="M:KS.Reactor.ksReadOnlyTransform2DExtension.Backwards(KS.Reactor.ksIReadOnlyTransform2D)">
            <summary>Returns the local backwards direction. At 0 rotation this is (-1, 0).</summary>
            <returns>Backwards</returns>
        </member>
        <member name="M:KS.Reactor.ksReadOnlyTransform2DExtension.ToWorld(KS.Reactor.ksIReadOnlyTransform2D,KS.Reactor.ksVector2)">
            <summary>Converts a point from local space to world space.</summary>
            <param name="localPosition"></param>
            <returns>Position in world space.</returns>
        </member>
        <member name="M:KS.Reactor.ksReadOnlyTransform2DExtension.ToLocal(KS.Reactor.ksIReadOnlyTransform2D,KS.Reactor.ksVector2)">
            <summary>Converts a point from world space to local space.</summary>
            <param name="worldPosition"></param>
            <returns>Position in local space.</returns>
        </member>
        <member name="T:KS.Reactor.ksRigidBodyModes">
            <summary>Rigid body modes.</summary>
        </member>
        <member name="F:KS.Reactor.ksRigidBodyModes.DEFAULT">
            <summary>Use the default mode.</summary>
        </member>
        <member name="F:KS.Reactor.ksRigidBodyModes.RIGID_BODY_3D">
            <summary>3D rigid body.</summary>
        </member>
        <member name="F:KS.Reactor.ksRigidBodyModes.RIGID_BODY_2D">
            <summary>2D rigid body.</summary>
        </member>
        <member name="T:KS.Reactor.ksForceMode">
            <summary>Determines how forces are applied.</summary>
        </member>
        <member name="F:KS.Reactor.ksForceMode.FORCE">
            <summary>Add a continuous force, using mass.</summary>
        </member>
        <member name="F:KS.Reactor.ksForceMode.IMPULSE">
            <summary>Add an instant impulse, using mass.</summary>
        </member>
        <member name="F:KS.Reactor.ksForceMode.ACCELERATION">
            <summary>Add a continuous acceleration, ignoring mass.</summary>
        </member>
        <member name="F:KS.Reactor.ksForceMode.VELOCITY">
            <summary>Add an instant velocity, ignoring mass.</summary>
        </member>
        <member name="T:KS.Reactor.ksRigidBodyConstraints">
            <summary>Use these flags to constrain motion of rigidbodies. <see cref="P:KS.Reactor.ksIRigidBody.Constraints"/></summary>
        </member>
        <member name="F:KS.Reactor.ksRigidBodyConstraints.FREEZE_POSITION_X">
            <summary>Freeze translations along the X axis.</summary>
        </member>
        <member name="F:KS.Reactor.ksRigidBodyConstraints.FREEZE_POSITION_Y">
            <summary>Freeze translations along the Y axis.</summary>
        </member>
        <member name="F:KS.Reactor.ksRigidBodyConstraints.FREEZE_POSITION_Z">
            <summary>Freeze translations along the Z axis.</summary>
        </member>
        <member name="F:KS.Reactor.ksRigidBodyConstraints.FREEZE_ROTATION_X">
            <summary>Freeze rotations around the X axis.</summary>
        </member>
        <member name="F:KS.Reactor.ksRigidBodyConstraints.FREEZE_ROTATION_Y">
            <summary>Freeze rotations around the Y axis.</summary>
        </member>
        <member name="F:KS.Reactor.ksRigidBodyConstraints.FREEZE_ROTATION_Z">
            <summary>Freeze rotations around the Z axis.</summary>
        </member>
        <member name="F:KS.Reactor.ksRigidBodyConstraints.NONE">
            <summary>Do not freeze any translation or rotation.</summary>
        </member>
        <member name="F:KS.Reactor.ksRigidBodyConstraints.FREEZE_POSITION">
            <summary>Freeze all translations.</summary>
        </member>
        <member name="F:KS.Reactor.ksRigidBodyConstraints.FREEZE_ROTATION">
            <summary>Freeze all rotations.</summary>
        </member>
        <member name="F:KS.Reactor.ksRigidBodyConstraints.FREEZE_ALL">
            <summary>Freeze all translation and rotation.</summary>
        </member>
        <member name="T:KS.Reactor.ksIRigidBody">
            <summary>Interface exposed to player controllers to restrict access to entity physics data.</summary>
        </member>
        <member name="P:KS.Reactor.ksIRigidBody.Velocity">
            <summary>Linear velocity</summary>
        </member>
        <member name="P:KS.Reactor.ksIRigidBody.AngularVelocity">
            <summary>Angular velocity. Component values are degrees per second.</summary>
        </member>
        <member name="P:KS.Reactor.ksIRigidBody.KinematicMovement">
            <summary>
            Amount of movement that will be applied to a kinematic rigid body entity 
            during the next physics simulation step. After the simulation step this 
            value will be reset to <see cref="P:KS.Reactor.ksVector3.Zero"/>
            </summary>
        </member>
        <member name="P:KS.Reactor.ksIRigidBody.KinematicRotation">
            <summary>
            Amount of rotation that will be applied to a kinematic rigid body entity 
            during the next physics simulation step. After the simulation step this 
            value will be reset to <see cref="P:KS.Reactor.ksQuaternion.Identity"/>
            </summary>
        </member>
        <member name="P:KS.Reactor.ksIRigidBody.Mass">
            <summary>Mass of the rigid body.</summary>
        </member>
        <member name="P:KS.Reactor.ksIRigidBody.Drag">
            <summary>Damping.</summary>
        </member>
        <member name="P:KS.Reactor.ksIRigidBody.AngularDrag">
            <summary>Angular damping.</summary>
        </member>
        <member name="P:KS.Reactor.ksIRigidBody.UseGravity">
            <summary>If true, the entity will be affected by the scene gravity.</summary>
        </member>
        <member name="P:KS.Reactor.ksIRigidBody.IsKinematic">
            <summary>
            If true, the entity will not be effected by gravity or other impulses, but may be moved around by setting
            translation and rotation from scripts.
            </summary>
        </member>
        <member name="P:KS.Reactor.ksIRigidBody.Constraints">
            <summary>Controls which degrees of freedom are allowed for the simulation of this rigidbody.</summary>
        </member>
        <member name="P:KS.Reactor.ksIRigidBody.CenterOfMass">
            <summary>The rigidbody's center of mass in local space.</summary>
        </member>
        <member name="M:KS.Reactor.ksIRigidBody.ClearKinematicMotion">
            <summary>Clear the Kinematic movement and rotation values.</summary>
        </member>
        <member name="T:KS.Reactor.ksRigidBody2DConstraints">
            <summary>Use these flags to constrain motion of rigidbodies.</summary>
        </member>
        <member name="T:KS.Reactor.ksIRigidBody2D">
            <summary>Interface exposed to player controllers to restrict access to 2D entity physics data.</summary>
        </member>
        <member name="P:KS.Reactor.ksIRigidBody2D.Velocity">
            <summary>Velocity.</summary>
        </member>
        <member name="P:KS.Reactor.ksIRigidBody2D.AngularVelocity">
            <summary>Angular velocity in degrees per second.</summary>
        </member>
        <member name="P:KS.Reactor.ksIRigidBody2D.KinematicMovement">
            <summary>
            Amount of movement that will be applied to a kinematic rigid body entity 
            during the next physics simulation step. After the simulation step this 
            value will be reset to <see cref="P:KS.Reactor.ksVector2.Zero"/>
            </summary>
        </member>
        <member name="P:KS.Reactor.ksIRigidBody2D.KinematicRotation">
            <summary>
            Amount of rotation in degrees that will be applied to a kinematic rigid body entity 
            during the next physics simulation step. After the simulation step this 
            value will be reset to zero.
            </summary>
        </member>
        <member name="P:KS.Reactor.ksIRigidBody2D.KinematicRotationRadians">
            <summary>
            Amount of rotation in radians that will be applied to a kinematic rigid body entity 
            during the next physics simulation step. After the simulation step this 
            value will be reset to zero.
            </summary>
        </member>
        <member name="P:KS.Reactor.ksIRigidBody2D.Mass">
            <summary>Mass of the rigid body.</summary>
        </member>
        <member name="P:KS.Reactor.ksIRigidBody2D.Drag">
            <summary>Damping.</summary>
        </member>
        <member name="P:KS.Reactor.ksIRigidBody2D.AngularDrag">
            <summary>Angular damping.</summary>
        </member>
        <member name="P:KS.Reactor.ksIRigidBody2D.UseGravity">
            <summary>If true, the entity will be affected by the scene gravity.</summary>
        </member>
        <member name="P:KS.Reactor.ksIRigidBody2D.IsKinematic">
            <summary>
            If true, the entity will not be effected by gravity or other impulses, but may be moved around by setting
            translation and rotation from scripts.
            </summary>
        </member>
        <member name="P:KS.Reactor.ksIRigidBody2D.Constraints">
            <summary>Controls which degrees of freedom are allowed for the simulation of this rigidbody.</summary>
        </member>
        <member name="P:KS.Reactor.ksIRigidBody2D.CenterOfMass">
            <summary>The rigidbody's center of mass in local space.</summary>
        </member>
        <member name="M:KS.Reactor.ksIRigidBody2D.ClearKinematicMotion">
            <summary>Clear the Kinematic movement and rotation values.</summary>
        </member>
        <member name="T:KS.Reactor.ksIWebRequest">
            <summary>Web request interface.</summary>
        </member>
        <member name="P:KS.Reactor.ksIWebRequest.Method">
            <summary>Method.</summary>
        </member>
        <member name="P:KS.Reactor.ksIWebRequest.URL">
            <summary>URL.</summary>
        </member>
        <member name="P:KS.Reactor.ksIWebRequest.JSON">
            <summary>JSON request data.</summary>
        </member>
        <member name="P:KS.Reactor.ksIWebRequest.Headers">
            <summary>Headers.</summary>
        </member>
        <member name="P:KS.Reactor.ksIWebRequest.IsDone">
            <summary>Check if the request has completed.</summary>
        </member>
        <member name="P:KS.Reactor.ksIWebRequest.Response">
            <summary>Response.</summary>
        </member>
        <member name="T:KS.Reactor.ksIWebRequestFactory">
            <summary>Factory for creating a ksIWebRequest.</summary>
            <param name="url">URL.</param>
            <param name="headers">Header collection.</param>
            <param name="method">Request method (default GET).</param>
            <param name="request">JSON request data.</param>
            <param name="stateObject">User defined state tracking object.</param>
            <returns></returns>
        </member>
        <member name="T:KS.Reactor.ksWebResponse">
            <summary>ksIWebRequest response ojbect.</summary>
        </member>
        <member name="T:KS.Reactor.ksWebResponse.Handler">
            <summary>ksIWebRequest response handler</summary>
            <param name="response">Response object.</param>
        </member>
        <member name="P:KS.Reactor.ksWebResponse.StatusCode">
            <summary>HTTP response status code.</summary>
        </member>
        <member name="P:KS.Reactor.ksWebResponse.StatusMessage">
            <summary>HTTP response status message.</summary>
        </member>
        <member name="P:KS.Reactor.ksWebResponse.Headers">
            <summary>HTTP response headers.</summary>
        </member>
        <member name="P:KS.Reactor.ksWebResponse.Error">
            <summary>Error message.</summary>
        </member>
        <member name="P:KS.Reactor.ksWebResponse.Data">
            <summary>Raw stream data.</summary>
        </member>
        <member name="P:KS.Reactor.ksWebResponse.String">
            <summary>Response string.</summary>
        </member>
        <member name="P:KS.Reactor.ksWebResponse.JSON">
            <summary>Response JSON if the response content-type was application/json.</summary>
        </member>
        <member name="P:KS.Reactor.ksWebResponse.AsyncState">
            <summary>Asynchronous object passed into the request.</summary>
        </member>
        <member name="P:KS.Reactor.ksWebResponse.ReplyTime">
            <summary>Amount of time in milliseconds the request took.</summary>
        </member>
        <member name="T:KS.Reactor.ksJSON">
            <summary>
            Represents a JSON value and provides methods for serializing/deserializing JSON. Unlike standard JSON,
            this implementation differentiates between floats and ints and supports NaN, infinity, and negative infinity.
            Ints are stored as 64 bit longs.
            </summary>
            <summary>
            Represents a JSON value and provides methods for serializing/deserializing JSON. Unlike standard JSON,
            this implementation differentiates between floats and ints and supports NaN, infinity, and negative infinity.
            Ints are stored as 64 bit longs.
            </summary>
        </member>
        <member name="T:KS.Reactor.ksJSON.Types">
            <summary>JSON value types.</summary>
        </member>
        <member name="T:KS.Reactor.ksJSON.Literals">
            <summary>JSON literals</summary>
        </member>
        <member name="T:KS.Reactor.ksJSON.ModifyHandler">
            <summary>Handler for on modify events.</summary>
            <param name="json">JSON that was modified.</param>
        </member>
        <member name="E:KS.Reactor.ksJSON.OnModify">
            <summary>Invoked when the json is modified.</summary>
        </member>
        <member name="P:KS.Reactor.ksJSON.IsNull">
            <summary>Is this a null value?</summary>
        </member>
        <member name="P:KS.Reactor.ksJSON.IsString">
            <summary>Is this a string value?</summary>
        </member>
        <member name="P:KS.Reactor.ksJSON.IsFloat">
            <summary>Is this a float value?</summary>
        </member>
        <member name="P:KS.Reactor.ksJSON.IsInt">
            <summary>Is this an int value?</summary>
        </member>
        <member name="P:KS.Reactor.ksJSON.IsBool">
            <summary>Is this a bool value?</summary>
        </member>
        <member name="P:KS.Reactor.ksJSON.IsArray">
            <summary>Is this a JSON array?</summary>
        </member>
        <member name="P:KS.Reactor.ksJSON.IsObject">
            <summary>Is this a JSON object?</summary>
        </member>
        <member name="P:KS.Reactor.ksJSON.IsNumber">
            <summary>Is this a float or int value?</summary>
        </member>
        <member name="P:KS.Reactor.ksJSON.IsContainer">
            <summary>Is this a JSON object or array?</summary>
        </member>
        <member name="P:KS.Reactor.ksJSON.Type">
            <summary>JSON type.</summary>
        </member>
        <member name="P:KS.Reactor.ksJSON.Count">
            <summary>
            Number of fields in the JSON object or number of elements in the JSON array.
            0 if this is neither an object or an array.
            </summary>
        </member>
        <member name="P:KS.Reactor.ksJSON.Array">
            <summary>The value as a JSON array.</summary>
        </member>
        <member name="P:KS.Reactor.ksJSON.Fields">
            <summary>The JSON object fields.</summary>
        </member>
        <member name="P:KS.Reactor.ksJSON.Item(System.Int32)">
            <summary>Gets/sets the value by index in the JSON array.</summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:KS.Reactor.ksJSON.Item(System.String)">
            <summary>Gets/sets a JSON object field.</summary>
            <param name="name">Name of field.</param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksJSON.#ctor">
            <summary>Constructs a null JSON value.</summary>
        </member>
        <member name="M:KS.Reactor.ksJSON.#ctor(KS.Reactor.ksJSON.Types)">
            <summary>Constructor</summary>
            <param name="type">Type of JSON.</param>
        </member>
        <member name="P:KS.Reactor.ksJSON.String">
            <summary>The value as a string. Serializes the JSON if it is a container type.</summary>
        </member>
        <member name="M:KS.Reactor.ksJSON.#ctor(System.String)">
            <summary>
            Constructs a JSON string value. Does not parse the string. Use ksJSON.Parse(string) to parse a JSON string.
            </summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksJSON.op_Implicit(System.String)~KS.Reactor.ksJSON">
            <summary>Implicit conversion from string to ksJSON. Does not parse the string.</summary>
            <param name="value">String value.</param>
        </member>
        <member name="M:KS.Reactor.ksJSON.op_Implicit(KS.Reactor.ksJSON)~System.String">
            <summary>
            Implicit conversion from ksJSON to string. Serializes the JSON if it is a container type.
            </summary>
            <param name="json">JSON value.</param>
        </member>
        <member name="M:KS.Reactor.ksJSON.GetField(System.String,System.String@)">
            <summary>Gets a string field.</summary>
            <param name="name">Name of field to get.</param>
            <param name="field">Set to the field value if the field is found.</param>
            <returns>True if the field is found.</returns>
        </member>
        <member name="P:KS.Reactor.ksJSON.Double">
            <summary>The value as a double.</summary>
        </member>
        <member name="M:KS.Reactor.ksJSON.#ctor(System.Double)">
            <summary>Constructs a JSON double value.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksJSON.op_Implicit(System.Double)~KS.Reactor.ksJSON">
            <summary>Implicit conversion from double to ksJSON.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksJSON.op_Implicit(KS.Reactor.ksJSON)~System.Double">
            <summary>Implicit conversion from ksJSON to double.</summary>
            <param name="json">JSON value.</param>
        </member>
        <member name="M:KS.Reactor.ksJSON.GetField(System.String,System.Double@)">
            <summary>Gets a double field.</summary>
            <param name="name">Name of field to get.</param>
            <param name="field">Set to the field value if the field is found.</param>
            <returns>True if the field is found.</returns>
        </member>
        <member name="P:KS.Reactor.ksJSON.Long">
            <summary>The value as a long.</summary>
        </member>
        <member name="M:KS.Reactor.ksJSON.#ctor(System.Int64)">
            <summary>Constructs a JSON long value.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksJSON.op_Implicit(System.Int64)~KS.Reactor.ksJSON">
            <summary>Implicit conversion from long to ksJSON.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksJSON.op_Implicit(KS.Reactor.ksJSON)~System.Int64">
            <summary>Implicit conversion from ksJSON to long.</summary>
            <param name="json">JSON value.</param>
        </member>
        <member name="M:KS.Reactor.ksJSON.GetField(System.String,System.Int64@)">
            <summary>Gets a long field.</summary>
            <param name="name">Name of field to get.</param>
            <param name="field">Set to the field value if the field is found.</param>
            <returns>True if the field is found.</returns>
        </member>
        <member name="P:KS.Reactor.ksJSON.Bool">
            <summary>The value as a bool.</summary>
        </member>
        <member name="M:KS.Reactor.ksJSON.#ctor(System.Boolean)">
            <summary>Constructs a JSON bool value.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksJSON.op_Implicit(System.Boolean)~KS.Reactor.ksJSON">
            <summary>Implicit conversion from bool to ksJSON.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksJSON.op_Implicit(KS.Reactor.ksJSON)~System.Boolean">
            <summary>Implicit conversion from ksJSON to bool.</summary>
            <param name="json">JSON value.</param>
        </member>
        <member name="M:KS.Reactor.ksJSON.GetField(System.String,System.Boolean@)">
            <summary>Gets a bool field.</summary>
            <param name="name">Name of field to get.</param>
            <param name="field">Set to the field value if the field is found.</param>
            <returns>True if the field is found.</returns>
        </member>
        <member name="P:KS.Reactor.ksJSON.Int">
            <summary>The value as a int.</summary>
        </member>
        <member name="M:KS.Reactor.ksJSON.#ctor(System.Int32)">
            <summary>Constructs a JSON int value.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksJSON.op_Implicit(System.Int32)~KS.Reactor.ksJSON">
            <summary>Implicit conversion from int to ksJSON.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksJSON.op_Implicit(KS.Reactor.ksJSON)~System.Int32">
            <summary>Implicit conversion from ksJSON to int.</summary>
            <param name="json">JSON value.</param>
        </member>
        <member name="M:KS.Reactor.ksJSON.GetField(System.String,System.Int32@)">
            <summary>Gets an int field.</summary>
            <param name="name">Name of field to get.</param>
            <param name="field">Set to the field value if the field is found.</param>
            <returns>True if the field is found.</returns>
        </member>
        <member name="P:KS.Reactor.ksJSON.UInt">
            <summary>The value as a uint.</summary>
        </member>
        <member name="M:KS.Reactor.ksJSON.#ctor(System.UInt32)">
            <summary>Constructs a JSON uint value.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksJSON.op_Implicit(System.UInt32)~KS.Reactor.ksJSON">
            <summary>Implicit conversion from uint to ksJSON.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksJSON.op_Implicit(KS.Reactor.ksJSON)~System.UInt32">
            <summary>Implicit conversion from ksJSON to uint.</summary>
            <param name="json">JSON value.</param>
        </member>
        <member name="M:KS.Reactor.ksJSON.GetField(System.String,System.UInt32@)">
            <summary>Gets a uint field.</summary>
            <param name="name">Name of field to get.</param>
            <param name="field">Set to the field value if the field is found.</param>
            <returns>True if the field is found.</returns>
        </member>
        <member name="P:KS.Reactor.ksJSON.Float">
            <summary>The value as a float.</summary>
        </member>
        <member name="M:KS.Reactor.ksJSON.#ctor(System.Single)">
            <summary>Constructs a JSON float value.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksJSON.op_Implicit(System.Single)~KS.Reactor.ksJSON">
            <summary>Implicit conversion from float to ksJSON.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksJSON.op_Implicit(KS.Reactor.ksJSON)~System.Single">
            <summary>Implicit conversion from ksJSON to float.</summary>
            <param name="json">JSON value.</param>
        </member>
        <member name="M:KS.Reactor.ksJSON.GetField(System.String,System.Single@)">
            <summary>Gets a float field.</summary>
            <param name="name">Name of field to get.</param>
            <param name="field">Set to the field value if the field is found.</param>
            <returns>True if the field is found.</returns>
        </member>
        <member name="P:KS.Reactor.ksJSON.Vector2">
            <summary>The array as a ksVector2.</summary>
        </member>
        <member name="M:KS.Reactor.ksJSON.#ctor(KS.Reactor.ksVector2)">
            <summary>Constructs a JSON array from a ksVector2.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksJSON.op_Implicit(KS.Reactor.ksVector2)~KS.Reactor.ksJSON">
            <summary>Implicit conversion from ksVector2 to ksJSON.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksJSON.op_Implicit(KS.Reactor.ksJSON)~KS.Reactor.ksVector2">
            <summary>Implicit conversion from ksJSON to ksVector2.</summary>
            <param name="json">JSON value.</param>
        </member>
        <member name="M:KS.Reactor.ksJSON.GetField(System.String,KS.Reactor.ksVector2@)">
            <summary>Gets a ksVector2 field.</summary>
            <param name="name">Name of field to get.</param>
            <param name="field">Set to the field value if the field is found.</param>
            <returns>True if the field is found.</returns>
        </member>
        <member name="P:KS.Reactor.ksJSON.Vector3">
            <summary>The array as a ksVector3</summary>
        </member>
        <member name="M:KS.Reactor.ksJSON.#ctor(KS.Reactor.ksVector3)">
            <summary>Constructs a JSON array from a ksVector3.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksJSON.op_Implicit(KS.Reactor.ksVector3)~KS.Reactor.ksJSON">
            <summary>Implicit conversion from ksVector3 to ksJSON.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksJSON.op_Implicit(KS.Reactor.ksJSON)~KS.Reactor.ksVector3">
            <summary>Implicit conversion from ksJSON to ksVector3.</summary>
            <param name="json">JSON value.</param>
        </member>
        <member name="M:KS.Reactor.ksJSON.GetField(System.String,KS.Reactor.ksVector3@)">
            <summary>Gets a ksVector3 field.</summary>
            <param name="name">Name of field to get.</param>
            <param name="field">Set to the field value if the field is found.</param>
            <returns>True if the field is found.</returns>
        </member>
        <member name="P:KS.Reactor.ksJSON.Quaternion">
            <summary>The array as a ksQuaternion.</summary>
        </member>
        <member name="M:KS.Reactor.ksJSON.#ctor(KS.Reactor.ksQuaternion)">
            <summary>Constructs a JSON array from a ksQuaternion.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksJSON.op_Implicit(KS.Reactor.ksQuaternion)~KS.Reactor.ksJSON">
            <summary>Implicit conversion from ksQuaternion to ksJSON.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksJSON.op_Implicit(KS.Reactor.ksJSON)~KS.Reactor.ksQuaternion">
            <summary>Implicit conversion from ksJSON to ksQuaternion.</summary>
            <param name="json">JSON value.</param>
        </member>
        <member name="M:KS.Reactor.ksJSON.GetField(System.String,KS.Reactor.ksQuaternion@)">
            <summary>Gets a ksQuaternion field.</summary>
            <param name="name">Name of field to get.</param>
            <param name="field">Set to the field value if the field is found.</param>
            <returns>True if the field is found.</returns>
        </member>
        <member name="P:KS.Reactor.ksJSON.Color">
            <summary>The array as a ksColor.</summary>
        </member>
        <member name="M:KS.Reactor.ksJSON.#ctor(KS.Reactor.ksColor)">
            <summary>Constructs a JSON array from a ksColor.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksJSON.op_Implicit(KS.Reactor.ksColor)~KS.Reactor.ksJSON">
            <summary>Implicit conversion from ksColor to ksJSON.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksJSON.op_Implicit(KS.Reactor.ksJSON)~KS.Reactor.ksColor">
            <summary>Implicit conversion from ksJSON to ksColor.</summary>
            <param name="json">JSON value.</param>
        </member>
        <member name="M:KS.Reactor.ksJSON.GetField(System.String,KS.Reactor.ksColor@)">
            <summary>Gets a ksColor field.</summary>
            <param name="name">Name of field to get.</param>
            <param name="field">Set to the field value if the field is found.</param>
            <returns>True if the field is found.</returns>
        </member>
        <member name="M:KS.Reactor.ksJSON.Add(KS.Reactor.ksJSON)">
            <summary>Appends to the JSON array.</summary>
            <param name="value">Value to add to the array.</param>
        </member>
        <member name="M:KS.Reactor.ksJSON.Remove(KS.Reactor.ksJSON)">
            <summary>Removes the first occurrence of a value from the JSON array.</summary>
            <param name="value">Value to remove from the JSON array.</param>
            <returns>True if the value was found and removed from the JSON array.</returns>
        </member>
        <member name="M:KS.Reactor.ksJSON.RemoveAt(System.Int32)">
            <summary>Removes the element at the specified index from the JSON array.</summary>
            <param name="index">Index to remove element from.</param>
        </member>
        <member name="M:KS.Reactor.ksJSON.SetField(System.String,KS.Reactor.ksJSON)">
            <summary>Sets a field in the JSON object.</summary>
            <param name="name">Name of field.</param>
            <param name="value">Value to set.</param>
        </member>
        <member name="M:KS.Reactor.ksJSON.GetField(System.String)">
            <summary>
            Gets a field from the JSON object.
            Throws an exception if the field isn't found or this isn't a JSON object.
            </summary>
            <param name="name">Name of field.</param>
            <returns>Field value.</returns>
        </member>
        <member name="M:KS.Reactor.ksJSON.GetField(System.String,KS.Reactor.ksJSON)">
            <summary>Gets a field from the JSON object.</summary>
            <param name="name">Name of field.</param>
            <param name="defaultValue">Default value to return if the field isn't found.</param>
            <returns>Field value, or defaultValue if the field isn't found.</returns>
        </member>
        <member name="M:KS.Reactor.ksJSON.GetField(System.String,KS.Reactor.ksJSON@)">
            <summary>Gets a field from the JSON object.</summary>
            <param name="name">Name of field.</param>
            <param name="field">Set to field value if the field is found.</param>
            <returns>True if the field was found.</returns>
        </member>
        <member name="M:KS.Reactor.ksJSON.GetField``1(System.String,``0@,KS.Reactor.ksJSON.Getter{``0})">
            <summary>Gets a field of type T from the JSON object.</summary>
            <typeparam name="T"></typeparam>
            <param name="name">Name of field.</param>
            <param name="field">Set to field value if the field is found.</param>
            <param name="getter">Getter for converting the ksJSON field to type T.</param>
            <returns>True if the field was found.</returns>
        </member>
        <member name="M:KS.Reactor.ksJSON.RemoveField(System.String)">
            <summary>Removes a field from the JSON object.</summary>
            <param name="name">Name of field.</param>
            <returns>True if the field was found.</returns>
        </member>
        <member name="M:KS.Reactor.ksJSON.HasField(System.String)">
            <summary>Checks if a field is present in the JSON object.</summary>
            <param name="name">Name of field.</param>
            <returns>True if this is a json object with the given field.</returns>
        </member>
        <member name="M:KS.Reactor.ksJSON.HasFields(System.String[])">
            <summary>Checks if fields are present in the JSON object.</summary>
            <param name="names">Names of fields to check for.</param>
            <returns>True if this is a json object with all the given fields.</returns>
        </member>
        <member name="M:KS.Reactor.ksJSON.Clear">
            <summary>Clears all fields, list entries and values, and sets the JSON type to null.</summary>
        </member>
        <member name="M:KS.Reactor.ksJSON.ToString">
            <summary>Convert JSON to string.</summary>
            <returns>JSON value. Serializes the JSON if it is a container type.</returns>
        </member>
        <member name="M:KS.Reactor.ksJSON.Parse(System.String)">
            <summary>Parses a JSON string. Throws an exception if the JSON string is invalid.</summary>
            <param name="str">String to parse.</param>
            <returns>ksJSON constructed from parsing JSON string.</returns>
        </member>
        <member name="M:KS.Reactor.ksJSON.Print(System.Boolean,System.Boolean)">
            <summary>Serializes JSON to a string.</summary>
            <param name="pretty">If true, will print with indentation and multiple lines.</param>
            <param name="allowNaN">
            If true, will serialize NaN, infinity, and negative infinity to non-string literals that aren't part of
            the JSON standard. Otherwise these values are serialized as null.</param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksJSON.Children">
            <summary>Iterates the children of this JSON. Does nothing if this is not an array or object.</summary>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksJSON.Descendants">
            <summary>
            Iterates all descendants of this JSON object. Does nothing if this is not an array or object. Logs warnings
            if circular references are detected.
            </summary>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksJSON.Descendants(System.Collections.Generic.HashSet{KS.Reactor.ksJSON})">
            <summary>
            Iterates all descendants of this JSON object. Does nothing if this is not an array or object. Logs warnings
            if circular references are detected.
            </summary>
            <param name="parents">Parents of this object. Used for detecting circular references.</param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksJSON.Equals(KS.Reactor.ksJSON)">
            <summary>Checks if the contents of a ksJSON are the same as another.</summary>
            <param name="other"></param>
            <returns>True if all keys and values are equals.</returns>
        </member>
        <member name="M:KS.Reactor.ksJSON.InvokeOnModify(KS.Reactor.ksJSON)">
            <summary>Invokes the on modify event.</summary>
            <param name="json"></param>
        </member>
        <member name="M:KS.Reactor.ksJSON.AddModifyHandlerToChildren">
            <summary>
            If this object has any modify handlers, adds a modify handler to the children of this object to call this
            object's handlers.
            </summary>
        </member>
        <member name="M:KS.Reactor.ksJSON.RemoveModifyHandlerFromChildren">
            <summary>
            If this object has any modify handlers, removes the modify handler from the children of this object to call
            this object's handlers.
            </summary>
        </member>
        <member name="M:KS.Reactor.ksJSON.op_Implicit(UnityEngine.Vector2)~KS.Reactor.ksJSON">
            <summary>Implicit conversion from <see cref="P:KS.Reactor.ksJSON.Vector2"/> to <see cref="T:KS.Reactor.ksJSON"/>.</summary>
            <param name="value"></param>
            <returns>Json</returns>
        </member>
        <member name="M:KS.Reactor.ksJSON.op_Implicit(KS.Reactor.ksJSON)~UnityEngine.Vector2">
            <summary>Implicit conversion from <see cref="T:KS.Reactor.ksJSON"/> to <see cref="P:KS.Reactor.ksJSON.Vector2"/>.</summary>
            <param name="json"></param>
            <returns>Vector2 value from json</returns>
        </member>
        <member name="M:KS.Reactor.ksJSON.op_Implicit(UnityEngine.Vector3)~KS.Reactor.ksJSON">
            <summary>Implicit conversion from <see cref="P:KS.Reactor.ksJSON.Vector3"/> to <see cref="T:KS.Reactor.ksJSON"/>.</summary>
            <param name="value"></param>
            <returns>Json</returns>
        </member>
        <member name="M:KS.Reactor.ksJSON.op_Implicit(KS.Reactor.ksJSON)~UnityEngine.Vector3">
            <summary>Implicit conversion from <see cref="T:KS.Reactor.ksJSON"/>to <see cref="P:KS.Reactor.ksJSON.Vector3"/>.</summary>
            <param name="json"></param>
            <returns>Vector3 value from json</returns>
        </member>
        <member name="M:KS.Reactor.ksJSON.op_Implicit(UnityEngine.Quaternion)~KS.Reactor.ksJSON">
            <summary>Implicit conversion from <see cref="P:KS.Reactor.ksJSON.Quaternion"/> to <see cref="T:KS.Reactor.ksJSON"/>.</summary>
            <param name="value"></param>
            <returns>Json</returns>
        </member>
        <member name="M:KS.Reactor.ksJSON.op_Implicit(KS.Reactor.ksJSON)~UnityEngine.Quaternion">
            <summary>Implicit conversion from <see cref="T:KS.Reactor.ksJSON"/> to <see cref="P:KS.Reactor.ksJSON.Quaternion"/>.</summary>
            <param name="json"></param>
            <returns>Quaternion value from json</returns>
        </member>
        <member name="M:KS.Reactor.ksJSON.op_Implicit(UnityEngine.Color)~KS.Reactor.ksJSON">
            <summary>Implicit conversion from <see cref="P:KS.Reactor.ksJSON.Color"/> to <see cref="T:KS.Reactor.ksJSON"/>.</summary>
            <param name="value"></param>
            <returns>Json</returns>
        </member>
        <member name="M:KS.Reactor.ksJSON.op_Implicit(KS.Reactor.ksJSON)~UnityEngine.Color">
            <summary>Implicit conversion from <see cref="T:KS.Reactor.ksJSON"/> to <see cref="P:KS.Reactor.ksJSON.Color"/>.</summary>
            <param name="json"></param>
            <returns>Color value from json</returns>
        </member>
        <member name="T:KS.Reactor.ksLinkedList`1">
            <summary>A linked list that can be modified while being iterated.</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:KS.Reactor.ksLinkedList`1.Count">
            <summary>Number of values in the list.</summary>
        </member>
        <member name="P:KS.Reactor.ksLinkedList`1.First">
            <summary>The first value in the list, or default(T) if the list is empty.</summary>
        </member>
        <member name="P:KS.Reactor.ksLinkedList`1.Last">
            <summary>The last value in the list, or default(T) if the list is empty.</summary>
        </member>
        <member name="P:KS.Reactor.ksLinkedList`1.Current">
            <summary>
            The current value being iterated, or default(T) if the list is not being iterated. Throws a
            MemberAccessException if you try to set it while not iterating the list.
            </summary>
        </member>
        <member name="P:KS.Reactor.ksLinkedList`1.Item(System.Int32)">
            <summary>Gets/Sets the value at an index.</summary>
        </member>
        <member name="P:KS.Reactor.ksLinkedList`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
            <summary>Indicates if this list is read only. Returns false.</summary>
        </member>
        <member name="P:KS.Reactor.ksLinkedList`1.System#Collections#IList#IsReadOnly">
            <summary>Indicates if this list is read only. Returns false.</summary>
        </member>
        <member name="P:KS.Reactor.ksLinkedList`1.System#Collections#IList#IsFixedSize">
            <summary>Indicates if this list is a fixed size. Returns false.</summary>
        </member>
        <member name="P:KS.Reactor.ksLinkedList`1.System#Collections#ICollection#SyncRoot">
            <summary>Object used to synchronize access to the collection. Returns this.</summary>
        </member>
        <member name="P:KS.Reactor.ksLinkedList`1.System#Collections#ICollection#IsSynchronized">
            <summary>Is this collection thread safe? Returns false.</summary>
        </member>
        <member name="P:KS.Reactor.ksLinkedList`1.System#Collections#IList#Item(System.Int32)">
            <summary>Gets/Sets the value at an index.</summary>
        </member>
        <member name="M:KS.Reactor.ksLinkedList`1.#ctor">
            <summary>Constructor</summary>
        </member>
        <member name="M:KS.Reactor.ksLinkedList`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>Copy constructor</summary>
            <param name="values">Values to initialize the list with.</param>
        </member>
        <member name="M:KS.Reactor.ksLinkedList`1.Add(`0)">
            <summary>Adds a value to the end of the list.</summary>
            <param name="value">Value to add.</param>
        </member>
        <member name="M:KS.Reactor.ksLinkedList`1.Insert(System.Int32,`0)">
            <summary>Inserts a value at a specified index.</summary>
            <param name="index">Index to insert value at.</param>
            <param name="value">Value to insert.</param>
        </member>
        <member name="M:KS.Reactor.ksLinkedList`1.InsertPrevious(`0)">
            <summary>
            Inserts a value before the current iterator position, or at the start of the list if not iterating.
            </summary>
            <param name="value">Value to insert.</param>
        </member>
        <member name="M:KS.Reactor.ksLinkedList`1.InsertNext(`0)">
            <summary>
            Inserts a value after the current iterator position, or at the end of the list if not iterating.
            </summary>
            <param name="value">Value to insert.</param>
        </member>
        <member name="M:KS.Reactor.ksLinkedList`1.RemoveCurrent">
            <summary>
            Removes the value at the current iterator position. Does nothing if not iterating, or if the current
            iterator position was already removed.
            </summary>
            <returns>True if a value was removed.</returns>
        </member>
        <member name="M:KS.Reactor.ksLinkedList`1.Remove(`0)">
            <summary>
            Removes the first occurrence of a value from the list. If the list is currently iterating and the iterated
            value matches the given value, will remove the iterated node instead of the first occurrence.
            </summary>
            <param name="value">Value to remove.</param>
            <returns>True if the value was found and removed.</returns>
        </member>
        <member name="M:KS.Reactor.ksLinkedList`1.RemoveAt(System.Int32)">
            <summary>Removes the value at a specified index.</summary>
            <param name="index">Index of value to remove.</param>
        </member>
        <member name="M:KS.Reactor.ksLinkedList`1.Clear">
            <summary>Removes everything from the list.</summary>
        </member>
        <member name="M:KS.Reactor.ksLinkedList`1.IndexOf(`0)">
            <summary>Finds the index of the first occurrence of a value.</summary>
            <param name="value">Value to search for.</param>
            <returns>Index of the value, or -1 if the value was not found.</returns>
        </member>
        <member name="M:KS.Reactor.ksLinkedList`1.Contains(`0)">
            <summary>Checks if a value is in the list.</summary>
            <param name="value">Value to check for.</param>
            <returns>True if the value is in the list.</returns>
        </member>
        <member name="M:KS.Reactor.ksLinkedList`1.CopyTo(`0[],System.Int32)">
            <summary>Copies the contents of the list to an array.</summary>
            <param name="array">Array to copy to.</param>
            <param name="arrayIndex">Array index to start copying to.</param>
        </member>
        <member name="M:KS.Reactor.ksLinkedList`1.Next">
            <summary>
            Advances <see cref="P:KS.Reactor.ksLinkedList`1.Current"/> to the next index. If not iterating, begins iterating and 
            <see cref="P:KS.Reactor.ksLinkedList`1.Current"/> will point to the first element. If the end of the list is reached, returns false and
            stops iterating.
            </summary>
            <returns>
            True if <see cref="P:KS.Reactor.ksLinkedList`1.Current"/> advanced to the next element. False if the end of the list was reached.
            </returns>
        </member>
        <member name="M:KS.Reactor.ksLinkedList`1.ResetCurrent">
            <summary>
            Sets the current iterator pointer to null to stop iterating with <see cref="M:KS.Reactor.ksLinkedList`1.Next"/>. This will not stop
            <see cref="M:KS.Reactor.ksLinkedList`1.GetEnumerator"/> iteration.
            </summary>
        </member>
        <member name="M:KS.Reactor.ksLinkedList`1.GetEnumerator">
            <summary>Gets the enumerator for the list.</summary>
            <returns>Enumerator for the list.</returns>
        </member>
        <member name="M:KS.Reactor.ksLinkedList`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Gets the enumerator for the list.</summary>
            <returns>Enumerator for the list.</returns>
        </member>
        <member name="M:KS.Reactor.ksLinkedList`1.ValidateIndex(System.Int32,System.Int32)">
            <summary>Throws an exception if the index is not valid.</summary>
            <param name="index">Index to validate.</param>
            <param name="count">Count to test index against.</param>
        </member>
        <member name="M:KS.Reactor.ksLinkedList`1.ValidateIndex(System.Int32)">
            <summary>Throws an exception if the index is not valid.</summary>
            <param name="index">Index to validate.</param>
        </member>
        <member name="M:KS.Reactor.ksLinkedList`1.GetNodeAt(System.Int32)">
            <summary>Gets the node at an index.</summary>
            <param name="index">Index of node to get.</param>
            <returns>Node at the index.</returns>
        </member>
        <member name="M:KS.Reactor.ksLinkedList`1.Remove(KS.Reactor.ksLinkedList{`0}.Node,KS.Reactor.ksLinkedList{`0}.Node)">
            <summary>Removes a node from the list.</summary>
            <param name="previous">
            Previous node before the node to remove. Null if the node to remove is the first in the list.
            </param>
            <param name="node">Node to remove.</param>
        </member>
        <member name="M:KS.Reactor.ksLinkedList`1.System#Collections#IList#Add(System.Object)">
            <summary>Adds a value to the end of the list.</summary>
            <param name="value">Value to add.</param>
            <returns>Index the value was added at.</returns>
        </member>
        <member name="M:KS.Reactor.ksLinkedList`1.System#Collections#IList#Contains(System.Object)">
            <summary>Checks if a value is in the list.</summary>
            <param name="value">Value to check for.</param>
            <returns>True if the value is in the list.</returns>
        </member>
        <member name="M:KS.Reactor.ksLinkedList`1.System#Collections#IList#IndexOf(System.Object)">
            <summary>Finds the index of the first occurrence of a value.</summary>
            <param name="value">Value to search for.</param>
            <returns>Index of the value, or -1 if the value was not found.</returns>
        </member>
        <member name="M:KS.Reactor.ksLinkedList`1.System#Collections#IList#Insert(System.Int32,System.Object)">
            <summary>Inserts a value at a specified index.</summary>
            <param name="index">Index to insert value at.</param>
            <param name="value">Value to insert.</param>
        </member>
        <member name="M:KS.Reactor.ksLinkedList`1.System#Collections#IList#Remove(System.Object)">
            <summary>
            Removes the first occurrence of a value from the list. If the list is currently iterating and the iterated
            value matches the given value, will remove the iterated node instead of the first occurrence.
            </summary>
            <param name="value">Value to remove.</param>
        </member>
        <member name="M:KS.Reactor.ksLinkedList`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>Copies the contents of the list to an array.</summary>
            <param name="array">Array to copy to.</param>
            <param name="arrayIndex">Array index to start copying to.</param>
        </member>
        <member name="T:KS.Reactor.ksLinkedList`1.Node">
            <summary>Linked list node.</summary>
        </member>
        <member name="M:KS.Reactor.ksLinkedList`1.Node.#ctor(`0)">
            <summary>Constructor.</summary>
            <param name="value"></param>
        </member>
        <member name="T:KS.Reactor.ksLog">
            <summary>
            Static logger class. Log messages have a level and a channel string that can be used to filter log messages.
            Channels can have parent channels. Any message a channel receives will also be sent to all of it's parent 
            channels. Channels are seperated by ".", with children channel following parents. All channels are children of
            the root channel. If a non-string object is passed as channel parameter T to a log function, the channel string
            will be [namespace.classname].
            Example:
             ksLog.Info("X.Y", "This message will be received by channels 'X.Y', 'X', and 'Root');
            </summary>
            <summary>
            Static logger class. Log messages have a level and a channel string that can be used to filter log messages.
            Channels can have parent channels. Any message a channel receives will also be sent to all of it's parent channels.
            Channels are seperated by ".", with children channel following parents. All channels are children of the root channel.
            If a non-string object is passed as channel parameter T to a log function, the channel string will be [namespace.classname].
            Example:
            ksLog.Info("X.Y", "This message will be received by channels 'X.Y', 'X', and 'Root');
            </summary>
        </member>
        <member name="T:KS.Reactor.ksLog.LogHandler">
            <summary>Delegate for logging a message.</summary>
            <param name="level">Level of the message.</param>
            <param name="channel">Channel the message was sent to.</param>
            <param name="message">Message to log. May be null if exception is provided.</param>
            <param name="exception">Exception to log. May be null if message is provided.</param>
            <param name="context">Object related to this message.</param>
        </member>
        <member name="T:KS.Reactor.ksLog.Level">
            <summary>Log levels.</summary>
        </member>
        <member name="T:KS.Reactor.ksLog.Logger">
            <summary>Associates a handler delegate with a level mask.</summary>
        </member>
        <member name="F:KS.Reactor.ksLog.ROOT_CHANNEL">
            <summary>Name of the root channel.</summary>
        </member>
        <member name="F:KS.Reactor.ksLog.m_loggers">
            <summary>Maps channels to lists of loggers.</summary>
        </member>
        <member name="M:KS.Reactor.ksLog.#ctor">
            <summary>Private constructor.</summary>
        </member>
        <member name="M:KS.Reactor.ksLog.Debug``1(``0,System.String)">
            <summary>Logs a debug message.</summary>
            <typeparam name="T"></typeparam>
            <param name="channel">Channel to log to.</param>
            <param name="message">Message to log.</param>
        </member>
        <member name="M:KS.Reactor.ksLog.Debug(System.String)">
            <summary>Logs a debug message to the root channel.</summary>
            <param name="message">Message to log.</param>
        </member>
        <member name="M:KS.Reactor.ksLog.Debug``1(``0,System.String,System.Object)">
            <summary>Logs a debug message.</summary>
            <typeparam name="T"></typeparam>
            <param name="channel">Channel to log to.</param>
            <param name="message">Message to log.</param>
            <param name="context">Object related to this message.</param>
        </member>
        <member name="M:KS.Reactor.ksLog.Debug(System.String,System.Object)">
            <summary>Logs a debug message to the root channel.</summary>
            <param name="message">Message to log.</param>
            <param name="context">Object related to this message.</param>
        </member>
        <member name="M:KS.Reactor.ksLog.Info``1(``0,System.String)">
            <summary>Logs an info message.</summary>
            <typeparam name="T"></typeparam>
            <param name="channel">Channel to log to.</param>
            <param name="message">Message to log.</param>
        </member>
        <member name="M:KS.Reactor.ksLog.Info(System.String)">
            <summary>Logs an info message to the root channel.</summary>
            <param name="message">Message to log.</param>
        </member>
        <member name="M:KS.Reactor.ksLog.Info``1(``0,System.String,System.Object)">
            <summary>Logs an info message.</summary>
            <typeparam name="T"></typeparam>
            <param name="channel">Channel to log to.</param>
            <param name="message">Message to log.</param>
            <param name="context">Object related to this message.</param>
        </member>
        <member name="M:KS.Reactor.ksLog.Info(System.String,System.Object)">
            <summary>Logs an info message to the root channel.</summary>
            <param name="message">Message to log.</param>
            <param name="context">Object related to this message.</param>
        </member>
        <member name="M:KS.Reactor.ksLog.Warning``1(``0,System.String)">
            <summary>Logs a warning.</summary>
            <typeparam name="T"></typeparam>
            <param name="channel">Channel to log to.</param>
            <param name="message">Message to log.</param>
        </member>
        <member name="M:KS.Reactor.ksLog.Warning(System.String)">
            <summary>Logs a warning to the root channel.</summary>
            <param name="message">Message to log.</param>
        </member>
        <member name="M:KS.Reactor.ksLog.Warning``1(``0,System.String,System.Object)">
            <summary>Logs a warning.</summary>
            <typeparam name="T"></typeparam>
            <param name="channel">Channel to log to.</param>
            <param name="message">Message to log.</param>
            <param name="context">Object related to this message.</param>
        </member>
        <member name="M:KS.Reactor.ksLog.Warning(System.String,System.Object)">
            <summary>Logs a warning to the root channel.</summary>
            <param name="message">Message to log.</param>
            <param name="context">Object related to this message.</param>
        </member>
        <member name="M:KS.Reactor.ksLog.Error``1(``0,System.String)">
            <summary>Logs an error.</summary>
            <typeparam name="T"></typeparam>
            <param name="channel">Channel to log to.</param>
            <param name="message">Message to log.</param>
        </member>
        <member name="M:KS.Reactor.ksLog.Error``1(``0,System.String,System.Exception)">
            <summary>Logs an error.</summary>
            <typeparam name="T"></typeparam>
            <param name="channel">Channel to log to.</param>
            <param name="message">Message to log.</param>
            <param name="exception">Exception to log.</param>
        </member>
        <member name="M:KS.Reactor.ksLog.Error(System.String)">
            <summary>Logs an error to the root channel.</summary>
            <param name="message">Message to log.</param>
        </member>
        <member name="M:KS.Reactor.ksLog.Error(System.String,System.Exception)">
            <summary>Logs an error to the root channel.</summary>
            <param name="message">Message to log.</param>
            <param name="exception">Exception to log.</param>
        </member>
        <member name="M:KS.Reactor.ksLog.Error``1(``0,System.String,System.Object)">
            <summary>Logs an error.</summary>
            <typeparam name="T"></typeparam>
            <param name="channel">Channel to log to.</param>
            <param name="message">Message to log.</param>
            <param name="context">Object related to this message.</param>
        </member>
        <member name="M:KS.Reactor.ksLog.Error``1(``0,System.String,System.Exception,System.Object)">
            <summary>Logs an error.</summary>
            <typeparam name="T"></typeparam>
            <param name="channel">Channel to log to.</param>
            <param name="message">Message to log.</param>
            <param name="exception">Exception to log.</param>
            <param name="context">Object related to this message.</param>
        </member>
        <member name="M:KS.Reactor.ksLog.Error(System.String,System.Object)">
            <summary>Logs an error to the root channel.</summary>
            <param name="message">Message to log.</param>
            <param name="context">Object related to this message.</param>
        </member>
        <member name="M:KS.Reactor.ksLog.Error(System.String,System.Exception,System.Object)">
            <summary>Logs an error to the root channel.</summary>
            <param name="message">Message to log.</param>
            <param name="exception">Exception to log.</param>
            <param name="context">Object related to this message.</param>
        </member>
        <member name="M:KS.Reactor.ksLog.LogException``1(``0,System.Exception)">
            <summary>Logs an exception.</summary>
            <typeparam name="T"></typeparam>
            <param name="channel">Channel to log to.</param>
            <param name="exception">Exception to log.</param>
        </member>
        <member name="M:KS.Reactor.ksLog.LogException(System.Exception)">
            <summary>Logs an exception to the root channel.</summary>
            <param name="exception">Exception to log.</param>
        </member>
        <member name="M:KS.Reactor.ksLog.LogException``1(``0,System.Exception,System.Object)">
            <summary>Logs an exception.</summary>
            <typeparam name="T"></typeparam>
            <param name="channel">Channel to log to.</param>
            <param name="exception">Exception to log.</param>
            <param name="context">Object related to this message.</param>
        </member>
        <member name="M:KS.Reactor.ksLog.LogException(System.Exception,System.Object)">
            <summary>Logs an exception to the root channel.</summary>
            <param name="exception">Exception to log.</param>
            <param name="context">Object related to this message.</param>
        </member>
        <member name="M:KS.Reactor.ksLog.Fatal``1(``0,System.String,System.Exception)">
            <summary>Logs a fatal error.</summary>
            <typeparam name="T"></typeparam>
            <param name="channel">Channel to log to.</param>
            <param name="message">Message to log.</param>
            <param name="exception">Exception to log.</param>
        </member>
        <member name="M:KS.Reactor.ksLog.Fatal(System.String,System.Exception)">
            <summary>Logs a fatal error to the root channel.</summary>
            <param name="message">Message to log.</param>
            <param name="exception">Exception to log.</param>
        </member>
        <member name="M:KS.Reactor.ksLog.Fatal``1(``0,System.String,System.Object,System.Exception)">
            <summary>Logs a fatal error.</summary>
            <typeparam name="T"></typeparam>
            <param name="channel">Channel to log to.</param>
            <param name="message">Message to log.</param>
            <param name="context">Object related to this message.</param>
            <param name="exception">Exception to log.</param>
        </member>
        <member name="M:KS.Reactor.ksLog.Fatal(System.String,System.Object,System.Exception)">
            <summary>Logs a fatal error to the root channel.</summary>
            <param name="message">Message to log.</param>
            <param name="context">Object related to this message.</param>
            <param name="exception">Exception to log.</param>
        </member>
        <member name="M:KS.Reactor.ksLog.FatalException``1(``0,System.Exception)">
            <summary>Logs a fatal exception.</summary>
            <typeparam name="T"></typeparam>
            <param name="channel">Channel to log to.</param>
            <param name="exception">Exception to log.</param>
        </member>
        <member name="M:KS.Reactor.ksLog.FatalException(System.Exception)">
            <summary>Logs a fatal exception to the root channel.</summary>
            <param name="exception">Exception to log.</param>
        </member>
        <member name="M:KS.Reactor.ksLog.FatalException``1(``0,System.Exception,System.Object)">
            <summary>Logs a fatal exception.</summary>
            <typeparam name="T"></typeparam>
            <param name="channel">Channel to log to.</param>
            <param name="exception">Exception to log.</param>
            <param name="context">Object related to this message.</param>
        </member>
        <member name="M:KS.Reactor.ksLog.FatalException(System.Exception,System.Object)">
            <summary>Logs a fatal exception to the root channel.</summary>
            <param name="exception">Exception to log.</param>
            <param name="context">Object related to this message.</param>
        </member>
        <member name="M:KS.Reactor.ksLog.RegisterHandler``1(``0,KS.Reactor.ksLog.LogHandler,KS.Reactor.ksLog.Level,System.Boolean)">
            <summary>Registers a log handler.</summary>
            <typeparam name="T"></typeparam>
            <param name="channel">Channel to register to.</param>
            <param name="handler">Handler to register.</param>
            <param name="levelMask">Filters messages by level.</param>
            <param name="allowBubbling">
            If false, logs handled by this handler will not be processed by handlers on parent channels.
            </param>
        </member>
        <member name="M:KS.Reactor.ksLog.RegisterHandler(KS.Reactor.ksLog.LogHandler,KS.Reactor.ksLog.Level,System.Boolean)">
            <summary>Registers a log handler to the root channel.</summary>
            <param name="handler">Handler to register.</param>
            <param name="levelMask">Filters messages by level.</param>
            <param name="allowBubbling">
            If false, logs handled by this handler will not be processed by handlers on parent channels.
            </param>
        </member>
        <member name="M:KS.Reactor.ksLog.UnregisterHandler``1(``0,KS.Reactor.ksLog.LogHandler)">
            <summary>Unregisters a log handler.</summary>
            <typeparam name="T"></typeparam>
            <param name="channel">Channel to unregister from.</param>
            <param name="handler">Handler to unregister.</param>
            <returns>True if the handler was found and removed.</returns>
        </member>
        <member name="M:KS.Reactor.ksLog.UnregisterHandler(KS.Reactor.ksLog.LogHandler)">
            <summary>Unregisters a log handler from the root channel.</summary>
            <param name="handler">Handler to unregister.</param>
            <returns>True if the handler was found and removed.</returns>
        </member>
        <member name="M:KS.Reactor.ksLog.GetChannelName``1(``0)">
            <summary>Converts a Template T to a channel name.</summary>
            <typeparam name="T">Channel to convert to channel name.</typeparam>
            <param name="channel">Channel name.</param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksLog.Log``1(``0,System.String,System.Exception,KS.Reactor.ksLog.Level,System.Object)">
            <summary>Logs a message.</summary>
            <typeparam name="T"></typeparam>
            <param name="channel">Channel to log to.</param>
            <param name="message">Message to log.</param>
            <param name="exception">Exception to log.</param>
            <param name="level">Level of message.</param>
            <param name="context">Object related to this message.</param>
        </member>
        <member name="M:KS.Reactor.ksLog.HandleLog(System.String,System.String,System.String,System.Exception,KS.Reactor.ksLog.Level,System.Object)">
            <summary>Sends a log message to all handlers on a channel.</summary>
            <param name="channel">Channel the message was logged to.</param>
            <param name="handlerChannel">Channel handling the message. May be a parent of channel.</param>
            <param name="message">Message to log.</param>
            <param name="exception">Exception to log.</param>
            <param name="level">Level of message.</param>
            <param name="context">Object related to this message.</param>
            <returns>True if parent channels should process this message.</returns>
        </member>
        <member name="F:KS.Reactor.ksLog.MAX_LENGTH">
            <summary>
            Maximum number of characters in a log statement before it is split up into multiple log statements. This is
            to prevent Unity from breaking because a log statement is too long. This is a bit shorter than Unity's
            maximum (16384) since some extra text is added to each message (log level, channel, etc.).
            </summary>
        </member>
        <member name="M:KS.Reactor.ksLog.#cctor">
            <summary>Static initialization. Registers a Unity log handler.</summary>
        </member>
        <member name="M:KS.Reactor.ksLog.LogToUnity(KS.Reactor.ksLog.Level,System.String,System.String,System.Exception,System.Object)">
            <summary>Passes a log message to Unity's logger.</summary>
            <param name="level">level of the message.</param>
            <param name="channel">channel the message was sent to.</param>
            <param name="message">message to log. May be null if exception is provided.</param>
            <param name="exception">exception to log. May be null if message is provided.</param>
            <param name="context">object related to this message.</param>
        </member>
        <member name="M:KS.Reactor.ksLog.LogToUnity(KS.Reactor.ksLog.Level,System.String,System.String,System.Object,System.Int32,System.Int32)">
            <summary>Passes a log message to Unity's logger.</summary>
            <param name="level">level of the message.</param>
            <param name="channel">channel the message was sent to.</param>
            <param name="message">message to log.</param>
            <param name="part">
            if the log statement was split in to multiple parts, this is the part number, starting
            from 0.
            </param>
            <param name="totalParts">total number of parts the log statement was split into.</param>
        </member>
        <member name="M:KS.Reactor.ksLog.SplitLog(KS.Reactor.ksLog.Level,System.String,System.String,System.Object)">
            <summary>
            Splits a log statement into multiple smaller log statements that are less than MAX_LENGTH characters, and
            logs them.
            </summary>
            <param name="level">level of the message.</param>
            <param name="channel">channel the message was sent to.</param>
            <param name="message">message to log.</param>
            <param name="context">object related to this message.</param>
        </member>
        <member name="T:KS.Reactor.ksMath">
            <summary>
            Collection of frequently used math algorithms and coversions of <see cref="T:System.Math"/> methods 
            which operate on and return float values.
            </summary>
        </member>
        <member name="F:KS.Reactor.ksMath.Epsilon">
            <summary>
            Smallest float value that does not equate to 0. On ARM systems, the value of the Epsilon constant is too 
            small to be detected, so it equates to zero. In this case we use the value 1.175494E-38f.
            <see href="https://docs.microsoft.com/en-us/dotnet/api/system.single.epsilon?view=net-6.0#platform-notes"/>
            </summary>
        </member>
        <member name="M:KS.Reactor.ksMath.CountSetBits(System.Int32)">
            <summary>
            Count the number of bits set in an int
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMath.MaxSetBit(System.Int32)">
            <summary>
            Get the highest bit set from 1 to 32. If no bits are set, then this method returns 0.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMath.ClosestPowerOfTwo(System.Int32)">
            <summary>
            Returns the closest power of two value.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMath.IsPowerOfTwo(System.Int32)">
            <summary>
            Returns true if the value is power of two.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMath.NextPowerOfTwo(System.Int32)">
            <summary>
            Returns the next power of two that is equal to, or greater than, the argument.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMath.PerlinNoise(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Generate Perlin noise.
            </summary>
            <param name="x">X value</param>
            <param name="y">Y value</param>
            <param name="z">Z value</param>
            <param name="range">Values will be remapped onto [0...range) using value%range.</param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMath.Sin(System.Single)">
            <summary>
            Returns the sine of angle f.
            </summary>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMath.Cos(System.Single)">
            <summary>
            Returns the cosine of angle f.
            </summary>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMath.Tan(System.Single)">
            <summary>
            Returns the tangent of angle f in radians.
            </summary>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMath.Asin(System.Single)">
            <summary>
            Returns the absolute value of f.
            </summary>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMath.Acos(System.Single)">
            <summary>
            Returns the arc-cosine of f - the angle in radians whose cosine is f.
            </summary>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMath.Atan(System.Single)">
            <summary>
            Returns the arc-tangent of f - the angle in radians whose tangent is f.
            </summary>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMath.Atan2(System.Single,System.Single)">
            <summary>
            Returns the angle in radians whose Tan is y/x.
            </summary>
            <param name="y"></param>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMath.Sqrt(System.Single)">
            <summary>
            Returns square root of f.
            </summary>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMath.Abs(System.Single)">
            <summary>
            Returns the absolute value of f.
            </summary>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMath.Abs(System.Int32)">
            <summary>
            Returns the absolute value of f.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMath.Min(System.Single,System.Single)">
            <summary>
            Returns the smallest of two or more values.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMath.Min(System.Single[])">
            <summary>
            Returns the smallest of two or more values.
            </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMath.Min(System.Int32,System.Int32)">
            <summary>
            Returns the smallest of two or more values.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMath.Min(System.Int32[])">
            <summary>
            Returns the smallest of two or more values.
            </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMath.Max(System.Single,System.Single)">
            <summary>
            Returns largest of two or more values.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMath.Max(System.Single[])">
            <summary>
            Returns largest of two or more values.
            </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMath.Max(System.Int32,System.Int32)">
            <summary>
            Returns largest of two or more values.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMath.Max(System.Int32[])">
            <summary>
            Returns largest of two or more values.
            </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMath.Pow(System.Single,System.Single)">
            <summary>
            Returns f raised to power p.
            </summary>
            <param name="f"></param>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMath.Exp(System.Single)">
            <summary>
            Returns e raised to the specified power.
            </summary>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMath.Log(System.Single,System.Single)">
            <summary>
            Returns the logarithm of a specified number in a specified base.
            </summary>
            <param name="f"></param>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMath.Log(System.Single)">
            <summary>
            Returns the logarithm of a specified number in a specified base.
            </summary>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMath.Log10(System.Single)">
            <summary>
            Returns the base 10 logarithm of a specified number.
            </summary>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMath.Ceil(System.Single)">
            <summary>
            Returns the smallest integer greater to or equal to f.
            </summary>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMath.Floor(System.Single)">
            <summary>
            Returns the largest integer smaller than or equal to f.
            </summary>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMath.Round(System.Single)">
            <summary>
            Returns f rounded to the nearest integer.
            </summary>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMath.CeilToInt(System.Single)">
            <summary>
            Returns the smallest integer greater to or equal to f.
            </summary>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMath.FloorToInt(System.Single)">
            <summary>
            Returns the largest integer smaller to or equal to f.
            </summary>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMath.RoundToInt(System.Single)">
            <summary>
            Returns f rounded to the nearest integer.
            </summary>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMath.Sign(System.Single)">
            <summary>
            Returns the sign of f.
            </summary>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMath.Clamp(System.Single,System.Single,System.Single)">
            <summary>
            Clamps the given value between the given minimum float and maximum float values.
            Returns the given value if it is within the min and max range.
            </summary>
            <param name="value"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMath.Clamp(System.Int32,System.Int32,System.Int32)">
            <summary>
            Clamps the given value between the given minimum int and maximum int values.
            Returns the given value if it is within the min and max range.
            </summary>
            <param name="value"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMath.Clamp01(System.Single)">
            <summary>
            Clamps value between 0 and 1 and returns value.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMath.Lerp(System.Single,System.Single,System.Single)">
            <summary>
            Linearly interpolates between a and b by t.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMath.LerpUnclamped(System.Single,System.Single,System.Single)">
            <summary>
            Linearly interpolates between a and b by t with no limit to t.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMath.LerpAngle(System.Single,System.Single,System.Single)">
            <summary>
            Same as Lerp but makes sure the values interpolate correctly when they wrap around 360 degrees.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMath.MoveTowards(System.Single,System.Single,System.Single)">
            <summary>
            Moves a value current towards target. A negative value moves the value away from the target.
            </summary>
            <param name="current"></param>
            <param name="target"></param>
            <param name="maxDelta"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMath.MoveTowardsAngle(System.Single,System.Single,System.Single)">
            <summary>
            Same as MoveTowards but makes sure the values interpolate correctly when they wrap around 360 degrees.
            </summary>
            <param name="current"></param>
            <param name="target"></param>
            <param name="maxDelta"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMath.SmoothStep(System.Single,System.Single,System.Single)">
            <summary>
            Interpolates between min and max with smoothing at the limits.
            </summary>
            <param name="from"></param>
            <param name="to"></param>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMath.Gamma(System.Single,System.Single,System.Single)">
            <summary>
            Normalize a value between negative <paramref name="absmax"/> and positive <paramref name="absmax"/> 
            to -1...1 then raise the result to a power before remapping it into negative <paramref name="absmax"/>
            to <paramref name="absmax"/>.
            </summary>
            <param name="value"></param>
            <param name="absmax"></param>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMath.Approximately(System.Single,System.Single,System.Single)">
            <summary>
            Compares two floating point values and returns true if they are similar.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="tolerance">
            This value is mulitplied by the largest of a or b to determine the 
            value used for the comparison.
            </param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMath.SmoothDamp(System.Single,System.Single,System.Single@,System.Single,System.Single,System.Single)">
            <summary>
            Gradually changes a value towards a desired goal over time.
            </summary>
            <param name="current"></param>
            <param name="target"></param>
            <param name="currentVelocity"></param>
            <param name="smoothTime"></param>
            <param name="deltaTime"></param>
            <param name="maxSpeed"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMath.SmoothDampAngle(System.Single,System.Single,System.Single@,System.Single,System.Single,System.Single)">
            <summary>
            Gradually changes an angle given in degrees towards a desired goal angle over time.
            </summary>
            <param name="current"></param>
            <param name="target"></param>
            <param name="currentVelocity"></param>
            <param name="smoothTime"></param>
            <param name="deltaTime"></param>
            <param name="maxSpeed"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMath.Repeat(System.Single,System.Single)">
            <summary>
            Loops the value t, so that it is never larger than length and never smaller than 0.
            </summary>
            <param name="t"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMath.PingPong(System.Single,System.Single)">
            <summary>
            PingPong returns a value that will increment and decrement between the value 0 and length.
            </summary>
            <param name="t"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMath.InverseLerp(System.Single,System.Single,System.Single)">
            <summary>
            Calculates the linear parameter t that produces the interpolant value within the range [a, b].
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMath.DeltaAngle(System.Single,System.Single)">
            <summary>
            Calculates the shortest difference between two given angles given in degrees.
            </summary>
            <param name="current"></param>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMath.LineIntersection(KS.Reactor.ksVector2,KS.Reactor.ksVector2,KS.Reactor.ksVector2,KS.Reactor.ksVector2,KS.Reactor.ksVector2@)">
            <summary>
            Check if the line (p1,p2) intersects with line (p3, p4)
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <param name="p3"></param>
            <param name="p4"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMath.LineSegmentIntersection(KS.Reactor.ksVector2,KS.Reactor.ksVector2,KS.Reactor.ksVector2,KS.Reactor.ksVector2,KS.Reactor.ksVector2@)">
            <summary>
            Check if the line segment (p1,p2) intersects with the line segment (p3, p4)
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <param name="p3"></param>
            <param name="p4"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMath.Interpolate(System.Single,System.Single,System.Single,KS.Reactor.ksMath.Interpolation)">
            <summary>
            Interpolate between the value a and b according to an interpolation method.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="t"></param>
            <param name="equation"></param>
            <returns></returns>
        </member>
        <member name="T:KS.Reactor.ksMultiList`1">
            <summary>Wraps multiple lists and presents them as one list with read-only access.</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:KS.Reactor.ksMultiList`1.Count">
            <summary>The combined number of items in all lists.</summary>
        </member>
        <member name="P:KS.Reactor.ksMultiList`1.Item(System.Int32)">
            <summary>
            Gets the item at an index. The inner lists are treated as one continuous list, so if there are two lists
            and the first list has 3 items, index 3 will be the first item in the second list.
            </summary>
            <param name="index">Index</param>
            <returns>The item at the index.</returns>
        </member>
        <member name="M:KS.Reactor.ksMultiList`1.#ctor(System.Collections.Generic.IList{`0}[])">
            <summary>Constructor</summary>
            <param name="lists">The lists to wrap and present as one list.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiList`1.IndexOf(`0)">
            <summary>
            Gets the index of an item in the multi list. See <see cref="P:KS.Reactor.ksMultiList`1.Item(System.Int32)"/> for indexing rules.
            </summary>
            <param name="item">Item to get index of.</param>
            <returns>The index of the item, or -1 if the item was not found.</returns>
        </member>
        <member name="M:KS.Reactor.ksMultiList`1.Contains(`0)">
            <summary>Checks if an item is contained in any of the inner lists.</summary>
            <param name="item">Item to check for.</param>
            <returns>True if the item is in any of the inner lists.</returns>
        </member>
        <member name="M:KS.Reactor.ksMultiList`1.CopyTo(`0[],System.Int32)">
            <summary>Copies the contents of each list to an array.</summary>
            <param name="array">Array to copy to.</param>
            <param name="arrayIndex">Array index to start copying to.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiList`1.GetEnumerator">
            <summary>Enumerates all the lists.</summary>
            <returns>Enumerator for all the lists.</returns>
        </member>
        <member name="M:KS.Reactor.ksMultiList`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Enumerates all the lists.</summary>
            <returns>Enumerator for all the lists.</returns>
        </member>
        <member name="T:KS.Reactor.ksMultiType">
            <summary>
            Wraps a byte array and provides methods for interpreting/serializing/deserializing the data as different types.
            </summary>
            <summary>
            Wraps a byte array and provides methods for interpreting/serializing/deserializing the data as different types.
            </summary>
        </member>
        <member name="T:KS.Reactor.ksMultiType.Types">
            <summary>Data types that ksMultiTypes can store.</summary>
        </member>
        <member name="P:KS.Reactor.ksMultiType.OnSet">
            <summary>Called when the value is set.</summary>
        </member>
        <member name="P:KS.Reactor.ksMultiType.Initialize">
            <summary>Initialization functions for when type is not known at compile time.</summary>
        </member>
        <member name="P:KS.Reactor.ksMultiType.Convert">
            <summary>Conversions functions for when type is not known at compile time.</summary>
        </member>
        <member name="M:KS.Reactor.ksMultiType.#cctor">
            <summary>
            Initializes maps of initialization and conversion delegates for when type is not known at compile time.
            </summary>
        </member>
        <member name="P:KS.Reactor.ksMultiType.Type">
            <summary>Type of value.</summary>
        </member>
        <member name="P:KS.Reactor.ksMultiType.Data">
            <summary>The underlying byte array.</summary>
        </member>
        <member name="P:KS.Reactor.ksMultiType.IsArray">
            <summary>Is the multitype an array?</summary>
        </member>
        <member name="P:KS.Reactor.ksMultiType.TypeSize">
            <summary>Size of type, factoring in array length. -1 for variable length types.</summary>
        </member>
        <member name="P:KS.Reactor.ksMultiType.ArrayLength">
            <summary>Array length.</summary>
        </member>
        <member name="M:KS.Reactor.ksMultiType.IsSupported(System.Type)">
            <summary>Checks if a type can be converted to a ksMultiType.</summary>
            <param name="type">Type to check.</param>
            <returns>True if the type is supported.</returns>
        </member>
        <member name="M:KS.Reactor.ksMultiType.#ctor">
            <summary>Constructor.</summary>
        </member>
        <member name="M:KS.Reactor.ksMultiType.Create(System.Byte[],KS.Reactor.ksMultiType.Types,System.Int32)">
            <summary>Constructs a multitype directly from a byte array without making a copy of the data.</summary>
            <param name="data">Byte array data.</param>
            <param name="type">Type of value.</param>
            <param name="arrayLength">
            Array length. -1 for non-array types. If less than -1, the length of the data will be used.
            </param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMultiType.Clone">
            <summary>Create a copy of this multi type.</summary>
            <returns>Copy.</returns>
        </member>
        <member name="M:KS.Reactor.ksMultiType.#ctor(System.Object,System.Type)">
            <summary>Constructor for arbitrary type. Use this when you don't know the type at compile time.</summary>
            <param name="value">Value</param>
            <param name="type">Type of value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.GetValue(System.Type)">
            <summary>
            Gets the value as an arbitrary type. Use this when you don't know the type at compile time.
            Logs a warning if the multitype cannot be converted to the <paramref name="type"/>.
            </summary>
            <param name="type">Type to get value as.</param>
            <returns>Value.</returns>
        </member>
        <member name="M:KS.Reactor.ksMultiType.TryGetValue(System.Type,System.Object@)">
            <summary>
            Tries to get the value as an arbitrary type. Use this when you don't know the type at compile time.
            </summary>
            <param name="type">Type to get value as.</param>
            <param name="value">
            The converted value of the multitype, or null if it cannot be converted to <paramref name="type"/>.
            </param>
            <returns>True if the multitype could be converted to <paramref name="type"/>.</returns>
        </member>
        <member name="M:KS.Reactor.ksMultiType.#ctor(System.Int32)">
            <summary>Constructor.</summary>
            <param name="value">Int value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.#ctor(System.Int32[])">
            <summary>Constructor.</summary>
            <param name="value">Int array value.</param>
        </member>
        <member name="P:KS.Reactor.ksMultiType.Int">
            <summary>The value as an int.</summary>
        </member>
        <member name="P:KS.Reactor.ksMultiType.IntArray">
            <summary>The value as an int array.</summary>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(System.Int32)~KS.Reactor.ksMultiType">
            <summary>Implicit conversion from int to ksMultiType.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(KS.Reactor.ksMultiType)~System.Int32">
            <summary>Implicit conversion from ksMultiType to int.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(System.Int32[])~KS.Reactor.ksMultiType">
            <summary>Implicit conversion from int array to ksMultiType.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(KS.Reactor.ksMultiType)~System.Int32[]">
            <summary>Implicit conversion from ksMultiType to int array.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.GetInt(System.Int32@)">
            <summary>
            Gets the value at an index as an int. Converts to int if the value is of a different type.
            </summary>
            <param name="index">Index to get int from.</param>
            <returns>Int value.</returns>
        </member>
        <member name="M:KS.Reactor.ksMultiType.#ctor(System.Single)">
            <summary>Constructor.</summary>
            <param name="value">Float value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.#ctor(System.Single[])">
            <summary>Constructor.</summary>
            <param name="value">Float array value.</param>
        </member>
        <member name="P:KS.Reactor.ksMultiType.Float">
            <summary>The value as a float.</summary>
        </member>
        <member name="P:KS.Reactor.ksMultiType.FloatArray">
            <summary>The value as a float array.</summary>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(System.Single)~KS.Reactor.ksMultiType">
            <summary>Implicit conversion from float to ksMultiType.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(KS.Reactor.ksMultiType)~System.Single">
            <summary>Implicit conversion from ksMultiType to float.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(System.Single[])~KS.Reactor.ksMultiType">
            <summary>Implicit conversion from float array to ksMultiType.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(KS.Reactor.ksMultiType)~System.Single[]">
            <summary>Implicit conversion from ksMultiType to float array.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.GetFloat(System.Int32@)">
            <summary>
            Gets the value at an index as a float. Converts to float if the value is of a different type.
            </summary>
            <param name="index">Index to get float from.</param>
            <returns>Float value.</returns>
        </member>
        <member name="M:KS.Reactor.ksMultiType.#ctor(System.String)">
            <summary>Constructor.</summary>
            <param name="value">String value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.#ctor(System.String[])">
            <summary>Constructor.</summary>
            <param name="value">String array value.</param>
        </member>
        <member name="P:KS.Reactor.ksMultiType.String">
            <summary>The value as a string.</summary>
        </member>
        <member name="P:KS.Reactor.ksMultiType.StringArray">
            <summary>The value as a string array.</summary>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(System.String)~KS.Reactor.ksMultiType">
            <summary>Implicit conversion from string to ksMultiType.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(KS.Reactor.ksMultiType)~System.String">
            <summary>Implicit conversion from ksMultiType to string.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(System.String[])~KS.Reactor.ksMultiType">
            <summary>Implicit conversion from string array to ksMultiType.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(KS.Reactor.ksMultiType)~System.String[]">
            <summary>Implicit conversion from ksMultiType to string array.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.GetString(System.Int32@)">
            <summary>
            Gets the value at an index as a string. Converts to string if the value is of a different type.
            </summary>
            <param name="index">Index to get string from.</param>
            <returns>String value.</returns>
        </member>
        <member name="M:KS.Reactor.ksMultiType.SetString(System.Int32@,System.String)">
            <summary>Sets the value at an index to a string.</summary>
            <param name="index">Index to set.</param>
            <param name="value">String value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.ParseString(System.Int32@)">
            <summary>Parses the value at an index as a string.</summary>
            <param name="index">Index to parse string from.</param>
            <returns>String value.</returns>
        </member>
        <member name="M:KS.Reactor.ksMultiType.#ctor(System.Boolean)">
            <summary>Constructor.</summary>
            <param name="value">Bool value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.#ctor(System.Boolean[])">
            <summary>Constructor.</summary>
            <param name="value">Bool array value.</param>
        </member>
        <member name="P:KS.Reactor.ksMultiType.Bool">
            <summary>The value as a bool.</summary>
        </member>
        <member name="P:KS.Reactor.ksMultiType.BoolArray">
            <summary>The value as a bool array.</summary>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(System.Boolean)~KS.Reactor.ksMultiType">
            <summary>Implicit conversion from bool to ksMultiType.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(KS.Reactor.ksMultiType)~System.Boolean">
            <summary>Implicit conversion from ksMultiType to bool.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(System.Boolean[])~KS.Reactor.ksMultiType">
            <summary>Implicit conversion from iboolnt array to ksMultiType.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(KS.Reactor.ksMultiType)~System.Boolean[]">
            <summary>Implicit conversion from ksMultiType to bool array.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.GetBool(System.Int32@)">
            <summary>
            Gets the value at an index as a bool. Converts to bool if the value is of a different type.
            </summary>
            <param name="index">Index to get bool from.</param>
            <returns>Bool value.</returns>
        </member>
        <member name="M:KS.Reactor.ksMultiType.SetBool(System.Int32@,System.Boolean)">
            <summary>Sets the value at an index to a bool.</summary>
            <param name="index">Index to set.</param>
            <param name="value">Bool value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.ParseBool(System.Int32@)">
            <summary>Parses the value at an index as a bool.</summary>
            <param name="index">Index to parse bool from.</param>
            <returns>Bool value.</returns>
        </member>
        <member name="M:KS.Reactor.ksMultiType.#ctor(System.UInt32)">
            <summary>Constructor.</summary>
            <param name="value">Uint value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.#ctor(System.UInt32[])">
            <summary>Constructor.</summary>
            <param name="value">Uint array value.</param>
        </member>
        <member name="P:KS.Reactor.ksMultiType.UInt">
            <summary>The value as a uint.</summary>
        </member>
        <member name="P:KS.Reactor.ksMultiType.UIntArray">
            <summary>The value as a uint array.</summary>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(System.UInt32)~KS.Reactor.ksMultiType">
            <summary>Implicit conversion from uint to ksMultiType.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(KS.Reactor.ksMultiType)~System.UInt32">
            <summary>Implicit conversion from ksMultiType to uint.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(System.UInt32[])~KS.Reactor.ksMultiType">
            <summary>Implicit conversion from uint array to ksMultiType.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(KS.Reactor.ksMultiType)~System.UInt32[]">
            <summary>Implicit conversion from ksMultiType to uint array.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.GetUInt(System.Int32@)">
            <summary>
            Gets the value at an index as a uint. Converts to uint if the value is of a different type.
            </summary>
            <param name="index">Index to get uint from.</param>
            <returns>Uint value.</returns>
        </member>
        <member name="M:KS.Reactor.ksMultiType.#ctor(System.Byte)">
            <summary>Constructor.</summary>
            <param name="value">Byte value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.#ctor(System.Byte[])">
            <summary>Constructor.</summary>
            <param name="value">Byte array value.</param>
        </member>
        <member name="P:KS.Reactor.ksMultiType.Byte">
            <summary>The value as a byte.</summary>
        </member>
        <member name="P:KS.Reactor.ksMultiType.ByteArray">
            <summary>The value as a byte array.</summary>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(System.Byte)~KS.Reactor.ksMultiType">
            <summary>Implicit conversion from byte to ksMultiType.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(KS.Reactor.ksMultiType)~System.Byte">
            <summary>Implicit conversion from ksMultiType to byte.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(System.Byte[])~KS.Reactor.ksMultiType">
            <summary>Implicit conversion from byte array to ksMultiType.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(KS.Reactor.ksMultiType)~System.Byte[]">
            <summary>Implicit conversion from ksMultiType to byte array.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.GetByte(System.Int32@)">
            <summary>
            Gets the value at an index as a byte. Converts to byte if the value is of a different type.
            </summary>
            <param name="index">Index to get byte from.</param>
            <returns>Byte value.</returns>
        </member>
        <member name="M:KS.Reactor.ksMultiType.SetByte(System.Int32@,System.Byte)">
            <summary>Sets the value at an index to a byte.</summary>
            <param name="index">Index to set.</param>
            <param name="value">Byte value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.ParseByte(System.Int32@)">
            <summary>Parses the value at an index as a byte.</summary>
            <param name="index">Index to parse byte from.</param>
            <returns>Byte value.</returns>
        </member>
        <member name="M:KS.Reactor.ksMultiType.#ctor(System.Int64)">
            <summary>Constructor.</summary>
            <param name="value">Long value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.#ctor(System.Int64[])">
            <summary>Constructor.</summary>
            <param name="value">Long array value.</param>
        </member>
        <member name="P:KS.Reactor.ksMultiType.Long">
            <summary>The value as a long.</summary>
        </member>
        <member name="P:KS.Reactor.ksMultiType.LongArray">
            <summary>The value as a long array.</summary>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(System.Int64)~KS.Reactor.ksMultiType">
            <summary>Implicit conversion from long to ksMultiType.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(KS.Reactor.ksMultiType)~System.Int64">
            <summary>Implicit conversion from ksMultiType to long.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(System.Int64[])~KS.Reactor.ksMultiType">
            <summary>Implicit conversion from long array to ksMultiType.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(KS.Reactor.ksMultiType)~System.Int64[]">
            <summary>Implicit conversion from ksMultiType to long array.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.GetLong(System.Int32@)">
            <summary>
            Gets the value at an index as a long. Converts to long if the value is of a different type.
            </summary>
            <param name="index">Index to get long from.</param>
            <returns>Long value.</returns>
        </member>
        <member name="M:KS.Reactor.ksMultiType.#ctor(KS.Reactor.ksVector3)">
            <summary>Constructor.</summary>
            <param name="value">ksVector3 value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.#ctor(KS.Reactor.ksVector3[])">
            <summary>Constructor.</summary>
            <param name="value">ksVector3 array value.</param>
        </member>
        <member name="P:KS.Reactor.ksMultiType.KSVector3">
            <summary>The value as a ksVector3.</summary>
        </member>
        <member name="P:KS.Reactor.ksMultiType.KSVector3Array">
            <summary>The value as a ksVector3 array.</summary>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(KS.Reactor.ksVector3)~KS.Reactor.ksMultiType">
            <summary>Implicit conversion from ksVector3 to ksMultiType.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(KS.Reactor.ksMultiType)~KS.Reactor.ksVector3">
            <summary>Implicit conversion from ksMultiType to ksVector3.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(KS.Reactor.ksVector3[])~KS.Reactor.ksMultiType">
            <summary>Implicit conversion from ksVector3 array to ksMultiType.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(KS.Reactor.ksMultiType)~KS.Reactor.ksVector3[]">
            <summary>Implicit conversion from ksMultiType to ksVector3 array.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.#ctor(KS.Reactor.ksVector2)">
            <summary>Constructor.</summary>
            <param name="value">ksVector2 value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.#ctor(KS.Reactor.ksVector2[])">
            <summary>Constructor.</summary>
            <param name="value">ksVector2 array value.</param>
        </member>
        <member name="P:KS.Reactor.ksMultiType.KSVector2">
            <summary>The value as a ksVector2.</summary>
        </member>
        <member name="P:KS.Reactor.ksMultiType.KSVector2Array">
            <summary>The value as a ksVector2 array.</summary>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(KS.Reactor.ksVector2)~KS.Reactor.ksMultiType">
            <summary>Implicit conversion from ksVector2 to ksMultiType.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(KS.Reactor.ksMultiType)~KS.Reactor.ksVector2">
            <summary>Implicit conversion from ksMultiType to ksVector2.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(KS.Reactor.ksVector2[])~KS.Reactor.ksMultiType">
            <summary>Implicit conversion from ksVector2 array to ksMultiType.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(KS.Reactor.ksMultiType)~KS.Reactor.ksVector2[]">
            <summary>Implicit conversion from ksMultiType to ksVector2 array.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.#ctor(KS.Reactor.ksQuaternion)">
            <summary>Constructor.</summary>
            <param name="value">ksQuaternion value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.#ctor(KS.Reactor.ksQuaternion[])">
            <summary>Constructor.</summary>
            <param name="value">ksQuaternion array value.</param>
        </member>
        <member name="P:KS.Reactor.ksMultiType.KSQuaternion">
            <summary>The value as a ksQuaternion.</summary>
        </member>
        <member name="P:KS.Reactor.ksMultiType.KSQuaternionArray">
            <summary>The value as a ksQuaternion array.</summary>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(KS.Reactor.ksQuaternion)~KS.Reactor.ksMultiType">
            <summary>Implicit conversion from ksQuaternion to ksMultiType.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(KS.Reactor.ksMultiType)~KS.Reactor.ksQuaternion">
            <summary>Implicit conversion from ksMultiType to ksQuaternion.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(KS.Reactor.ksQuaternion[])~KS.Reactor.ksMultiType">
            <summary>Implicit conversion from ksQuaternion array to ksMultiType.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(KS.Reactor.ksMultiType)~KS.Reactor.ksQuaternion[]">
            <summary>Implicit conversion from ksMultiType to ksQuaternion array.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.#ctor(KS.Reactor.ksColor)">
            <summary>Constructor.</summary>
            <param name="value">ksColor value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.#ctor(KS.Reactor.ksColor[])">
            <summary>Constructor.</summary>
            <param name="value">ksColor array value.</param>
        </member>
        <member name="P:KS.Reactor.ksMultiType.KSColor">
            <summary>The value as a ksColor.</summary>
        </member>
        <member name="P:KS.Reactor.ksMultiType.KSColorArray">
            <summary>The value as a ksColor array.</summary>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(KS.Reactor.ksColor)~KS.Reactor.ksMultiType">
            <summary>Implicit conversion from ksColor to ksMultiType.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(KS.Reactor.ksMultiType)~KS.Reactor.ksColor">
            <summary>Implicit conversion from ksMultiType to ksColor.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(KS.Reactor.ksColor[])~KS.Reactor.ksMultiType">
            <summary>Implicit conversion from ksColor array to ksMultiType.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(KS.Reactor.ksMultiType)~KS.Reactor.ksColor[]">
            <summary>Implicit conversion from ksMultiType to ksColor array.</summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.#ctor(KS.Reactor.ksIBufferable)">
            <summary>Constructor.</summary>
            <param name="value">ksIBufferable value.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.CreateBufferableArray``1(``0[])">
            <summary>Constructs a multitype from a an array of ksIBufferable types.</summary>
            <typeparam name="T"></typeparam>
            <param name="value">Array of a type that implements ksIBufferable.</param>
            <returns>ksMultiType</returns>
        </member>
        <member name="M:KS.Reactor.ksMultiType.FromBufferable(KS.Reactor.ksIBufferable)">
            <summary>Stores a ksIBufferable in the multiType.</summary>
            <param name="value"></param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.ToBufferable``1">
            <summary>Converts this multitype to a ksIBufferable object</summary>
            <typeparam name="T">T implements ksIBufferable.</typeparam>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMultiType.ToBufferable(System.Type)">
            <summary>Converts this multitype to a ksIBufferable object.</summary>
            <param name="type">Type of ksIBufferable to convert to.</param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMultiType.FromBufferableArray``1(``0[])">
            <summary>Stores a ksIBufferable array in the multiType.</summary>
            <typeparam name="T"></typeparam>
            <param name="array"></param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.ToBufferableArray``1">
            <summary>Converts this multitype to a ksIBufferable[] object.</summary>
            <typeparam name="T">T implements ksIBufferable.</typeparam>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMultiType.ConvertTo(KS.Reactor.ksMultiType.Types)">
            <summary>
            Converts the multitype to the given type.
            Eg. If the multi type is a float with value 3.14 and you convert to an int, the new int value will be 3.
            </summary>
            <param name="type">Type to convert to.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.Equals(KS.Reactor.ksMultiType)">
            <summary>Checks if this multi type has the same value as another multi type.</summary>
            <param name="multiType">Multi type to compare with.</param>
            <returns>True if the values are the same.</returns>
        </member>
        <member name="M:KS.Reactor.ksMultiType.ToString">
            <summary>Gets the string representation of the value.</summary>
            <returns>The string representation of the value.</returns>
        </member>
        <member name="M:KS.Reactor.ksMultiType.FromJSON(KS.Reactor.ksJSON)">
            <summary>Constructs a multi type from JSON.</summary>
            <param name="json">
            ksJSON json to construct multitype from. Should be an object with two fields:
            type - the type corresponding to one of the Types enum values.
            value - the value of the multi type.
            </param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMultiType.ToJSON">
            <summary>Gets the ksJSON representation of the value.</summary>
            <returns>The ksJSON representation of the value.</returns>
        </member>
        <member name="M:KS.Reactor.ksMultiType.ToJSONArray``1(``0[],KS.Reactor.ksMultiType.JSONSerializer{``0})">
            <summary>Converts an array to a json array.</summary>
            <typeparam name="T">Array to convert.</typeparam>
            <param name="array">Serializer to serialize individual elements with.</param>
            <param name="serializer"></param>
            <returns>JSON array</returns>
        </member>
        <member name="M:KS.Reactor.ksMultiType.ArrayToString``1(``0[])">
            <summary>Converts an array to a string.</summary>
            <typeparam name="T"></typeparam>
            <param name="array">Array to convert.</param>
            <returns>String.</returns>
        </member>
        <member name="M:KS.Reactor.ksMultiType.CompareArrays``1(``0[],``0[])">
            <summary>Compares to arrays to see if they are equivalent.</summary>
            <typeparam name="T"></typeparam>
            <param name="array1"></param>
            <param name="array2"></param>
            <returns>True if the arrays are the same.</returns>
        </member>
        <member name="M:KS.Reactor.ksMultiType.Get``1(KS.Reactor.ksMultiType.Getter{``0})">
            <summary>Generic getter.</summary>
            <typeparam name="T"></typeparam>
            <param name="getter">Getter to get value with.</param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMultiType.Set``1(``0,KS.Reactor.ksMultiType.Setter{``0},KS.Reactor.ksMultiType.Types,System.Int32)">
            <summary>Generic setter.</summary>
            <typeparam name="T"></typeparam>
            <param name="value">Value to set.</param>
            <param name="setter">Setter to set value with.</param>
            <param name="type">Type of value.</param>
            <param name="size">Size of data. If 0 or less, will be set to size of T.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.GetArray``1(KS.Reactor.ksMultiType.Getter{``0})">
            <summary>Generic array getter.</summary>
            <typeparam name="T"></typeparam>
            <param name="getter">Getter to get values with.</param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMultiType.SetArray``1(``0[],KS.Reactor.ksMultiType.Setter{``0},KS.Reactor.ksMultiType.Types,System.Int32)">
            <summary>Generic array setter.</summary>
            <typeparam name="T"></typeparam>
            <param name="value">Value to set.</param>
            <param name="setter">Setter to set values with.</param>
            <param name="type">Type of value.</param>
            <param name="size">Size of data. If 0 or less, will be set to size of T * value.Length.</param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.Set``1(System.Int32@,``0)">
            <summary>Sets the value at an index to a T struct.</summary>
            <typeparam name="T"></typeparam>
            <param name="index">Index to set.</param>
            <param name="value"></param>
        </member>
        <member name="M:KS.Reactor.ksMultiType.Parse``1(System.Int32@)">
            <summary>Parses the value at an index as a T struct.</summary>
            <typeparam name="T"></typeparam>
            <param name="index">Index to parse int from.</param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMultiType.IsNumeric(KS.Reactor.ksMultiType.Types)">
            <summary>Is the type numeric?</summary>
            <param name="t">ksMultitype type.</param>
            <returns>True if the type is (byte, int, uint, long, or float).</returns>
        </member>
        <member name="M:KS.Reactor.ksMultiType.CombinedType(KS.Reactor.ksMultiType.Types,KS.Reactor.ksMultiType.Types)">
            <summary>
            Gets the resulting type when combining two ksMultitype types with an arithmetic operation.
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Addition(System.String,KS.Reactor.ksMultiType)">
            <summary>String concatenation.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns>Concatenated string.</returns>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Addition(KS.Reactor.ksMultiType,System.String)">
            <summary>String concatenation.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns>Concatenated string.</returns>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Addition(KS.Reactor.ksMultiType,KS.Reactor.ksMultiType)">
            <summary>MultiType addition or concatination.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Subtraction(KS.Reactor.ksMultiType,KS.Reactor.ksMultiType)">
            <summary>MultiType subtraction.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Multiply(KS.Reactor.ksMultiType,KS.Reactor.ksMultiType)">
            <summary>MultiType multiplication.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Division(KS.Reactor.ksMultiType,KS.Reactor.ksMultiType)">
            <summary>MultiType division.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Modulus(KS.Reactor.ksMultiType,KS.Reactor.ksMultiType)">
            <summary>MultiType modulus.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Increment(KS.Reactor.ksMultiType)">
            <summary>MultiType increment.</summary>
            <param name="operand"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Decrement(KS.Reactor.ksMultiType)">
            <summary>MultiType decrement.</summary>
            <param name="operand"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksMultiType.MultiTypeUnityExtender.#ctor">
            <summary>
            Initializes conversion and initialization functions for Unity <see cref="T:UnityEngine.Vector2"/>,
            <see cref="T:UnityEngine.Vector3"/> and <see cref="T:UnityEngine.Quaternion"/>.
            </summary>
        </member>
        <member name="T:KS.Reactor.ksMultiType.SerializableData">
            <summary>Contains data for Unity to serialize.</summary>
        </member>
        <member name="M:KS.Reactor.ksMultiType.UnityEngine#ISerializationCallbackReceiver#OnBeforeSerialize">
            <summary>Copies data from the multitype onto the object that Unity can serialize.</summary>
        </member>
        <member name="M:KS.Reactor.ksMultiType.UnityEngine#ISerializationCallbackReceiver#OnAfterDeserialize">
            <summary>Copies serialized Unity data onto the multitype.</summary>
        </member>
        <member name="P:KS.Reactor.ksMultiType.Vector3">
            <summary>The value as a <see cref="T:UnityEngine.Vector3"/>.</summary>
        </member>
        <member name="P:KS.Reactor.ksMultiType.Vector3Array">
            <summary>The value as a <see cref="T:UnityEngine.Vector3"/> array.</summary>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(UnityEngine.Vector3)~KS.Reactor.ksMultiType">
            <summary>Implicit conversion from <see cref="T:UnityEngine.Vector3"/> to <see cref="T:KS.Reactor.ksMultiType"/>.</summary>
            <param name="value"></param>
            <returns>Multi type</returns>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(KS.Reactor.ksMultiType)~UnityEngine.Vector3">
            <summary>Implicit conversion from <see cref="T:KS.Reactor.ksMultiType"/> to <see cref="T:UnityEngine.Vector3"/>.</summary>
            <param name="value"></param>
            <returns>Vector3</returns>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(UnityEngine.Vector3[])~KS.Reactor.ksMultiType">
            <summary>
            Implicit conversion from <see cref="T:UnityEngine.Vector3"/> array to <see cref="T:KS.Reactor.ksMultiType"/>.
            </summary>
            <param name="value"></param>
            <returns>Multi type</returns>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(KS.Reactor.ksMultiType)~UnityEngine.Vector3[]">
            <summary>
            Implicit conversion from <see cref="T:KS.Reactor.ksMultiType"/> to <see cref="T:UnityEngine.Vector3"/> array.
            </summary>
            <param name="value"></param>
            <returns>Vector3 array</returns>
        </member>
        <member name="P:KS.Reactor.ksMultiType.Vector2">
            <summary>The value as a <see cref="T:UnityEngine.Vector2"/>.</summary>
        </member>
        <member name="P:KS.Reactor.ksMultiType.Vector2Array">
            <summary>The value as a <see cref="T:UnityEngine.Vector2"/> array.</summary>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(UnityEngine.Vector2)~KS.Reactor.ksMultiType">
            <summary>Implicit conversion from <see cref="T:UnityEngine.Vector2"/> to <see cref="T:KS.Reactor.ksMultiType"/>.</summary>
            <param name="value"></param>
            <returns>Multi type</returns>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(KS.Reactor.ksMultiType)~UnityEngine.Vector2">
            <summary>Implicit conversion from <see cref="T:KS.Reactor.ksMultiType"/> to <see cref="T:UnityEngine.Vector2"/>.</summary>
            <param name="value"></param>
            <returns>Vector2</returns>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(UnityEngine.Vector2[])~KS.Reactor.ksMultiType">
            <summary>
            Implicit conversion from <see cref="T:UnityEngine.Vector2"/> array to <see cref="T:KS.Reactor.ksMultiType"/>.
            </summary>
            <param name="value"></param>
            <returns>Multi type</returns>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(KS.Reactor.ksMultiType)~UnityEngine.Vector2[]">
            <summary>
            Implicit conversion from <see cref="T:KS.Reactor.ksMultiType"/> to <see cref="T:UnityEngine.Vector2"/> array.
            </summary>
            <param name="value"></param>
            <returns>Vector2 array</returns>
        </member>
        <member name="P:KS.Reactor.ksMultiType.Quaternion">
            <summary>The value as a <see cref="T:UnityEngine.Quaternion"/>.</summary>
        </member>
        <member name="P:KS.Reactor.ksMultiType.QuaternionArray">
            <summary>The value as a <see cref="T:UnityEngine.Quaternion"/> array.</summary>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(UnityEngine.Quaternion)~KS.Reactor.ksMultiType">
            <summary>
            Implicit conversion from <see cref="T:UnityEngine.Quaternion"/> to <see cref="T:KS.Reactor.ksMultiType"/>.
            </summary>
            <param name="value"></param>
            <returns>Multi type</returns>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(KS.Reactor.ksMultiType)~UnityEngine.Quaternion">
            <summary>
            Implicit conversion from <see cref="T:KS.Reactor.ksMultiType"/> to <see cref="T:UnityEngine.Quaternion"/>.
            </summary>
            <param name="value"></param>
            <returns>Quaternion</returns>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(UnityEngine.Quaternion[])~KS.Reactor.ksMultiType">
            <summary>
            Implicit conversion from <see cref="T:UnityEngine.Quaternion"/> array to <see cref="T:KS.Reactor.ksMultiType"/>.
            </summary>
            <param name="value"></param>
            <returns>Multi type</returns>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(KS.Reactor.ksMultiType)~UnityEngine.Quaternion[]">
            <summary>
            Implicit conversion from <see cref="T:KS.Reactor.ksMultiType"/> to <see cref="T:UnityEngine.Quaternion"/> array.
            </summary>
            <param name="value"></param>
            <returns>Quaternion array</returns>
        </member>
        <member name="P:KS.Reactor.ksMultiType.Color">
            <summary>The value as a <see cref="T:UnityEngine.Color"/>.</summary>
        </member>
        <member name="P:KS.Reactor.ksMultiType.ColorArray">
            <summary>The value as a <see cref="T:UnityEngine.Color"/> array.</summary>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(UnityEngine.Color)~KS.Reactor.ksMultiType">
            <summary>Implicit conversion from <see cref="T:UnityEngine.Color"/> to <see cref="T:KS.Reactor.ksMultiType"/>.</summary>
            <param name="value"></param>
            <returns>Multi type</returns>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(KS.Reactor.ksMultiType)~UnityEngine.Color">
            <summary>Implicit conversion from <see cref="T:KS.Reactor.ksMultiType"/> to <see cref="T:UnityEngine.Color"/>.</summary>
            <param name="value"></param>
            <returns>Color</returns>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(UnityEngine.Color[])~KS.Reactor.ksMultiType">
            <summary>
            Implicit conversion from <see cref="T:UnityEngine.Color"/> array to <see cref="T:KS.Reactor.ksMultiType"/>.
            </summary>
            <param name="value"></param>
            <returns>Multi type</returns>
        </member>
        <member name="M:KS.Reactor.ksMultiType.op_Implicit(KS.Reactor.ksMultiType)~UnityEngine.Color[]">
            <summary>
            Implicit conversion from <see cref="T:KS.Reactor.ksMultiType"/> to <see cref="T:UnityEngine.Color"/> array.
            </summary>
            <param name="value"></param>
        </member>
        <member name="T:KS.Reactor.ksNoUnityProxyAttribute">
            <summary>Server scripts tagged with this will not have Unity proxy scripts generated for them.</summary>
        </member>
        <member name="T:KS.Reactor.ksObjectPool">
            <summary>Static class for configuring object pools.</summary>
        </member>
        <member name="F:KS.Reactor.ksObjectPool.DefaultLimit">
            <summary>
            The default maximum number of objects to allow in objects pools. Object pools that have a negative
            <see cref="P:KS.Reactor.ksObjectPool`1.OverrideLimit"/> will use this value. By default this is zero which disables
            object pooling. If you enable object pooling, be aware that entities and linear predictors will be pooled,
            so references to destroyed entities can become references to new entities, and linear predictors cannot be
            reassigned once they are unassigned and returned to the pool.
            </summary>
        </member>
        <member name="T:KS.Reactor.ksObjectPool`1">
            <summary>
            An object pool that constructs new objects using the default constructor or a factory delegate.
            </summary>
            <typeparam name="T">Type of object in the pool</typeparam>
        </member>
        <member name="P:KS.Reactor.ksObjectPool`1.Instance">
            <summary>Static instance.</summary>
        </member>
        <member name="T:KS.Reactor.ksObjectPool`1.Factory">
            <summary>Creates a new instance for the pool.</summary>
            <returns>new instance</returns>
        </member>
        <member name="P:KS.Reactor.ksObjectPool`1.Limit">
            <summary>
            The maximum number of objects allowed in the pool. Returns <see cref="P:KS.Reactor.ksObjectPool`1.OverrideLimit"/> if it is greater
            than or equal to zero, otherwise returns <see cref="F:KS.Reactor.ksObjectPool.DefaultLimit"/>.
            </summary>
        </member>
        <member name="P:KS.Reactor.ksObjectPool`1.OverrideLimit">
            <summary>
            If this is greater than or equal to zero, this is used as the <see cref="P:KS.Reactor.ksObjectPool`1.Limit"/> instead of
            <see cref="F:KS.Reactor.ksObjectPool.DefaultLimit"/>.
            </summary>
        </member>
        <member name="P:KS.Reactor.ksObjectPool`1.IsFull">
            <summary>Has the pool size reached the <see cref="P:KS.Reactor.ksObjectPool`1.Limit"/>?</summary>
        </member>
        <member name="M:KS.Reactor.ksObjectPool`1.#ctor">
            <summary>
            Constructor that uses the default constructor to create <typeparamref name="T"/> instances.
            </summary>
        </member>
        <member name="M:KS.Reactor.ksObjectPool`1.#ctor(KS.Reactor.ksObjectPool{`0}.Factory,System.Int32)">
            <summary>Constructor that uses a factory</summary>
            <param name="factory">Factory to create new instances.</param>
            <param name="limit">
            Maximum number of objects allowed in the pool. If less than zero, use
            <see cref="F:KS.Reactor.ksObjectPool.DefaultLimit"/>
            </param>
        </member>
        <member name="M:KS.Reactor.ksObjectPool`1.Create(System.Int32)">
            <summary>Creates new objects and add them to the pool.</summary>
            <param name="amount">Amount of objects to create.</param>
        </member>
        <member name="M:KS.Reactor.ksObjectPool`1.AtomicFetch">
            <summary>
            Fetch an instance of the object from the pool thread-safely. If the pool is empty, then create a new
            object.
            </summary>
            <returns>instance</returns>
        </member>
        <member name="M:KS.Reactor.ksObjectPool`1.Fetch">
            <summary>
            Fetch an instance of the object from the pool. If the pool is empty, then create a new object.
            </summary>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksObjectPool`1.AtomicReturn(`0)">
            <summary>Returns an object to the pool thread-safely.</summary>
            <param name="obj">Pool object.</param>
        </member>
        <member name="M:KS.Reactor.ksObjectPool`1.Return(`0)">
            <summary>
            Returns an object to the pool. Objects will not be returned if the pool <see cref="P:KS.Reactor.ksObjectPool`1.IsFull"/>.
            </summary>
            <param name="obj">Pool object.</param>
        </member>
        <member name="T:KS.Reactor.ksEventSet`1">
            <summary>Tracks events in a hashset.</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:KS.Reactor.ksEventSet`1.op_Addition(KS.Reactor.ksEventSet{`0},`0)">
            <summary>Adds an event handler to the event.</summary>
            <param name="lhs">Event to add handler to.</param>
            <param name="rhs">Handler to add.</param>
            <returns>lhs</returns>
        </member>
        <member name="M:KS.Reactor.ksEventSet`1.op_Subtraction(KS.Reactor.ksEventSet{`0},`0)">
            <summary>Adds an event handler to the event.</summary>
            <param name="lhs">Event to add handler to.</param>
            <param name="rhs">Handler to add.</param>
            <returns>lhs</returns>
        </member>
        <member name="M:KS.Reactor.ksEventSet`1.Remove(`0)">
            <summary>Remove an item from the event set</summary>
            <param name="item">Item to be removed</param>
            <returns>True if the remove was handled immediately. If the removal was not immediate, ProcessRemovals() must be invoked.</returns>
        </member>
        <member name="M:KS.Reactor.ksEventSet`1.ForEach(KS.Reactor.ksEventSet{`0}.ForEachCallback)">
            <summary>Iterate and invoke the callback on all items.</summary>
            <param name="callback"></param>
        </member>
        <member name="T:KS.Reactor.ksOrderedEvents`1">
            <summary>Tracks event sets in a sorted dictionary.</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:KS.Reactor.ksOrderedEvents`1.Item(System.Int32)">
            <summary>Gets the event for a key.</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="T:KS.Reactor.ksOverlapParams">
            <summary>Parameters for overlap queries</summary>
        </member>
        <member name="F:KS.Reactor.ksOverlapParams.EntityColliderFilter">
            <summary>
            Collider filter for entity queries to determine which of the entity's colliders to run queries for. Only
            used for entity queries.
            </summary>
        </member>
        <member name="F:KS.Reactor.ksOverlapParams.UseEntityPosition">
            <summary>
            If true, the position of the entity will be used in place of an explicit origin or rotation.
            This value does not affect ksShape overlap objects.
            </summary>
        </member>
        <member name="F:KS.Reactor.ksOverlapParams.UseEntityRotation">
            <summary>
            If true, the rotation of the entity will be used in place of an explicit origin or rotation.
            This value does not affect ksShape overlap objects.
            </summary>
        </member>
        <member name="M:KS.Reactor.ksOverlapParams.#ctor">
            <summary>Constructor</summary>
        </member>
        <member name="P:KS.Reactor.ksOverlapParams.QueryType">
            <summary>Query type</summary>
        </member>
        <member name="P:KS.Reactor.ksOverlapParams.Shape">
            <summary>Get/Set the <see cref="T:KS.Reactor.ksShape"/></summary>
        </member>
        <member name="P:KS.Reactor.ksOverlapParams.Entity">
            <summary>Get/Set the <see cref="T:KS.Reactor.ksIEntity"/></summary>
        </member>
        <member name="P:KS.Reactor.ksOverlapParams.Collider">
            <summary>Get/Set the <see cref="T:KS.Reactor.ksICollider"/></summary>
        </member>
        <member name="P:KS.Reactor.ksOverlapParams.QueryObject">
            <summary>
            Get/Set the object which defines the geomeetry being queried.
            </summary>
        </member>
        <member name="P:KS.Reactor.ksOverlapParams.Origin">
            <summary>
            Set/Get the query origin.
            When UseEntityPosition is false, queries using colliders will add the collider offset to the origin to determine the geometry positioning.
            </summary>
        </member>
        <member name="P:KS.Reactor.ksOverlapParams.Rotation">
            <summary>
            Set/Get the query rotation.
            When UseEntityRotation is false, queries using colliders will add the collider rotataion to this rotatation to determine the geometry positioning.
            </summary>
        </member>
        <member name="P:KS.Reactor.ksOverlapParams.ObjectType">
            <summary>The object type used in the query.</summary>
        </member>
        <member name="M:KS.Reactor.ksOverlapParams.#ctor(KS.Reactor.ksVector3,KS.Reactor.ksQuaternion,KS.Reactor.ksIQueryFilter,KS.Reactor.ksIEntity,KS.Reactor.ksQueryFlags,System.Boolean,System.Boolean)">
            <summary>
            Private common constructor for all query object types
            </summary>
            <param name="origin"></param>
            <param name="rotation"></param>
            <param name="filter"></param>
            <param name="excludeEntity"></param>
            <param name="flags"></param>
            <param name="useEntityPosition"></param>
            <param name="useEntityRotation"></param>
        </member>
        <member name="M:KS.Reactor.ksOverlapParams.#ctor(KS.Reactor.ksShape,KS.Reactor.ksVector3,KS.Reactor.ksQuaternion,KS.Reactor.ksIQueryFilter,KS.Reactor.ksIEntity,KS.Reactor.ksQueryFlags)">
            <summary>Constructor</summary>
            <param name="shape">Overlap shape</param>
            <param name="origin">Overlap origin</param>
            <param name="rotation">Shape rotation</param>
            <param name="filter">Query filter for filtering results.</param>
            <param name="excludeEntity">Exclude this entity from results.</param>
            <param name="flags">Query flags for filtering results.</param>
        </member>
        <member name="M:KS.Reactor.ksOverlapParams.#ctor(KS.Reactor.ksIEntity,KS.Reactor.ksIQueryFilter,KS.Reactor.ksIEntityQueryColliderFilter,System.Boolean,KS.Reactor.ksQueryFlags)">
            <summary>
            Entity overlap which uses the pose of the entity when the query is performed.
            </summary>
            <param name="entity">Overlap entity</param>
            <param name="filter">Query filter for filtering results.</param>
            <param name="colliderFilter">
            Query collider filter for filtering which of the entity's colliders to query with.
            </param>
            <param name="excludeSelf">Should <paramref name="entity"/> be excluded from results?</param>
            <param name="flags">Query flags for filtering results.</param>
        </member>
        <member name="M:KS.Reactor.ksOverlapParams.#ctor(KS.Reactor.ksIEntity,KS.Reactor.ksVector3,KS.Reactor.ksQuaternion,KS.Reactor.ksIQueryFilter,KS.Reactor.ksIEntityQueryColliderFilter,System.Boolean,KS.Reactor.ksQueryFlags)">
            <summary>
            Entity overlap which sets the pose;
            </summary>
            <param name="entity">Overlap entity</param>
            <param name="origin">Overlap origin</param>
            <param name="rotation">Shape rotation</param>
            <param name="filter">Query filter for filtering results.</param>
            <param name="colliderFilter">
            Query collider filter for filtering which of the entity's colliders to query with.
            </param>
            <param name="excludeSelf">Should <paramref name="entity"/> be excluded from results?</param>
            <param name="flags">Query flags for filtering results.</param>
        </member>
        <member name="M:KS.Reactor.ksOverlapParams.#ctor(KS.Reactor.ksICollider,KS.Reactor.ksIQueryFilter,System.Boolean,KS.Reactor.ksQueryFlags)">
            <summary>Collider overlap that uses the collider's entity's pose.</summary>
            <param name="collider">Overlap collider</param>
            <param name="filter">Query filter for filtering results.</param>
            <param name="excludeColliderEntity">
            Should <paramref name="collider"/>'s entity be excluded from results?
            </param>
            <param name="flags">Query flags for filtering results.</param>
        </member>
        <member name="M:KS.Reactor.ksOverlapParams.#ctor(KS.Reactor.ksICollider,KS.Reactor.ksVector3,KS.Reactor.ksQuaternion,KS.Reactor.ksIQueryFilter,System.Boolean,KS.Reactor.ksQueryFlags)">
            <summary>Collider overlap that sets the pose.</summary>
            <param name="collider">Overlap collider</param>
            <param name="origin">Overlap origin</param>
            <param name="rotation">Shape rotation</param>
            <param name="filter">Query filter for filtering results.</param>
            <param name="excludeColliderEntity">
            Should <paramref name="collider"/>'s entity be excluded from results?
            </param>
            <param name="flags">Query flags for filtering results.</param>
        </member>
        <member name="M:KS.Reactor.ksOverlapParams.Validate(System.Boolean)">
            <summary>
            Checks if the parameters are valid. The parameters are invalid if <see cref="P:KS.Reactor.ksOverlapParams.Shape"/> is null or if
            <see cref="F:KS.Reactor.ksBaseQueryParams.Filter"/> is a <see cref="T:KS.Reactor.ksCollisionFilter"/>
            </summary>
            <param name="log">If true, logs warnings describing what is invalid if anything is invalid.</param>
            <returns>True if the params are valid.</returns>
        </member>
        <member name="M:KS.Reactor.ksOverlapParams.CopyTo(KS.Reactor.ksOverlapParams)">
            <summary>Copies the values from this object to the <paramref name="target"/>.</summary>
            <param name="target">Target to copy to.</param>
        </member>
        <member name="T:KS.Reactor.ksOverlapResult">
            <summary>Result of an overlap scene query.</summary>
        </member>
        <member name="F:KS.Reactor.ksOverlapResult.QueryCollider">
            <summary>The collider used in the query. Null for shape queries.</summary>
        </member>
        <member name="F:KS.Reactor.ksOverlapResult.Entity">
            <summary>Overlapped entity</summary>
        </member>
        <member name="F:KS.Reactor.ksOverlapResult.Collider">
            <summary>Overlapped collider</summary>
        </member>
        <member name="T:KS.Reactor.ksIPerformanceTimer">
            <summary>Performance timer interface.</summary>
        </member>
        <member name="P:KS.Reactor.ksIPerformanceTimer.LogInterval">
            <summary>
            Ammount of time between timer logs in milliseconds. 
            A negative log value will disable the timer.
            A zero value will report the timer value every sample.
            </summary>
        </member>
        <member name="T:KS.Reactor.ksPerformanceTimer">
            <summary>
            Basic performance timer that tracks time and reports timing statistics.
            </summary>
        </member>
        <member name="T:KS.Reactor.ksPerformanceTimer.States">
            <summary>Timer states</summary>
        </member>
        <member name="F:KS.Reactor.ksPerformanceTimer.States.OFF">
            <summary>
            The timer is not running or paused. Call <see cref="M:KS.Reactor.ksPerformanceTimer.Start"/> or <see cref="M:KS.Reactor.ksPerformanceTimer.Resume"/> to start the timer.
            </summary>
        </member>
        <member name="F:KS.Reactor.ksPerformanceTimer.States.RUNNING">
            <summary>
            The timer is tracking time. Call <see cref="M:KS.Reactor.ksPerformanceTimer.Stop"/> or <see cref="M:KS.Reactor.ksPerformanceTimer.Pause"/> to stop or pause the timer.
            </summary>
        </member>
        <member name="F:KS.Reactor.ksPerformanceTimer.States.PAUSED">
            <summary>
            The timer is paused and not tracking time. Call <see cref="M:KS.Reactor.ksPerformanceTimer.Resume"/> to resume tracking time.
            </summary>
        </member>
        <member name="M:KS.Reactor.ksPerformanceTimer.#ctor(System.String,System.Int32)">
            <summary>
            Constructor.
            </summary>
            <param name="logChannel">Channel used to log timer stats.</param>
            <param name="logInterval">
            Time in milliseconds between logs. A negative value disables the timer. Zero will reporty every sample.
            </param>
        </member>
        <member name="P:KS.Reactor.ksPerformanceTimer.LogInterval">
            <summary>
            Ammount of time between timer logs in milliseconds. 
            A negative log value will disable the timer.
            A zero value will report the timer value every sample.
            </summary>
        </member>
        <member name="P:KS.Reactor.ksPerformanceTimer.State">
            <summary>The state of the timer.</summary>
        </member>
        <member name="M:KS.Reactor.ksPerformanceTimer.Start">
            <summary>
            Start the timer.
            </summary>
        </member>
        <member name="M:KS.Reactor.ksPerformanceTimer.Stop">
            <summary>
            Stop the timer and add the elapsed time to the timing stats.
            If the time since the last stats log exceeds the log interval 
            a new log message with the stats will be printed and the stats will
            be cleared.
            </summary>
        </member>
        <member name="M:KS.Reactor.ksPerformanceTimer.Restart">
            <summary>Stops and restarts the timer.</summary>
        </member>
        <member name="M:KS.Reactor.ksPerformanceTimer.Pause">
            <summary>
            Pause a timing cycle. Time between pause and resume calls will
            not be included in the current timing data.
            </summary>
        </member>
        <member name="M:KS.Reactor.ksPerformanceTimer.Resume">
            <summary>
            Resume the timer.
            </summary>
        </member>
        <member name="M:KS.Reactor.ksPerformanceTimer.LogStats">
            <summary>
            Print the current timing stats.
            </summary>
        </member>
        <member name="M:KS.Reactor.ksPerformanceTimer.ClearStats">
            <summary>
            Clear the current timing stats.
            </summary>
        </member>
        <member name="M:KS.Reactor.ksPerformanceTimer.TicksToMS(System.Int64)">
            <summary>
            Convert timer ticks to a fractional millisecond time.
            </summary>
            <param name="ticks">Timer ticks</param>
            <returns>Time in milliseconds</returns>
        </member>
        <member name="T:KS.Reactor.ksPerlinNoise">
            <summary>
            Adaption of the the perlin noise code found at http://adrianb.io/2014/08/09/perlinnoise.html
            </summary>
        </member>
        <member name="M:KS.Reactor.ksPerlinNoise.#cctor">
            <summary>
            Static initializer for the doubled permutation array.
            </summary>
        </member>
        <member name="M:KS.Reactor.ksPerlinNoise.GetValue(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Calculate a Perlin noise value at a coordinate
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
            <param name="range"></param>
            <returns>Perlin noise value.</returns>
        </member>
        <member name="M:KS.Reactor.ksPerlinNoise.GetValue(System.Double,System.Double,System.Double,System.Int32,System.Double,System.Double)">
            <summary>
            Generate a Perlin noise value by adding mulitple values over multiple passes at different frequencies.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
            <param name="octaves">Number of passes to combine</param>
            <param name="persistence">
            The amount a noise pass is scaled by in each pass. Scaling is applied repreatedly in each pass. 
            </param>
            <param name="range"></param>
            <returns>Perline noise value.</returns>
        </member>
        <member name="M:KS.Reactor.ksPerlinNoise.Grad(System.Int32,System.Double,System.Double,System.Double)">
            <summary>
            Maps coordinate values into a single unique value.
            </summary>
            <param name="hash"></param>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksPerlinNoise.Fade(System.Double)">
            <summary>
            Fade function as defined by Ken Perlin. This eases coordinate values
            so that they will "ease" towards integral values.  This ends up smoothing
            the final output.
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksPerlinNoise.Lerp(System.Double,System.Double,System.Double)">
            <summary>
            Interpolate between two valuea a and b by t.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="T:KS.Reactor.ksPlayerAPI">
            <summary>Implementation of the ksPlayerAPI used for player requests.</summary>
        </member>
        <member name="T:KS.Reactor.ksPlayerAPI.DeviceTypes">
            <summary>Recognized device types.</summary>
        </member>
        <member name="P:KS.Reactor.ksPlayerAPI.SessionExpiry">
            <summary>
            How long in hours it takes a session created by a login request to expire with no activity.
            </summary>
        </member>
        <member name="T:KS.Reactor.ksPlayerAPI.Session">
            <summary>
            Player session information with implementation of the API requests that require an authenticated player.
            </summary>
        </member>
        <member name="P:KS.Reactor.ksPlayerAPI.Session.IsValid">
            <summary>Check if the session is valid.</summary>
        </member>
        <member name="P:KS.Reactor.ksPlayerAPI.Session.PlayerId">
            <summary>Return the player ID.</summary>
        </member>
        <member name="P:KS.Reactor.ksPlayerAPI.Session.Token">
            <summary>Return the session token.</summary>
        </member>
        <member name="M:KS.Reactor.ksPlayerAPI.Session.#ctor(KS.Reactor.ksPlayerAPI,System.String,System.String)">
            <summary>Constructs a new player session .</summary>
            <param name="playerAPI">PlayerAPI instance that constructed this session.</param>
            <param name="playerId">Player ID.</param>
            <param name="token">Session token.</param>
        </member>
        <member name="M:KS.Reactor.ksPlayerAPI.Session.#ctor(KS.Reactor.ksPlayerAPI,System.String)">
            <summary>Creates a session from a base64 encoded session string.</summary>
            <param name="playerAPI">PlayerAPI instance that constructed this session.</param>
            <param name="encodedSession">Encoded session.</param>
        </member>
        <member name="M:KS.Reactor.ksPlayerAPI.Session.Authenticate(KS.Reactor.ksPlayerAPI.LoginCallback,System.Object)">
            <summary>Authenticate the current session.</summary>
            <param name="callback">Asynchronous callback.</param>
            <param name="asyncState">State object returned in the callback.</param>
        </member>
        <member name="M:KS.Reactor.ksPlayerAPI.Session.Logout(KS.Reactor.ksPlayerAPI.GenericCallback,System.Object)">
            <summary>Invalidate a ksPlayerAPI.Session.</summary>
            <param name="callback">Asynchronous callback.</param>
            <param name="asyncState">State object returned in the callback.</param>
        </member>
        <member name="M:KS.Reactor.ksPlayerAPI.Session.LinkDeviceID(System.String,KS.Reactor.ksPlayerAPI.DeviceTypes,KS.Reactor.ksPlayerAPI.GenericCallback,System.Object)">
            <summary>Links a device ID to the current active session.</summary>
            <param name="deviceId">Device ID.</param>
            <param name="deviceType">Device type.</param>
            <param name="callback">Asynchronous callback.</param>
            <param name="asyncState">State object returned in the callback.</param>
        </member>
        <member name="M:KS.Reactor.ksPlayerAPI.Session.LinkPassword(System.String,System.String,System.String,KS.Reactor.ksPlayerAPI.GenericCallback,System.Object)">
            <summary>Links a password credential to the current active session.</summary>
            <param name="email"></param>
            <param name="username"></param>
            <param name="password"></param>
            <param name="callback">Asynchronous callback.</param>
            <param name="asyncState">State object returned in the callback.</param>
        </member>
        <member name="M:KS.Reactor.ksPlayerAPI.Session.UnlinkDeviceID(System.String,KS.Reactor.ksPlayerAPI.DeviceTypes,KS.Reactor.ksPlayerAPI.GenericCallback,System.Object)">
            <summary>Unlinks a device ID from the current active session.</summary>
            <param name="deviceId">Device ID.</param>
            <param name="deviceType">Device type.</param>
            <param name="callback">Asynchronous callback.</param>
            <param name="asyncState">State object returned in the callback.</param>
        </member>
        <member name="M:KS.Reactor.ksPlayerAPI.Session.UnlinkPassword(KS.Reactor.ksPlayerAPI.GenericCallback,System.Object)">
            <summary>Unlinks a password credential from the current active session.</summary>
            <param name="callback">Asynchronous callback.</param>
            <param name="asyncState">State object returned in the callback.</param>
        </member>
        <member name="M:KS.Reactor.ksPlayerAPI.Session.ToBase64">
            <summary>
            Encodes the player ID and token as a base64 encode string that can be used save and restore sessions.
            </summary>
            <returns></returns>
        </member>
        <member name="T:KS.Reactor.ksPlayerAPI.LoginCallback">
            <summary>Callback for all login requests.</summary>
            <param name="error">Error message.</param>
            <param name="session">Session created on a successful login.</param>
            <param name="asyncState">Asynchronous state object.</param>
        </member>
        <member name="T:KS.Reactor.ksPlayerAPI.GenericCallback">
            <summary>Generic callback with no return data.</summary>
            <param name="error">Error message.</param>
            <param name="asyncState">Asynchronous state object.</param>
        </member>
        <member name="T:KS.Reactor.ksPlayerAPI.RequestHandler">
            <summary>Web request handler for API calls.</summary>
            <param name="url">URL.</param>
            <param name="headers">Additional request headers.</param>
            <param name="method">Request method.</param>
            <param name="data">POST request data.</param>
            <param name="onComplete">Request callback.</param>
            <param name="stateObject">State object returned in the callback.</param>
            <returns></returns>
        </member>
        <member name="T:KS.Reactor.ksPlayerAPI.ResponseState`1">
            <summary>Response state that contains the callback and other async data.</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:KS.Reactor.ksPlayerAPI.ResponseState`1.#ctor(`0,System.Object,KS.Reactor.ksPlayerAPI.Session)">
            <summary>Constructor.</summary>
            <param name="callback">Callback function.</param>
            <param name="asyncState">Async state object.</param>
            <param name="session">Session associated withe the request.</param>
        </member>
        <member name="M:KS.Reactor.ksPlayerAPI.#ctor(KS.Reactor.ksPlayerAPI.RequestHandler)">
            <summary>Constructor.</summary>
            <param name="requestFactory">Optional request handling method.</param>
        </member>
        <member name="M:KS.Reactor.ksPlayerAPI.DefaultRequestHandler(System.String,System.Net.WebHeaderCollection,System.String,KS.Reactor.ksJSON,KS.Reactor.ksWebResponse.Handler,System.Object)">
            <summary>
            The default API request handler uses ksWebRequest which will call the completion handler on
            another thread when a response is received.
            </summary>
            <param name="url">URL</param>
            <param name="headers">Additional request headers.</param>
            <param name="method">Request method.</param>
            <param name="data">POST request data.</param>
            <param name="onComplete">Request callback.</param>
            <param name="stateObject">State object returned in the callback.</param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksPlayerAPI.Initialize(System.String,System.String,System.String)">
            <summary>Initializes the API object.</summary>
            <param name="APIURL">Player API URL.</param>
            <param name="APIKey">Project ID.</param>
            <param name="APISecret">Project client secret.</param>
        </member>
        <member name="M:KS.Reactor.ksPlayerAPI.Register(System.String,System.String,System.String,KS.Reactor.ksPlayerAPI.GenericCallback,System.Object)">
            <summary>Creates a new player with email/username/password credentials.</summary>
            <param name="email"></param>
            <param name="username"></param>
            <param name="password"></param>
            <param name="callback">Asynchronous callback.</param>
            <param name="asyncState">State object returned in the callback.</param>
        </member>
        <member name="M:KS.Reactor.ksPlayerAPI.OnRegister(KS.Reactor.ksWebResponse)">
            <summary>Handles email/username/password registration responses.</summary>
            <param name="response"></param>
        </member>
        <member name="M:KS.Reactor.ksPlayerAPI.LoginWithDeviceID(System.String,KS.Reactor.ksPlayerAPI.DeviceTypes,System.Boolean,KS.Reactor.ksPlayerAPI.LoginCallback,System.Object)">
            <summary>Login with device ID.</summary>
            <param name="deviceId">Device ID.</param>
            <param name="deviceType">Device type.</param>
            <param name="register">Register a new player.</param>
            <param name="callback">Asynchronous callback.</param>
            <param name="asyncState">State object returned in the callback.</param>
        </member>
        <member name="M:KS.Reactor.ksPlayerAPI.LoginWithEmail(System.String,System.String,KS.Reactor.ksPlayerAPI.LoginCallback,System.Object)">
            <summary>Login with an email address and password.</summary>
            <param name="email"></param>
            <param name="password"></param>
            <param name="callback">Asynchronous callback.</param>
            <param name="asyncState">State object returned in the callback.</param>
        </member>
        <member name="M:KS.Reactor.ksPlayerAPI.LoginWithUsername(System.String,System.String,KS.Reactor.ksPlayerAPI.LoginCallback,System.Object)">
            <summary>Login with an email address and password.</summary>
            <param name="username"></param>
            <param name="password"></param>
            <param name="callback">Asynchronous callback.</param>
            <param name="asyncState">State object returned in the callback.</param>
        </member>
        <member name="M:KS.Reactor.ksPlayerAPI.OnLogin(KS.Reactor.ksWebResponse)">
            <summary>Handles session login responses.</summary>
            <param name="response"></param>
        </member>
        <member name="M:KS.Reactor.ksPlayerAPI.CreateSession(System.String)">
            <summary>Constructs and binds a new session to this API using a Base64 encoded session string.</summary>
            <param name="encodedSession">Encoded session string.</param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksPlayerAPI.Authenticate(KS.Reactor.ksPlayerAPI.Session,KS.Reactor.ksPlayerAPI.LoginCallback,System.Object)">
            <summary>Authenticates the current session.</summary>
            <param name="session">Session to authenticate.</param>
            <param name="callback">Asynchronous callback.</param>
            <param name="asyncState">State object returned in the callback.</param>
        </member>
        <member name="M:KS.Reactor.ksPlayerAPI.OnAuthenticate(KS.Reactor.ksWebResponse)">
            <summary>Handles session authentication responses.</summary>
            <param name="response"></param>
        </member>
        <member name="M:KS.Reactor.ksPlayerAPI.Logout(KS.Reactor.ksPlayerAPI.Session,KS.Reactor.ksPlayerAPI.GenericCallback,System.Object)">
            <summary>Invalidates a ksPlayerAPI.Session.</summary>
            <param name="session">Session to authenticate.</param>
            <param name="callback">Asynchronous callback.</param>
            <param name="asyncState">State object returned in the callback.</param>
        </member>
        <member name="M:KS.Reactor.ksPlayerAPI.OnLogout(KS.Reactor.ksWebResponse)">
            <summary>Handles session authentication responses.</summary>
            <param name="response"></param>
        </member>
        <member name="M:KS.Reactor.ksPlayerAPI.LinkDeviceID(KS.Reactor.ksPlayerAPI.Session,System.String,KS.Reactor.ksPlayerAPI.DeviceTypes,KS.Reactor.ksPlayerAPI.GenericCallback,System.Object)">
            <summary>Links a device ID to the current active session.</summary>
            <param name="session">Session to use for the request.</param>
            <param name="deviceId">Device ID.</param>
            <param name="deviceType">Device type.</param>
            <param name="callback">Asynchronous callback.</param>
            <param name="asyncState">State object returned in the callback.</param>
        </member>
        <member name="M:KS.Reactor.ksPlayerAPI.LinkPassword(KS.Reactor.ksPlayerAPI.Session,System.String,System.String,System.String,KS.Reactor.ksPlayerAPI.GenericCallback,System.Object)">
            <summary>Links a password credential to the current active session.</summary>
            <param name="session"></param>
            <param name="email"></param>
            <param name="username"></param>
            <param name="password"></param>
            <param name="callback">Asynchronous callback.</param>
            <param name="asyncState">State object returned in the callback.</param>
        </member>
        <member name="M:KS.Reactor.ksPlayerAPI.OnLink(KS.Reactor.ksWebResponse)">
            <summary>Handles credential linking responses.</summary>
            <param name="response"></param>
        </member>
        <member name="M:KS.Reactor.ksPlayerAPI.UnlinkDeviceID(KS.Reactor.ksPlayerAPI.Session,System.String,KS.Reactor.ksPlayerAPI.DeviceTypes,KS.Reactor.ksPlayerAPI.GenericCallback,System.Object)">
            <summary>Unlinks a device ID from the current active session.</summary>
            <param name="session">Session to use for the request.</param>
            <param name="deviceId">Device ID.</param>
            <param name="deviceType">Device type.</param>
            <param name="callback">Asynchronous callback.</param>
            <param name="asyncState">State object returned in the callback.</param>
        </member>
        <member name="M:KS.Reactor.ksPlayerAPI.UnlinkPassword(KS.Reactor.ksPlayerAPI.Session,KS.Reactor.ksPlayerAPI.GenericCallback,System.Object)">
            <summary>Unlinks a password credential from the current active session.</summary>
            <param name="session">Session to use for the request.</param>
            <param name="callback">Asynchronous callback.</param>
            <param name="asyncState">State object returned in the callback.</param>
        </member>
        <member name="M:KS.Reactor.ksPlayerAPI.OnUnlink(KS.Reactor.ksWebResponse)">
            <summary>Handles credential unlinking responses.</summary>
            <param name="response"></param>
        </member>
        <member name="M:KS.Reactor.ksPlayerAPI.GenerateHeaders(KS.Reactor.ksPlayerAPI.Session)">
            <summary>Generates the headers required for a ksPlayerAPI request.</summary>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="T:KS.Reactor.ksPlayerController">
            <summary>
            Base class for player controllers. Player controllers allow you to write one class that runs on both the client
            and the server for controlling entity movement using player inputs. The server uses it for authoritative
            movement, and the client uses it for prediction/latency masking.
            </summary>
        </member>
        <member name="P:KS.Reactor.ksPlayerController.Input">
            <summary>Player input.</summary>
        </member>
        <member name="P:KS.Reactor.ksPlayerController.Transform">
            <summary>Entity transform.</summary>
        </member>
        <member name="P:KS.Reactor.ksPlayerController.Transform2D">
            <summary>2D entity transform.</summary>
        </member>
        <member name="P:KS.Reactor.ksPlayerController.RigidBody">
            <summary>Entity rigid body.</summary>
        </member>
        <member name="P:KS.Reactor.ksPlayerController.RigidBody2D">
            <summary>2D entity rigid body.</summary>
        </member>
        <member name="P:KS.Reactor.ksPlayerController.CharacterController">
            <summary>Character controller.</summary>
        </member>
        <member name="P:KS.Reactor.ksPlayerController.Entity">
            <summary>Entity this player controller is controlling.</summary>
        </member>
        <member name="P:KS.Reactor.ksPlayerController.Time">
            <summary>Time.</summary>
        </member>
        <member name="P:KS.Reactor.ksPlayerController.Properties">
            <summary>Entity properties.</summary>
        </member>
        <member name="P:KS.Reactor.ksPlayerController.Physics">
            <summary>Physics API.</summary>
        </member>
        <member name="P:KS.Reactor.ksPlayerController.UseInputPrediction">
            <summary>
            Should this controller use input prediction? Set this to false in Initialize or in the inspector to disable
            input prediction. Setting this after Initialize is called will do nothing.
            </summary>
        </member>
        <member name="P:KS.Reactor.ksPlayerController.Type">
            <summary>Player controller type. This must be unique-per class and non-zero.</summary>
        </member>
        <member name="M:KS.Reactor.ksPlayerController.RegisterInputs(KS.Reactor.ksInputRegistrar)">
            <summary>Register all buttons and axes you will be using here.</summary>
            <param name="registrar">Registrar to register with.</param>
        </member>
        <member name="M:KS.Reactor.ksPlayerController.Initialize">
            <summary>Called after properties are initialized.</summary>
        </member>
        <member name="M:KS.Reactor.ksPlayerController.Update">
            <summary>Called every frame.</summary>
        </member>
        <member name="M:KS.Reactor.ksPlayerController.Clone">
            <summary>
            Creates a copy of the controller with the value of all members tagged with ksEditable or ksCloneable copied.
            Arrays, lists, and dictionaries are cloned. Other object references will reference the same object.
            </summary>
        </member>
        <member name="T:KS.Reactor.ksPropertyMap">
            <summary>Provides access to ksProperties.</summary>
        </member>
        <member name="T:KS.Reactor.ksPropertyMap.OnSetHandler">
            <summary>On set handler.</summary>
            <param name="propertyId">ID of property that was set.</param>
            <param name="value">Value of property.</param>
        </member>
        <member name="P:KS.Reactor.ksPropertyMap.OnSet">
            <summary>Delegate to call when a property is set.</summary>
        </member>
        <member name="P:KS.Reactor.ksPropertyMap.ReadOnly">
            <summary>If true, using ksPropertyMap[propertyId] = value will not set property values.</summary>
        </member>
        <member name="P:KS.Reactor.ksPropertyMap.UseControllerValues">
            <summary>
            If true, ksPropertyMap[propertyId] will read from and write to the controller values. If a property is not
            found in the controller values, will read from the regular values. Used for input prediction.
            </summary>
        </member>
        <member name="P:KS.Reactor.ksPropertyMap.ControllerValues">
            <summary>Values written to by the player controller. Used for input prediction.</summary>
        </member>
        <member name="P:KS.Reactor.ksPropertyMap.Properties">
            <summary>Maps property ids to property values.</summary>
        </member>
        <member name="M:KS.Reactor.ksPropertyMap.#ctor(System.Boolean)">
            <summary>Constructor</summary>
            <param name="readOnly">Is this a read-only map?</param>
        </member>
        <member name="P:KS.Reactor.ksPropertyMap.Item(System.UInt32)">
            <summary>
            Gets/Sets the value of a property. This will never return null; if a property id
            is not in the map, a ksMultiType of type ksMultiType.Types.UNDEFINED is returned.
            </summary>
            <param name="propertyId"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksPropertyMap.Contains(System.UInt32)">
            <summary>Checks if a property id is in the map.</summary>
            <param name="propertyId">Property ID to check for.</param>
            <returns>True if the property id is in the map.</returns>
        </member>
        <member name="M:KS.Reactor.ksPropertyMap.GetEnumerator">
            <summary>Gets the property enumerator.</summary>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksPropertyMap.System#Collections#IEnumerable#GetEnumerator">
            <summary>Gets the property enumerator.</summary>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksPropertyMap.Get(System.UInt32)">
            <summary>
            Gets a property value directly from the map (Will return null if the property id is not found).
            </summary>
            <param name="propertyId">ID of property to get.</param>
            <returns>Value of property.</returns>
        </member>
        <member name="M:KS.Reactor.ksPropertyMap.Set(System.UInt32,KS.Reactor.ksMultiType)">
            <summary>
            Sets a property value without calling the OnSet delegate or updating the value in scripts.
            </summary>
            <param name="propertyId">ID of property to set.</param>
            <param name="value">Value to set.</param>
        </member>
        <member name="M:KS.Reactor.ksPropertyMap.CreateSetCallback(System.UInt32)">
            <summary>Creates an OnSet callback for a multitype with the given propertyId.</summary>
            <param name="propertyId">ID to create callback for.</param>
            <returns>Callback.</returns>
        </member>
        <member name="M:KS.Reactor.ksPropertyMap.OnSetProperty(System.UInt32,KS.Reactor.ksMultiType)">
            <summary>Calls the OnSet delegate.</summary>
            <param name="propertyId">ID of property that was set.</param>
            <param name="value">Value of property.</param>
        </member>
        <member name="T:KS.Reactor.ksQuaternion">
            <summary>ksQuaternion struct.</summary>
            <summary>Quaternion struct</summary>
        </member>
        <member name="F:KS.Reactor.ksQuaternion.m_identity">
            <summary>Identity.</summary>
        </member>
        <member name="P:KS.Reactor.ksQuaternion.X">
            <summary>X value of this quaternion.</summary>
        </member>
        <member name="P:KS.Reactor.ksQuaternion.Y">
            <summary>Y value of this quaternion.</summary>
        </member>
        <member name="P:KS.Reactor.ksQuaternion.Z">
            <summary>Z value of this quaternion.</summary>
        </member>
        <member name="P:KS.Reactor.ksQuaternion.W">
            <summary>W value of this quaternion.</summary>
        </member>
        <member name="P:KS.Reactor.ksQuaternion.Item(System.Int32)">
            <summary>Indexer.</summary>
        </member>
        <member name="M:KS.Reactor.ksQuaternion.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>Constructor.</summary>
            <param name="x">X value.</param>
            <param name="y">Y value.</param>
            <param name="z">Z value.</param>
            <param name="w">W value.</param>
        </member>
        <member name="M:KS.Reactor.ksQuaternion.op_Implicit(KS.Reactor.ksQuaternion)~System.Single[]">
            <summary>Implicit conversion from ksQuaternion to float[4].</summary>
        </member>
        <member name="M:KS.Reactor.ksQuaternion.op_Implicit(System.Single[])~KS.Reactor.ksQuaternion">
            <summary>Implicit conversion from float[] to ksQuaternion.</summary>
        </member>
        <member name="M:KS.Reactor.ksQuaternion.GetFirstNonZeroComponentSign">
            <summary>Return true if first nonzero component is positive or all components are zeros.</summary>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksQuaternion.Normalize">
            <summary>Normalizes this quaternion.</summary>
        </member>
        <member name="M:KS.Reactor.ksQuaternion.Inverse">
            <summary>Inversed quaternion.</summary>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksQuaternion.Invert">
            <summary>Inverts this quaternion.</summary>
        </member>
        <member name="M:KS.Reactor.ksQuaternion.ToEuler">
            <summary>Euler angle representation of this quaternion in degrees.</summary>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksQuaternion.ToEulerRadians">
            <summary>Euler angle representation of this quaternion in radians.</summary>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksQuaternion.FromEuler(KS.Reactor.ksVector3)">
            <summary>Constructs a ksQuaternion from euler angles.</summary>
            <param name="euler">Euler angles in degrees.</param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksQuaternion.FromEulerRadians(KS.Reactor.ksVector3)">
            <summary>Constructs a ksQuaternion from euler angles.</summary>
            <param name="euler">Euler angles in radians.</param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksQuaternion.ToAxisAngle(KS.Reactor.ksVector3@,System.Single@)">
            <summary>Converts the quaternion to axis-angle representation.</summary>
            <param name="axis">Axis of rotation.</param>
            <param name="angle">Angle of rotation in degrees.</param>
        </member>
        <member name="M:KS.Reactor.ksQuaternion.ToAxisAngleRadians(KS.Reactor.ksVector3@,System.Single@)">
            <summary>Converts the quaternion to axis-angle representation.</summary>
            <param name="axis">Axis of rotation.</param>
            <param name="angle">Angle of rotation in radians.</param>
        </member>
        <member name="M:KS.Reactor.ksQuaternion.FromAxisAngle(KS.Reactor.ksVector3,System.Single)">
            <summary>Constructs a ksQuaternion from an axis-angle.</summary>
            <param name="axis">Axis of rotation.</param>
            <param name="angle">Angle of rotation in degrees.</param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksQuaternion.FromAxisAngleRadians(KS.Reactor.ksVector3,System.Single)">
            <summary>Constructs a ksQuaternion from an axis-angle.</summary>
            <param name="axis">Axis of rotation.</param>
            <param name="angle">Angle of rotation in radians.</param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksQuaternion.ToAngularDisplacement">
            <summary>angular displacement representation of this quaternion in degrees.</summary>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksQuaternion.ToAngularDisplacementRadians">
            <summary>Angular displacement representation of this quaternion in radians.</summary>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksQuaternion.FromAngularDisplacement(KS.Reactor.ksVector3)">
            <summary>Constructs a ksQuaternion from angular displacement.</summary>
            <param name="angularDisplacement"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksQuaternion.FromAngularDisplacementRadians(KS.Reactor.ksVector3)">
            <summary>Constructs a ksQuaternion from angular displacement.</summary>
            <param name="angularDisplacement">Angular displacement in radians.</param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksQuaternion.FromDirection(KS.Reactor.ksVector3)">
            <summary>
            Constructs a ksQuaternion from a forward direction, with ksVector3.Up as the up direction.
            </summary>
            <param name="forward">Forward direction.</param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksQuaternion.FromDirection(KS.Reactor.ksVector3,KS.Reactor.ksVector3)">
            <summary>Constructs a ksQuaternion from forward and up directions.</summary>
            <param name="forward">Forward direction.</param>
            <param name="up">Up direction.</param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksQuaternion.FromVectorDelta(KS.Reactor.ksVector3,KS.Reactor.ksVector3)">
            <summary>Constructs a ksQuaternion that rotates one vector to another.</summary>
            <param name="startDirection">Start direction.</param>
            <param name="endDirection">End direction.</param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksQuaternion.RotateByEuler(KS.Reactor.ksQuaternion,KS.Reactor.ksVector3)">
            <summary>Rotates a quaternion by euler angles.</summary>
            <param name="quaternion">Quaternion to rotate.</param>
            <param name="euler">Euler angles in degrees to rotate by.</param>
            <returns>Rotated quaternion.</returns>
        </member>
        <member name="M:KS.Reactor.ksQuaternion.RotateByEulerRadians(KS.Reactor.ksQuaternion,KS.Reactor.ksVector3)">
            <summary>Rotates a quaternion by euler angles.</summary>
            <param name="quaternion">Quaternion to rotate.</param>
            <param name="euler">Euler angles in radians to rotate by.</param>
            <returns>Rotated quaternion.</returns>
        </member>
        <member name="M:KS.Reactor.ksQuaternion.ToString">
            <summary>
            Gets the string representation of the vector.
            </summary>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksQuaternion.ToString(System.String)">
            <summary>Returns a string respresentation of the quaternion.</summary>
            <param name="format"></param>
            <returns>String representation of the quaternion.</returns>
        </member>
        <member name="M:KS.Reactor.ksQuaternion.ToString(System.IFormatProvider)">
            <summary>Returns a string respresentation of the quaternion.</summary>
            <param name="provider"></param>
            <returns>String representation of the quaternion.</returns>
        </member>
        <member name="M:KS.Reactor.ksQuaternion.DeltaDegrees(KS.Reactor.ksQuaternion,KS.Reactor.ksQuaternion)">
            <summary>Returns the angle in degrees between two quaternions.</summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns>Angle in degrees between a and b.</returns>
        </member>
        <member name="M:KS.Reactor.ksQuaternion.DeltaRadians(KS.Reactor.ksQuaternion,KS.Reactor.ksQuaternion)">
            <summary>Returns the angle in radians between two quaternions.</summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns>Angle in radians between a and b.</returns>
        </member>
        <member name="M:KS.Reactor.ksQuaternion.Dot(KS.Reactor.ksQuaternion,KS.Reactor.ksQuaternion)">
            <summary>Computes the dot product of two quaternions.</summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns>Dot product of a and b.</returns>
        </member>
        <member name="M:KS.Reactor.ksQuaternion.Lerp(KS.Reactor.ksQuaternion,KS.Reactor.ksQuaternion,System.Single)">
            <summary>Interpolates linearly between two quaternions.</summary>
            <param name="from">Quaternion to interpolate from.</param>
            <param name="to">Quaternion to interpolate to.</param>
            <param name="t">Value between 0 and 1 that determines the amount of interpolation.</param>
            <returns>Interpolated quaternion.</returns>
        </member>
        <member name="M:KS.Reactor.ksQuaternion.Slerp(KS.Reactor.ksQuaternion,KS.Reactor.ksQuaternion,System.Single)">
            <summary>Spherically interpolates between two quaternions.</summary>
            <param name="from">Quaternion to interpolate from.</param>
            <param name="to">Quaternion to interpolate to.</param>
            <param name="t">Value between 0 and 1 that determines the amount of interpolation.</param>
            <returns>Interpolated quaternion.</returns>
        </member>
        <member name="M:KS.Reactor.ksQuaternion.RotateTowards(KS.Reactor.ksQuaternion,KS.Reactor.ksQuaternion,System.Single)">
            <summary>Rotates a quaternion towards another.</summary>
            <param name="start">Start rotation.</param>
            <param name="target">Target to rotate towards.</param>
            <param name="deltaAngle">
            Delta angle in degrees to rotate. It will not overshoot the target.
            Negative values will rotate away from the target.
            </param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksQuaternion.RotateTowardsRadians(KS.Reactor.ksQuaternion,KS.Reactor.ksQuaternion,System.Single)">
            <summary>Rotates a quaternion towards another.</summary>
            <param name="start">Start rotation.</param>
            <param name="target">Target to rotate towards.</param>
            <param name="deltaAngle">
            Delta angle in radians to rotate. It will not overshoot the target.
            Negative values will rotate away from the target.
            </param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksQuaternion.AngularDisplacement(KS.Reactor.ksQuaternion,KS.Reactor.ksQuaternion)">
            <summary>Returns the angular displacement between two quaternions.</summary>
            <param name="start"></param>
            <param name="end"></param>
            <returns>Angular displacement between start and end in degrees.</returns>
        </member>
        <member name="M:KS.Reactor.ksQuaternion.AngularDisplacementRadians(KS.Reactor.ksQuaternion,KS.Reactor.ksQuaternion)">
            <summary>Returns the angular displacement between two quaternions.</summary>
            <param name="start"></param>
            <param name="end"></param>
            <returns>Angular displacement between start and end in radians.</returns>
        </member>
        <member name="M:KS.Reactor.ksQuaternion.AddAngularDisplacement(KS.Reactor.ksQuaternion,KS.Reactor.ksVector3)">
            <summary>Rotates a quaternion using angular displacement.</summary>
            <param name="quaternion">Quaternion to rotate.</param>
            <param name="angularDisplacement">Angular displacement in degrees.</param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksQuaternion.AddAngularDisplacementRadians(KS.Reactor.ksQuaternion,KS.Reactor.ksVector3)">
            <summary>Rotates a quaternion using angular displacement.</summary>
            <param name="quaternion">Quaternion to rotate.</param>
            <param name="angularDisplacement">Angular displacement in radians.</param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksQuaternion.op_UnaryNegation(KS.Reactor.ksQuaternion)">
            <summary>Quaternion unary - operator.</summary>
            <param name="q"></param>
            <returns>Result.</returns>
        </member>
        <member name="M:KS.Reactor.ksQuaternion.op_Multiply(KS.Reactor.ksQuaternion,KS.Reactor.ksQuaternion)">
            <summary>Quaternion multiplication.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns>Result.</returns>
        </member>
        <member name="M:KS.Reactor.ksQuaternion.op_Multiply(KS.Reactor.ksQuaternion,KS.Reactor.ksVector3)">
            <summary>Rotates a vector by a quaternion.</summary>
            <param name="rotation">Rotation to apply.</param>
            <param name="point">Point to rotate.</param>
            <returns>Rotated point.</returns>
        </member>
        <member name="M:KS.Reactor.ksQuaternion.op_Multiply(KS.Reactor.ksVector3,KS.Reactor.ksQuaternion)">
            <summary>Rotates a vector by a quaternion.</summary>
            <param name="point">Point to rotate.</param>
            <param name="rotation">Rotation to apply.</param>
            <returns>Rotated point.</returns>
        </member>
        <member name="M:KS.Reactor.ksQuaternion.op_Equality(KS.Reactor.ksQuaternion,KS.Reactor.ksQuaternion)">
            <summary>Checks if two quaternions are equal.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns>True if the quaternions are equal.</returns>
        </member>
        <member name="M:KS.Reactor.ksQuaternion.op_Inequality(KS.Reactor.ksQuaternion,KS.Reactor.ksQuaternion)">
            <summary>Checks if two quaternions are not equal.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns>True if the quaternions are not equal.</returns>
        </member>
        <member name="M:KS.Reactor.ksQuaternion.Equals(System.Object)">
            <summary>Checks if this quaternion is equal to an object.</summary>
            <param name="obj">Object to compare with this quaternion.</param>
            <returns>True if this quaternion is equal to the object.</returns>
        </member>
        <member name="M:KS.Reactor.ksQuaternion.Equals(KS.Reactor.ksQuaternion)">
            <summary>Checks if this quaternion is equal to another.</summary>
            <param name="other">Other quaternion to compare with.</param>
            <returns>True if the quaternions are equal.</returns>
        </member>
        <member name="M:KS.Reactor.ksQuaternion.GetHashCode">
            <summary>Gets the hash code for this quaternion.</summary>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksQuaternion.Normalized(KS.Reactor.ksQuaternion)">
            <summary>Normalizes a quaternion</summary>
            <param name="quaternion">Quaternion to normalize.</param>
            <returns>Normalized quaternion.</returns>
        </member>
        <member name="P:KS.Reactor.ksQuaternion.isValid">
            <summary>
            Checks if the quaternion is valid (the components are normalized).
            </summary>
        </member>
        <member name="M:KS.Reactor.ksQuaternion.op_Implicit(KS.Reactor.ksQuaternion)~UnityEngine.Quaternion">
            <summary>Implicit conversion from <see cref="T:KS.Reactor.ksQuaternion"/> to Unity <see cref="T:UnityEngine.Quaternion"/>.</summary>
            <param name="value">Reactor quaternion</param>
            <returns>Unity quaternion</returns>
        </member>
        <member name="M:KS.Reactor.ksQuaternion.op_Implicit(UnityEngine.Quaternion)~KS.Reactor.ksQuaternion">
            <summary>Implicit conversion from Unity <see cref="T:UnityEngine.Quaternion"/> to <see cref="T:KS.Reactor.ksQuaternion"/>.</summary>
            <param name="value">Unity quaternion</param>
            <returns>Reactor quaternion</returns>
        </member>
        <member name="M:KS.Reactor.ksQuaternion.op_Multiply(KS.Reactor.ksQuaternion,UnityEngine.Quaternion)">
            <summary>
            Quaternion multiplication with <see cref="T:KS.Reactor.ksQuaternion"/> and Unity <see cref="T:UnityEngine.Quaternion"/>.
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns><paramref name="rhs"/> rotated by <paramref name="lhs"/>.</returns>
        </member>
        <member name="M:KS.Reactor.ksQuaternion.op_Multiply(UnityEngine.Quaternion,KS.Reactor.ksQuaternion)">
            <summary>
            Quaternion multiplication with Unity <see cref="T:UnityEngine.Quaternion"/> and <see cref="T:KS.Reactor.ksQuaternion"/>.
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns><paramref name="rhs"/> rotated by <paramref name="lhs"/>.</returns>
        </member>
        <member name="M:KS.Reactor.ksQuaternion.op_Equality(KS.Reactor.ksQuaternion,UnityEngine.Quaternion)">
            <summary>Equality comparison with <see cref="T:KS.Reactor.ksQuaternion"/> and Unity <see cref="T:UnityEngine.Quaternion"/>.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns><paramref name="lhs"/> == <paramref name="rhs"/></returns>
        </member>
        <member name="M:KS.Reactor.ksQuaternion.op_Equality(UnityEngine.Quaternion,KS.Reactor.ksQuaternion)">
            <summary>Equality comparison with Unity <see cref="T:UnityEngine.Quaternion"/> and <see cref="T:KS.Reactor.ksQuaternion"/>.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns><paramref name="lhs"/> == <paramref name="rhs"/></returns>
        </member>
        <member name="M:KS.Reactor.ksQuaternion.op_Inequality(KS.Reactor.ksQuaternion,UnityEngine.Quaternion)">
            <summary>
            Inequality comparison with <see cref="T:KS.Reactor.ksQuaternion"/> and Unity <see cref="T:UnityEngine.Quaternion"/>.
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns><paramref name="lhs"/> != <paramref name="rhs"/></returns>
        </member>
        <member name="M:KS.Reactor.ksQuaternion.op_Inequality(UnityEngine.Quaternion,KS.Reactor.ksQuaternion)">
            <summary>
            Inequality comparison with Unity <see cref="T:UnityEngine.Quaternion"/> and <see cref="T:KS.Reactor.ksQuaternion"/>.
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns><paramref name="lhs"/> != <paramref name="rhs"/></returns>
        </member>
        <member name="T:KS.Reactor.ksQueryHitResults`1">
            <summary>Struct containing touching hits and the blocking hit results from a raycast or sweep query.</summary>
            <typeparam name="T">Query result type</typeparam>
        </member>
        <member name="P:KS.Reactor.ksQueryHitResults`1.HasBlock">
            <summary>Is there a blocking hit? See <see cref="F:KS.Reactor.ksQueryHitTypes.BLOCK"/></summary>
        </member>
        <member name="P:KS.Reactor.ksQueryHitResults`1.Block">
            <summary>
            The blocking hit. See <see cref="F:KS.Reactor.ksQueryHitTypes.BLOCK"/>. <see cref="P:KS.Reactor.ksIQueryHitResult.IsValid"/> will be
            false if there was no blocking hit. The setter sets <see cref="P:KS.Reactor.ksQueryHitResults`1.HasBlock"/> to
            <see cref="P:KS.Reactor.ksIQueryHitResult.IsValid"/>.
            </summary>
        </member>
        <member name="P:KS.Reactor.ksQueryHitResults`1.Touches">
            <summary>The list of touching hits. See <see cref="F:KS.Reactor.ksQueryHitTypes.TOUCH"/>.</summary>
        </member>
        <member name="P:KS.Reactor.ksQueryHitResults`1.Count">
            <summary>The total number of hits, including the blocking hit.</summary>
        </member>
        <member name="M:KS.Reactor.ksQueryHitResults`1.TryGetBlock(`0@)">
            <summary>Gets the blocking hit if there is one.</summary>
            <param name="block">Set to the blocking hit.</param>
            <returns>True if <see cref="P:KS.Reactor.ksQueryHitResults`1.HasBlock"/> is true.</returns>
        </member>
        <member name="M:KS.Reactor.ksQueryHitResults`1.SortByDistance">
            <summary>Sorts <see cref="P:KS.Reactor.ksQueryHitResults`1.Touches"/> by distance from nearest to farthest.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:KS.Reactor.ksQueryHitResults`1.GetEnumerator" -->
        <!-- Badly formed XML comment ignored for member "M:KS.Reactor.ksQueryHitResults`1.System#Collections#IEnumerable#GetEnumerator" -->
        <member name="T:KS.Reactor.ksRandom">
            <summary>
            Extends the built-in C# Random class with methods for generating floats, vectors, and quaternions.
            </summary>
        </member>
        <member name="P:KS.Reactor.ksRandom.Seed">
            <summary>Initial seed.</summary>
        </member>
        <member name="M:KS.Reactor.ksRandom.#ctor">
            <summary>Constructor. Initializes the seed to the microsecond timestamp.</summary>
        </member>
        <member name="M:KS.Reactor.ksRandom.#ctor(System.Int32)">
            <summary>Constructor.</summary>
            <param name="seed">Seed for pseudo-random sequence.</param>
        </member>
        <member name="M:KS.Reactor.ksRandom.NextFloat">
            <summary>Random value between 0 (inclusive) and 1 (exclusive).</summary>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksRandom.NextFloat(System.Single,System.Single)">
            <summary>Returns a random float within a range.</summary>
            <param name="min">Min value (inclusive).</param>
            <param name="max">Max value (exclusive)</param>
            <returns>Random number in the range.</returns>
        </member>
        <member name="M:KS.Reactor.ksRandom.NextUnitVector2">
            <summary>Random vector2 with magnitude 1.</summary>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksRandom.NextVector2">
            <summary>Random vector3 with magnitude less than 1.</summary>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksRandom.NextVector2(System.Single,System.Single)">
            <summary>Returns a random vector2 with magnitude within a range.</summary>
            <param name="minMagnitude">Min magnitude (inclusive).</param>
            <param name="maxMagnitude">Max magnitude (exclusive).</param>
            <returns>Random vector2 with magnitude within the range.</returns>
        </member>
        <member name="M:KS.Reactor.ksRandom.NextUnitVector3">
            <summary>Random vector3 with magnitude 1.</summary>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksRandom.NextVector3">
            <summary>Random vector3 with magnitude less than 1.</summary>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksRandom.NextVector3(System.Single,System.Single)">
            <summary>Returns a random vector3 with magnitude within a range.</summary>
            <param name="minMagnitude">Min magnitude(inclusive).</param>
            <param name="maxMagnitude">Max magnitude(exclusive).</param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksRandom.NextQuaternion">
            <summary>Random quaternion.</summary>
            <returns></returns>
        </member>
        <member name="T:KS.Reactor.ksRange">
            <summary>Defines a numerical range that wraps around.</summary>
        </member>
        <member name="P:KS.Reactor.ksRange.Degrees">
            <summary>Degrees (0 - 360).</summary>
        </member>
        <member name="P:KS.Reactor.ksRange.Radians">
            <summary>Radians (0 - 2PI).</summary>
        </member>
        <member name="P:KS.Reactor.ksRange.Min">
            <summary>Min value in the range (inclusive).</summary>
        </member>
        <member name="P:KS.Reactor.ksRange.Max">
            <summary>Max value in the range (exclusive).</summary>
        </member>
        <member name="M:KS.Reactor.ksRange.#ctor(System.Single,System.Single)">
            <summary>Constructor.</summary>
            <param name="min">Min value in the range (inclusive).</param>
            <param name="max">Max value in the range (exclusive).</param>
        </member>
        <member name="M:KS.Reactor.ksRange.SetRange(System.Single,System.Single)">
            <summary>Sets new min and max range values</summary>
            <param name="min">Min value in the range (inclusive).</param>
            <param name="max">Max value in the range (exclusive).</param>
        </member>
        <member name="M:KS.Reactor.ksRange.Wrap(System.Single)">
            <summary>
            Fits a value into the range. This is not a clamp--values outside the range will wrap around.
            </summary>
            <param name="value"></param>
            <returns>Value in range.</returns>
        </member>
        <member name="M:KS.Reactor.ksRange.Clamp(System.Single)">
            <summary>Clamps a value into the range.</summary>
            <param name="value"></param>
            <returns>Clamped value.</returns>
        </member>
        <member name="M:KS.Reactor.ksRange.Delta(System.Single,System.Single)">
            <summary>Calculates the shortest delta between two values.</summary>
            <param name="from"></param>
            <param name="to"></param>
            <returns>Delta between from and to.</returns>
        </member>
        <member name="M:KS.Reactor.ksRange.Slerp(System.Single,System.Single,System.Single)">
            <summary>Spherically interpolates between two values.</summary>
            <param name="from">Value to interpolate from.</param>
            <param name="to">Value to interpolate to.</param>
            <param name="t">Amount to interpolate between 0 and 1.</param>
            <returns>Interpolated value.</returns>
        </member>
        <member name="M:KS.Reactor.ksRange.MoveTowards(System.Single,System.Single,System.Single)">
            <summary>Moves a value towards another in the shorest direction.</summary>
            <param name="start">Start value.</param>
            <param name="target">Target to move towards.</param>
            <param name="distance">
            delta distance to move. It will not overshoot the target. Negative values will move away from the target.
            </param>
            <returns>Result.</returns>
        </member>
        <member name="T:KS.Reactor.ksRaycastParams">
            <summary>Parameters for raycast queries.</summary>
        </member>
        <member name="P:KS.Reactor.ksRaycastParams.Origin">
            <summary>Raycast origin</summary>
        </member>
        <member name="P:KS.Reactor.ksRaycastParams.Direction">
            <summary>Raycast direction</summary>
        </member>
        <member name="F:KS.Reactor.ksRaycastParams.Distance">
            <summary>Raycast distance</summary>
        </member>
        <member name="P:KS.Reactor.ksRaycastParams.End">
            <summary>The end-point of the raycast.</summary>
        </member>
        <member name="P:KS.Reactor.ksRaycastParams.QueryType">
            <summary>Query type</summary>
        </member>
        <member name="M:KS.Reactor.ksRaycastParams.#ctor">
            <summary>Constructor</summary>
        </member>
        <member name="M:KS.Reactor.ksRaycastParams.#ctor(KS.Reactor.ksVector3,KS.Reactor.ksVector3,System.Single,KS.Reactor.ksIQueryFilter,KS.Reactor.ksIEntity,KS.Reactor.ksQueryFlags)">
            <summary>Constructor</summary>
            <param name="origin">Raycast origin</param>
            <param name="direction">Raycast direction</param>
            <param name="distance">Raycast distance</param>
            <param name="filter">Query filter for filtering results.</param>
            <param name="excludeEntity">Exclude this entity from results.</param>
            <param name="flags">Query flags for filtering results.</param>
        </member>
        <member name="M:KS.Reactor.ksRaycastParams.#ctor(KS.Reactor.ksVector3,KS.Reactor.ksVector3,KS.Reactor.ksIQueryFilter,KS.Reactor.ksIEntity,KS.Reactor.ksQueryFlags)">
            <summary>Constructor</summary>
            <param name="origin">Raycast origin</param>
            <param name="end">Raycast end point</param>
            <param name="filter">Query filter for filtering results.</param>
            <param name="excludeEntity">Exclude this entity from results.</param>
            <param name="flags">Query flags for filtering results.</param>
        </member>
        <member name="M:KS.Reactor.ksRaycastParams.Validate(System.Boolean)">
            <summary>
            Checks if the parameters are valid. The parameters are invalid if
            <see cref="F:KS.Reactor.ksBaseQueryParams.Filter"/> is a <see cref="T:KS.Reactor.ksSimulationFilter"/>.
            </summary>
            <param name="log">If true, logs warnings describing what is invalid if anything is invalid.</param>
            <returns>True if the params are valid.</returns>
        </member>
        <member name="M:KS.Reactor.ksRaycastParams.CopyTo(KS.Reactor.ksRaycastParams)">
            <summary>Copies the values from this object to the <paramref name="target"/>.</summary>
            <param name="target">Target to copy to.</param>
        </member>
        <member name="T:KS.Reactor.ksRaycastResult">
            <summary>Result of an raycast scene query.</summary>
        </member>
        <member name="P:KS.Reactor.ksRaycastResult.Entity">
            <summary>Entity hit by the raycast.</summary>
        </member>
        <member name="P:KS.Reactor.ksRaycastResult.Collider">
            <summary>Collider hit by the raycast.</summary>
        </member>
        <member name="P:KS.Reactor.ksRaycastResult.Point">
            <summary>Point on the surface of the entity where the ray instersected</summary>
        </member>
        <member name="P:KS.Reactor.ksRaycastResult.Normal">
            <summary>Normal of the surface where the raycast point is.</summary>
        </member>
        <member name="P:KS.Reactor.ksRaycastResult.Distance">
            <summary>Distance along the raycast when the intersection was detected.</summary>
        </member>
        <member name="P:KS.Reactor.ksRaycastResult.IsValid">
            <summary>A raycast result is only valid if it includes an entity reference.</summary>
        </member>
        <member name="P:KS.Reactor.ksRaycastResult.IsInitialOverlap">
            <summary>Is the entity/collider overlapping with the raycast origin?</summary>
        </member>
        <member name="T:KS.Reactor.ksReflectionUtils">
            <summary>Reflection utility functions.</summary>
        </member>
        <member name="M:KS.Reactor.ksReflectionUtils.GetEditableMembers(System.Type,System.Boolean)">
            <summary>Gets all fields and properties tagged with ksEditable or ksUnityTag on a type.</summary>
            <param name="type">Type to get editable fields and properties from.</param>
            <param name="includeInherited">If true, will include editable members from base classes.</param>
            <returns>Editable fields and properties from the type.</returns>
        </member>
        <member name="M:KS.Reactor.ksReflectionUtils.GetCloneableMembers(System.Type)">
            <summary>
            Gets all fields and properties tagged with ksEditable, ksUnityTagAttribute, or ksCloneable on a type.
            </summary>
            <param name="type">Type to get cloneable fields and properties from.</param>
            <returns>Cloneable fields and properties from the type.</returns>
        </member>
        <member name="M:KS.Reactor.ksReflectionUtils.GetMembersWithAttribute(System.Type,System.Boolean,System.Type[])">
            <summary>Gets all fields and properties tagged with any of the given attributes on a type.</summary>
            <param name="type">Type to get tagged fields and properties from.</param>
            <param name="includeInherited">If true, will include tagged members from base classes.</param>
            <param name="attributes">
            Attributes to check for. Members are returned if they have at least one of this attributes.
            </param>
            <returns>Fields and properties that have any of the attributes.</returns>
        </member>
        <member name="M:KS.Reactor.ksReflectionUtils.HasAnyAttributes(System.Reflection.MemberInfo,System.Type[])">
            <summary>Checks if a member has any of the given attributes.</summary>
            <param name="member">Member to check for attributes.</param>
            <param name="attributes">Attributes to check for.</param>
            <returns>True if the member has any of the attributes.</returns>
        </member>
        <member name="M:KS.Reactor.ksReflectionUtils.GetType(System.Reflection.MemberInfo)">
            <summary>Gets the type of a field or property.</summary>
            <param name="memberInfo">MemberInfo to get type from.</param>
            <returns>Type of field or property.</returns>
        </member>
        <member name="M:KS.Reactor.ksReflectionUtils.GetValue(System.Object,System.Reflection.MemberInfo)">
            <summary>Gets the value of a field or property.</summary>
            <param name="script">Script containing the field or property.</param>
            <param name="memberInfo">MemberInfo for field or property.</param>
            <returns>Value of the field or property.</returns>
        </member>
        <member name="M:KS.Reactor.ksReflectionUtils.SetValue(System.Object,System.Reflection.MemberInfo,System.Object)">
            <summary>Sets the value of a field or property.</summary>
            <param name="script">Script containing the field or property.</param>
            <param name="memberInfo">MemberInfo for the field or property.</param>
            <param name="value">Value to set.</param>
        </member>
        <member name="M:KS.Reactor.ksReflectionUtils.Clone``1(``0)">
            <summary>
            Creates a copy of a script with the value of all members tagged with ksEditable or ksCloneable copied.
            Arrays, lists, and dictionaries are cloned. Other object references will reference the same object.
            </summary>
            <typeparam name="T">Script to clone.</typeparam>
            <param name="script">Cloned script.</param>
            <returns></returns>
        </member>
        <member name="T:KS.Reactor.ksRenamedFromAttribute">
            <summary>
            When you rename ksEditable fields or properties in server scripts, add this tag with the old name to preserve
            saved values.
            </summary>
        </member>
        <member name="P:KS.Reactor.ksRenamedFromAttribute.OldName">
            <summary>Old name of the field or property.</summary>
        </member>
        <member name="M:KS.Reactor.ksRenamedFromAttribute.#ctor(System.String)">
            <summary>Constructor.</summary>
            <param name="oldName">Old name of the field or property.</param>
        </member>
        <member name="T:KS.Reactor.ksRoomInfo">
            <summary>
            Holds room data that is available without connecting to the room,
            including data required to connect to the room.
            </summary>
        </member>
        <member name="T:KS.Reactor.ksRoomInfo.RoomState">
            <summary>Room load state.</summary>
        </member>
        <member name="P:KS.Reactor.ksRoomInfo.Image">
            <summary>Image.</summary>
        </member>
        <member name="P:KS.Reactor.ksRoomInfo.Id">
            <summary>Room id.</summary>
        </member>
        <member name="P:KS.Reactor.ksRoomInfo.Scene">
            <summary>Scene name.</summary>
        </member>
        <member name="P:KS.Reactor.ksRoomInfo.Type">
            <summary>Room type.</summary>
        </member>
        <member name="P:KS.Reactor.ksRoomInfo.Host">
            <summary>Host to connect to.</summary>
        </member>
        <member name="P:KS.Reactor.ksRoomInfo.Port">
            <summary>Port to connect to.</summary>
        </member>
        <member name="P:KS.Reactor.ksRoomInfo.Name">
            <summary>Room name.</summary>
        </member>
        <member name="P:KS.Reactor.ksRoomInfo.IsPublic">
            <summary>Is public?</summary>
        </member>
        <member name="P:KS.Reactor.ksRoomInfo.KeepAlive">
            <summary>Keep alive?</summary>
        </member>
        <member name="P:KS.Reactor.ksRoomInfo.State">
            <summary>Server state.</summary>
        </member>
        <member name="P:KS.Reactor.ksRoomInfo.PublicTags">
            <summary>Public tags.</summary>
        </member>
        <member name="P:KS.Reactor.ksRoomInfo.PublicData">
            <summary>Public data.</summary>
        </member>
        <member name="M:KS.Reactor.ksRoomInfo.#ctor">
            <summary>Constructor.</summary>
        </member>
        <member name="M:KS.Reactor.ksRoomInfo.#ctor(KS.Reactor.ksRoomInfo)">
            <summary>Copy Constructor.</summary>
            <param name="copy">Room info to copy from.</param>
        </member>
        <member name="M:KS.Reactor.ksRoomInfo.#ctor(System.String,System.UInt16)">
            <summary>Constructor.</summary>
            <param name="host">Host to connect to.</param>
            <param name="port">Port to connect to.</param>
        </member>
        <member name="M:KS.Reactor.ksRoomInfo.ToJSON">
            <summary>Creates a ksJSON object of this room info.</summary>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksRoomInfo.FromJSON(KS.Reactor.ksJSON)">
            <summary>Initialize the room info using a json.</summary>
            <param name="json"></param>
            <returns>False if the json failed to contain the required fields.</returns>
        </member>
        <member name="M:KS.Reactor.ksRoomInfo.GetBytes">
            <summary>Serializes the room info to a byte array.</summary>
            <returns>Serialized room info.</returns>
        </member>
        <member name="M:KS.Reactor.ksRoomInfo.FromBytes(System.Byte[])">
            <summary>Deserializes the room info from a byte array.</summary>
            <param name="data">Data to deserialize.</param>
        </member>
        <member name="M:KS.Reactor.ksRoomInfo.op_Implicit(KS.Reactor.ksRoomInfo)~KS.Reactor.ksMultiType">
            <summary>Implicit conversion from ksRoomInfo to ksMultiType.</summary>
            <param name="info"></param>
        </member>
        <member name="M:KS.Reactor.ksRoomInfo.op_Implicit(KS.Reactor.ksMultiType)~KS.Reactor.ksRoomInfo">
            <summary>Implicit conversion from ksMultiType to ksRoomInfo.</summary>
            <param name="multiType"></param>
        </member>
        <member name="M:KS.Reactor.ksRoomInfo.ToString">
            <summary>
            Returns a brief summary of the ksRoomInfo object including id, scene and room type.
            </summary>
            <returns></returns>
        </member>
        <member name="T:KS.Reactor.ksRPCAttribute">
            <summary>Attribute used to mark RPC handlers on room and entity scripts.</summary>
        </member>
        <member name="P:KS.Reactor.ksRPCAttribute.ExecuteOnMainThread">
            <summary>When this is true the RPC will be executed on the main thread.</summary>
        </member>
        <member name="P:KS.Reactor.ksRPCAttribute.Id">
            <summary>Get the RPC ID.</summary>
        </member>
        <member name="M:KS.Reactor.ksRPCAttribute.#ctor(System.UInt32)">
            <summary>Constructor.</summary>
            <param name="id">RPC ID.</param>
        </member>
        <member name="M:KS.Reactor.ksRPCAttribute.#ctor(System.UInt32,System.Boolean)">
            <summary>Constructor.</summary>
            <param name="id">RPC ID.</param>
            <param name="executeOnMainThread">When true, the RPC will be excuted on the main thread.</param>
        </member>
        <member name="T:KS.Reactor.ksRPCManager`1">
            <summary>
            Manages the registration, storing and invocation of methods tagged with ksRPCAttributes.
            </summary>
            <typeparam name="Attribute"></typeparam>
        </member>
        <member name="P:KS.Reactor.ksRPCManager`1.Instance">
            <summary>Singleton instance</summary>
        </member>
        <member name="M:KS.Reactor.ksRPCManager`1.SetValidSubclasses(System.Type[])">
            <summary>
            Set the valid types all RPC methods owner must be a subclass of.
            If no subclass types are set, then all types are allowed.
            </summary>
            <param name="types">Valid subclass types.</param>
        </member>
        <member name="M:KS.Reactor.ksRPCManager`1.PrintValidClasses">
            <summary>Print a list of valid subclasses</summary>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksRPCManager`1.RegisterAssemblyRPCs(System.Reflection.Assembly)">
            <summary>
            Search an assembly and register all instance methods tagged with a ksRPCAttribute.
            </summary>
            <param name="assembly">Assembly to search.</param>
        </member>
        <member name="M:KS.Reactor.ksRPCManager`1.RegisterTypeRPCs(System.Type)">
            <summary>Searches a type and register all instance methods tagged with a ksRPCAttribute</summary>
            <param name="type">Type to search</param>
        </member>
        <member name="M:KS.Reactor.ksRPCManager`1.RegisterRPC(System.UInt32,System.Boolean,System.Reflection.MethodInfo)">
            <summary>Registers an RPC method.</summary>
            <param name="id">RPC ID</param>
            <param name="executeOnMainThread">RPC should be executed on the main thread.</param>
            <param name="method">RPC method.</param>
        </member>
        <member name="M:KS.Reactor.ksRPCManager`1.HasRegisteredRPC(System.UInt32)">
            <summary>Checks if at least one RPC handler has been registered for a specific RPC ID.</summary>
            <param name="id">RPC ID.</param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksRPCManager`1.InvokeRPC``1(System.UInt32,System.Object,System.Type,``0,KS.Reactor.ksMultiType[],System.Boolean)">
            <summary>Invoke an RPC on a target object from source T.</summary>
            <typeparam name="T"></typeparam>
            <param name="id">RPC ID.</param>
            <param name="target">Target type</param>
            <param name="targetType">Target to invoke on.</param>
            <param name="source">Source of the rpc (player, server, etc).</param>
            <param name="args">RPC arguments.</param>
            <param name="executeOnMainThread">RPC should be executed on the main thread.</param>
            <returns>True if registered RPCs were found and invoked.</returns>
        </member>
        <member name="T:KS.Reactor.ksRPCManager`1.RPC">
            <summary>
            This class contains all the required information to quickly invoke an RPC method.
            method parameter types are extracted, and the object[] arg array is pre-allocated, during construction
            to reduce overhead during invocation.
            </summary>
        </member>
        <member name="P:KS.Reactor.ksRPCManager`1.RPC.ExecuteOnMainThread">
            <summary>Should this RPC be executed on the main thread.</summary>
        </member>
        <member name="M:KS.Reactor.ksRPCManager`1.RPC.#ctor(System.UInt32,System.Boolean,System.Reflection.MethodInfo)">
            <summary>Constructs a new RPC handler.</summary>
            <param name="id">RPC ID.</param>
            <param name="executeOnMainThread">RPC should be executed on the main thread.</param>
            <param name="method">RPC method.</param>
        </member>
        <member name="M:KS.Reactor.ksRPCManager`1.RPC.Invoke``1(System.Object,``0,KS.Reactor.ksMultiType[])">
            <summary>Invokes the RPC method on a target object.</summary>
            <typeparam name="T"></typeparam>
            <param name="target">Target to invoke on.</param>
            <param name="source">Source of the rpc call (player, server, etc).</param>
            <param name="args">RPC arguments.</param>
        </member>
        <member name="T:KS.Reactor.ksScript`2">
            <summary>Base class for Reactor scripts.</summary>
            <typeparam name="Parent">Type the script can be attached to.</typeparam>
            <typeparam name="Script">Type of script this is.</typeparam>
        </member>
        <member name="T:KS.Reactor.ksScript`2.IInternals">
            <summary>
            Internal interface. These members are hidden unless the class is cast to this interface.
            </summary>
        </member>
        <member name="P:KS.Reactor.ksScript`2.InstanceType">
            <summary>Gets the most derived type of this script.</summary>
        </member>
        <member name="P:KS.Reactor.ksScript`2.IsAttached">
            <summary>Is the script attached?</summary>
        </member>
        <member name="P:KS.Reactor.ksScript`2.Scripts">
            <summary>List this script is in.</summary>
        </member>
        <member name="P:KS.Reactor.ksScript`2.Assets">
            <summary>Asset loader.</summary>
        </member>
        <member name="M:KS.Reactor.ksScript`2.Attached">
            <summary>
            Called immediately when the script is attached. Other scripts may not be attached or have their ksEditable
            field loaded yet, so it is not safe to access other scripts. Initialization that depends on other scripts
            should be done from <see cref="M:KS.Reactor.ksScript`2.Initialize"/>. <see cref="M:KS.Reactor.ksScript`2.Attached"/> is called on each script in the order
            they were configured.
            </summary>
        </member>
        <member name="M:KS.Reactor.ksScript`2.Initialize">
            <summary>
            Called after all other scripts on all entities are attached. <see cref="M:KS.Reactor.ksScript`2.Initialize"/> is called on each
            script in the order they were configured.
            </summary>
        </member>
        <member name="M:KS.Reactor.ksScript`2.Detached">
            <summary>
            Called when the script is detached. Remove event listeners and perform other clean up logic here.
            </summary>
        </member>
        <member name="M:KS.Reactor.ksScript`2.Clone">
            <summary>
            Creates a copy of the script with the value of all members tagged with ksEditable or ksCloneable copied.
            Arrays, lists, and dictionaries are cloned. Other object references will reference the same object.
            </summary>
            <returns>Cloned script.</returns>
        </member>
        <member name="P:KS.Reactor.ksScript`2.KS#Reactor#ksScript{Parent,Script}#IInternals#Parent">
            <summary>The parent object this script is attached to.</summary>
        </member>
        <member name="T:KS.Reactor.ksScriptAsset">
            <summary>Base class for scripts that can be loaded from assets.</summary>
        </member>
        <member name="P:KS.Reactor.ksScriptAsset.Assets">
            <summary>Asset loader singleton. Set this to supply a custom asset loader.</summary>
        </member>
        <member name="P:KS.Reactor.ksScriptAsset.AssetId">
            <summary>The id of the asset. Zero means it is not an asset.</summary>
        </member>
        <member name="P:KS.Reactor.ksScriptAsset.AssetPath">
            <summary>The asset path.</summary>
        </member>
        <member name="P:KS.Reactor.ksScriptAsset.IsPrefab">
            <summary>
            Is this a prefab asset? If true, this is the asset returned by
            <see cref="M:KS.Reactor.ksBaseAssetLoader.Get``1(System.UInt32,System.Boolean)"/>.
            </summary>
        </member>
        <member name="P:KS.Reactor.ksScriptAsset.AssetName">
            <summary>
            The name of the asset. This is the part of the <see cref="P:KS.Reactor.ksScriptAsset.AssetPath"/> after the last '/'.
            </summary>
        </member>
        <member name="M:KS.Reactor.ksScriptAsset.Finalize">
            <summary>Removes the asset from the cache when it is garbage collected.</summary>
        </member>
        <member name="M:KS.Reactor.ksScriptAsset.Clone">
            <summary>
            Creates a copy of the script with the value of all members tagged with ksEditable or ksCloneable copied.
            Arrays, lists, and dictionaries are cloned. Other object references will reference the same object.
            </summary>
        </member>
        <member name="T:KS.Reactor.ksScriptList`2">
            <summary>A templated list of scripts.</summary>
            <typeparam name="Parent">The type the scripts are attached to.</typeparam>
            <typeparam name="Script">The script type.</typeparam>
        </member>
        <member name="P:KS.Reactor.ksScriptList`2.Initialized">
            <summary>
            Are the scripts initialized? If true, new scripts will be initialized when they are attached.
            </summary>
        </member>
        <member name="P:KS.Reactor.ksScriptList`2.Count">
            <summary>Number of scripts in the list.</summary>
        </member>
        <member name="P:KS.Reactor.ksScriptList`2.Item(System.Int32)">
            <summary>Access the list by index.</summary>
        </member>
        <member name="M:KS.Reactor.ksScriptList`2.#ctor(`0)">
            <summary>Constructor.</summary>
            <param name="parent">Parent to attach scripts to.</param>
        </member>
        <member name="M:KS.Reactor.ksScriptList`2.GetEnumerator">
            <summary>Gets the enumerator for the list.</summary>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksScriptList`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>Gets the enumerator for the list.</summary>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksScriptList`2.Attach(`1)">
            <summary>
            Attaches a script. If the script is already attached somewhere, it is detached first.
            </summary>
            <param name="script">Script to attach.</param>
        </member>
        <member name="M:KS.Reactor.ksScriptList`2.Attach(`1,System.Boolean)">
            <summary>
            Attaches a script. If the script is already attached somewhere, it is detached first.
            </summary>
            <param name="script">Script to attach.</param>
            <param name="nextIndex">
            If true, will insert the script after current iteration index and advances the current interation index. If
            false, the script is appended to the end of the list. This is used to preserve config script order when
            config scripts attach or detach scripts from their <see cref="M:KS.Reactor.ksScript`2.Attached"/> method.
            </param>
        </member>
        <member name="M:KS.Reactor.ksScriptList`2.Detach(`1)">
            <summary>Detaches a script.</summary>
            <param name="script">Script to detach.</param>
            <returns>True if the script was found.</returns>
        </member>
        <member name="M:KS.Reactor.ksScriptList`2.Detach``1">
            <summary>Detaches a script of the template type.</summary>
            <typeparam name="T"></typeparam>
            <returns>Removed script, or null if no script of that type was found.</returns>
        </member>
        <member name="M:KS.Reactor.ksScriptList`2.DetachAll``1(System.Boolean)">
            <summary>Detaches all scripts of the template type.</summary>
            <typeparam name="T"></typeparam>
            <param name="allowAttachingScripts">
            When false new scripts cannot be attached while other scripts are being removed.
            </param>
        </member>
        <member name="M:KS.Reactor.ksScriptList`2.DetachAll(System.Boolean)">
            <summary>Detaches all scripts.</summary>
            <param name="allowAttachingScripts">
            When false new scripts cannot be attached while other scripts are being removed.
            </param>
        </member>
        <member name="M:KS.Reactor.ksScriptList`2.Get``1">
            <summary>
            Gets the first script of type T or null if not found.
            </summary>
            <typeparam name="T"></typeparam>
            <returns>A script of the template type, or null if the script is not found.</returns>
        </member>
        <member name="M:KS.Reactor.ksScriptList`2.GetAll``1">
            <summary>Gets all scripts of type T.</summary>
            <typeparam name="T"></typeparam>
            <returns>Script list.</returns>
        </member>
        <member name="M:KS.Reactor.ksScriptList`2.InitializeAll">
            <summary>
            Initializes all scripts. Subsequent scripts will be initialized when they're attached.
            </summary>
        </member>
        <member name="T:KS.Reactor.ksServerAPI">
            <summary>Implementation for the KSPlayerAPI calls made with server credentials.</summary>
        </member>
        <member name="T:KS.Reactor.ksServerAPI.Session">
            <summary>Player session information use for validation and player tracking.</summary>
        </member>
        <member name="T:KS.Reactor.ksServerAPI.ResponseState`1">
            <summary>Response state that contains the callback and other async data.</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:KS.Reactor.ksServerAPI.ResponseState`1.#ctor(`0,System.Object)">
            <summary>Constructor.</summary>
            <param name="callback"></param>
            <param name="asyncState">Async state object.</param>
        </member>
        <member name="T:KS.Reactor.ksServerAPI.GenericCallback">
            <summary>Generic callback with no return data.</summary>
            <param name="error">Error message.</param>
            <param name="asyncState">Async state object.</param>
        </member>
        <member name="T:KS.Reactor.ksServerAPI.RequestHandler">
            <summary>Web request handler for API calls.</summary>
            <param name="url">URL.</param>
            <param name="headers">Additional request headers.</param>
            <param name="method">Request method.</param>
            <param name="data">POST request data.</param>
            <param name="onComplete">Request callback.</param>
            <param name="stateObject">State object returned in the callback.</param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksServerAPI.#ctor(KS.Reactor.ksServerAPI.RequestHandler)">
            <summary>Constructor.</summary>
            <param name="requestFactory">Optional request handling method.</param>
        </member>
        <member name="M:KS.Reactor.ksServerAPI.DefaultRequestHandler(System.String,System.Net.WebHeaderCollection,System.String,KS.Reactor.ksJSON,KS.Reactor.ksWebResponse.Handler,System.Object)">
            <summary>Web request handler for API calls.</summary>
            <param name="url">URL.</param>
            <param name="headers">Additional request headers.</param>
            <param name="method">Request method.</param>
            <param name="data">POST request data.</param>
            <param name="onComplete">Request callback.</param>
            <param name="stateObject">State object returned in the callback.</param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksServerAPI.Initialize(System.String,System.String,System.String)">
            <summary>Initializes the API object.</summary>
            <param name="APIURL">Player API url.</param>
            <param name="APIKey">Project ID.</param>
            <param name="APISecret">Project client secret.</param>
        </member>
        <member name="M:KS.Reactor.ksServerAPI.AuthenticatePlayer(KS.Reactor.ksServerAPI.Session,KS.Reactor.ksServerAPI.GenericCallback,System.Object)">
            <summary>Authenticate a player session.</summary>
            <param name="session">Session to authenticate.</param>
            <param name="callback">Asynchronous callback.</param>
            <param name="asyncState">State object returned in the callback.</param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksServerAPI.OnAuthenticate(KS.Reactor.ksWebResponse)">
            <summary>Handles session authentication responses.</summary>
            <param name="response">Authentication response.</param>
        </member>
        <member name="M:KS.Reactor.ksServerAPI.GenerateHeaders">
            <summary>Generates the headers required for a ksServerAPI request.</summary>
            <returns></returns>
        </member>
        <member name="T:KS.Reactor.ksShape">
            <summary>A base class of the shapes used in the scene queries.</summary>
        </member>
        <member name="T:KS.Reactor.ksShape.ShapeTypes">
            <summary>Support shapes for scene queries.</summary>
        </member>
        <member name="T:KS.Reactor.ksShape.Axis">
            <summary>Axis used for revolute shapes (capsule, cylinder, cones).</summary>
        </member>
        <member name="P:KS.Reactor.ksShape.Type">
            <summary>Type of shape.</summary>
        </member>
        <member name="P:KS.Reactor.ksShape.IsQueryShape">
            <summary>Is the shape usable in scene queries?</summary>
        </member>
        <member name="P:KS.Reactor.ksShape.Geometry">
            <summary>PhysX Geometry</summary>
        </member>
        <member name="T:KS.Reactor.ksSphere">
            <summary>Sphere.</summary>
        </member>
        <member name="M:KS.Reactor.ksSphere.#ctor(System.Single)">
            <summary>Constructs a sphere with a given radius.</summary>
            <param name="radius"></param>
        </member>
        <member name="P:KS.Reactor.ksSphere.Radius">
            <summary>Gets/Sets the sphere radius.</summary>
        </member>
        <member name="T:KS.Reactor.ksBox">
            <summary>Box.</summary>
        </member>
        <member name="M:KS.Reactor.ksBox.#ctor(System.Single,System.Single,System.Single)">
            <summary>Constructs a box with dimensions x, y, z.</summary>
            <param name="x">X size.</param>
            <param name="y">Y size.</param>
            <param name="z">Z size.</param>
        </member>
        <member name="M:KS.Reactor.ksBox.#ctor(KS.Reactor.ksVector3)">
            <summary>Constructs a box with ksVector3.</summary>
            <param name="size"></param>
        </member>
        <member name="P:KS.Reactor.ksBox.Size">
            <summary>Size.</summary>
        </member>
        <member name="P:KS.Reactor.ksBox.HalfExtents">
            <summary>Half extents.</summary>
        </member>
        <member name="T:KS.Reactor.ksCapsule">
            <summary>Capsule.</summary>
        </member>
        <member name="M:KS.Reactor.ksCapsule.#ctor(System.Single,System.Single,KS.Reactor.ksShape.Axis)">
            <summary>Constructs a capsule aligned along an axis.</summary>
            <param name="radius">Raidus.</param>
            <param name="height">Total height including caps.</param>
            <param name="alignment">Axis.</param>
        </member>
        <member name="P:KS.Reactor.ksCapsule.Radius">
            <summary>Radius.</summary>
        </member>
        <member name="P:KS.Reactor.ksCapsule.Height">
            <summary>Height.</summary>
        </member>
        <member name="P:KS.Reactor.ksCapsule.CylinderHalfHeight">
            <summary>Half height of the cylinder part.</summary>
        </member>
        <member name="P:KS.Reactor.ksCapsule.Alignment">
            <summary>Alignment.</summary>
        </member>
        <member name="T:KS.Reactor.ksSharedDataAttribute">
            <summary>
            Server scripts tagged with this will not have their editable field data stripped from their proxy scripts in
            client builds. This tag applies to all derived scripts.
            </summary>
        </member>
        <member name="T:KS.Reactor.ksSimulationFilter">
            <summary>
            A query filter that uses the query collider's collision filter rules. Use this with entity queries to use the
            entity's colliders' collision filters as the filter. Colliders that collide with the query collider will
            <see cref="F:KS.Reactor.ksQueryHitTypes.BLOCK"/>, and colliders that do not collide but do belong to one of the query
            collider's notify groups will <see cref="F:KS.Reactor.ksQueryHitTypes.TOUCH"/>. Excludes non-trigger non-simulation
            colliders from results. Cannot be used for shape queries or raycasts.
            
            This also implements <see cref="T:KS.Reactor.ksIEntityQueryColliderFilter"/>. Set this as the
            <see cref="F:KS.Reactor.ksOverlapParams.EntityColliderFilter"/> for entity queries to exclude the entity's non-trigger
            non-simulation colliders from being queried.
            </summary>
        </member>
        <member name="M:KS.Reactor.ksSimulationFilter.Filter(KS.Reactor.ksICollider,KS.Reactor.ksICollider,KS.Reactor.ksQueryResultTypes,KS.Reactor.ksBaseQueryParams)">
            <summary>
            Determines if a potential collider hit should be included in query results and whether it is a blocking or
            touching hit.
            </summary>
            <param name="queryCollider">The collider used in the query. Null for shape queries.</param>
            <param name="hitCollider">The collider being evaluated for a hit.</param>
            <param name="resultType">What kind of results the query returns</param>
            <param name="args">Query parameters</param>
            <returns>Hit type</returns>
        </member>
        <member name="M:KS.Reactor.ksSimulationFilter.Filter(KS.Reactor.ksICollider,KS.Reactor.ksOverlapParams)">
            <summary>
            Determines if <paramref name="queryCollider"/> should be used to run a query. If the collider is a trigger,
            returns false if touches are excluded. Returns false for non-trigger non-simulation colliders.
            </summary>
            <param name="queryCollider">The collider we are checking if we should run a query for.</param>
            <param name="args">Query parameters</param>
            <returns>True if the query should run.</returns>
        </member>
        <member name="T:KS.Reactor.ksStreamBuffer">
            <summary>Manages a buffer for reading and writing stream data toa byte array.</summary>
        </member>
        <member name="M:KS.Reactor.ksStreamBuffer.Create">
            <summary>
            Fetches a ksStreamBuffer from a pool of available buffers or
            create a new ksStreamBuffer if the pool is empty.
            </summary>
            <returns></returns>
        </member>
        <member name="P:KS.Reactor.ksStreamBuffer.Array">
            <summary>
            Byte array managed by the stream buffer.
            Note: active buffers may only be using up to Count bytes of this array.
            </summary>
        </member>
        <member name="P:KS.Reactor.ksStreamBuffer.Count">
            <summary>Amount of data in the managed array used by the buffer.</summary>
        </member>
        <member name="P:KS.Reactor.ksStreamBuffer.Offset">
            <summary>
            Current position of the cursor in the buffer.
            All read/write operations will access the managed array at this position.
            </summary>
        </member>
        <member name="M:KS.Reactor.ksStreamBuffer.Clear(System.Boolean)">
            <summary>Clears all data from the buffer.</summary>
            <param name="zero">If this is true, all bytes in the managed array will be set to 0.</param>
        </member>
        <member name="M:KS.Reactor.ksStreamBuffer.ResizeBuffer(System.Int32)">
            <summary>Resizes and zeros the used portion of the manage array.</summary>
            <param name="size">New size.</param>
        </member>
        <member name="M:KS.Reactor.ksStreamBuffer.Write(System.Byte)">
            <summary>Writes a byte value at the current buffer offset.</summary>
            <param name="value"></param>
        </member>
        <member name="M:KS.Reactor.ksStreamBuffer.Write(System.Byte[])">
            <summary>Writes a byte array at the current buffer offset.</summary>
            <param name="value"></param>
        </member>
        <member name="M:KS.Reactor.ksStreamBuffer.Write``1(``0)">
            <summary>Writes a struct at the current buffer offset.</summary>
            <typeparam name="T"></typeparam>
            <param name="value"></param>
        </member>
        <member name="M:KS.Reactor.ksStreamBuffer.Read">
            <summary>Reads the byte at the current buffer offset.</summary>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksStreamBuffer.ReadBytes(System.Int32)">
            <summary>Reads multiple bytes at the current buffer offset.</summary>
            <param name="count">Number of bytes to read (-1 = up to the end of the buffer).</param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksStreamBuffer.Read``1">
            <summary>Reads the struct at the current buffer offset.</summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksStreamBuffer.TryGetSegment(KS.Reactor.ksStreamBuffer.Segment@,System.Int32,System.Int32)">
            <summary>Attempts to get a segment of the buffer.</summary>
            <param name="segment">Segement of buffer.</param>
            <param name="offset">Segment start index.</param>
            <param name="count">Segment size (-1 up to the end of the buffer).</param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksStreamBuffer.Release">
            <summary>Releases the buffer and put it pool of available buffers.</summary>
        </member>
        <member name="T:KS.Reactor.ksStreamBuffer.Segment">
            <summary>
            Represents a segment of a ksStreamBuffer.
            While a segment is not released, the buffer cannot be written to or released.
            </summary>
        </member>
        <member name="M:KS.Reactor.ksStreamBuffer.Segment.#ctor(KS.Reactor.ksStreamBuffer,System.Byte[],System.Int32,System.Int32)">
            <summary>Constructor.</summary>
            <param name="owner">Buffer this segment belongs to.</param>
            <param name="buffer">Source byte array.</param>
            <param name="offset">Offset in the byte array.</param>
            <param name="count">Number of bytes.</param>
        </member>
        <member name="P:KS.Reactor.ksStreamBuffer.Segment.Array">
            <summary>Byte array managed by the segment.</summary>
        </member>
        <member name="P:KS.Reactor.ksStreamBuffer.Segment.Count">
            <summary>Size of the buffer segment.</summary>
        </member>
        <member name="P:KS.Reactor.ksStreamBuffer.Segment.Offset">
            <summary>Offset in the referenced byte array.</summary>
        </member>
        <member name="M:KS.Reactor.ksStreamBuffer.Segment.Release">
            <summary>Releases the segement back to the buffer.</summary>
        </member>
        <member name="F:KS.Reactor.ksSweepParams.Distance">
            <summary>Sweep distance</summary>
        </member>
        <member name="M:KS.Reactor.ksSweepParams.#ctor">
            <summary>Default constructor</summary>
        </member>
        <member name="P:KS.Reactor.ksSweepParams.QueryType">
            <summary>Query type</summary>
        </member>
        <member name="P:KS.Reactor.ksSweepParams.Direction">
            <summary>Sweep direction</summary>
        </member>
        <member name="P:KS.Reactor.ksSweepParams.End">
            <summary>Sweep distance</summary>
            <summary>The end-point of the sweep.</summary>
        </member>
        <member name="M:KS.Reactor.ksSweepParams.#ctor(KS.Reactor.ksShape,KS.Reactor.ksVector3,KS.Reactor.ksQuaternion,KS.Reactor.ksVector3,System.Single,KS.Reactor.ksIQueryFilter,KS.Reactor.ksIEntity,KS.Reactor.ksQueryFlags)">
            <summary>Construct a shape sweep using an origin point, direction and distance.</summary>
            <param name="shape">Sweep shape</param>
            <param name="origin">Sweep origin</param>
            <param name="rotation">Shape rotation</param>
            <param name="direction">Sweep direction</param>
            <param name="distance">Sweep distance</param>
            <param name="filter">Query filter for filtering results.</param>
            <param name="excludeEntity">Exclude this entity from results.</param>
            <param name="flags">Query flags for filtering results.</param>
        </member>
        <member name="M:KS.Reactor.ksSweepParams.#ctor(KS.Reactor.ksShape,KS.Reactor.ksVector3,KS.Reactor.ksVector3,KS.Reactor.ksQuaternion,KS.Reactor.ksIQueryFilter,KS.Reactor.ksIEntity,KS.Reactor.ksQueryFlags)">
            <summary>Construct a shape sweep using an origin and end point.</summary>
            <param name="shape">Sweep shape</param>
            <param name="origin">Sweep origin</param>
            <param name="end">Sweep end point</param>
            <param name="rotation">Shape rotation</param>
            <param name="filter">Query filter for filtering results.</param>
            <param name="excludeEntity">Exclude this entity from results.</param>
            <param name="flags">Query flags for filtering results.</param>
        </member>
        <member name="M:KS.Reactor.ksSweepParams.#ctor(KS.Reactor.ksIEntity,KS.Reactor.ksVector3,System.Single,KS.Reactor.ksIQueryFilter,KS.Reactor.ksIEntityQueryColliderFilter,System.Boolean,KS.Reactor.ksQueryFlags)">
            <summary>
            Construct an entity sweep from the entity position and sweeping over a direction and distance.
            </summary>
            <param name="entity">Sweep entity</param>
            <param name="direction">Sweep direction</param>
            <param name="distance">Sweep distance</param>
            <param name="filter">Query filter for filtering results.</param>
            <param name="colliderFilter">
            Query collider filter for filtering which of the entity's colliders to query with.
            </param>
            <param name="excludeSelf">Should <paramref name="entity"/> be excluded from results?</param>
            <param name="flags">Query flags for filtering results.</param>
        </member>
        <member name="M:KS.Reactor.ksSweepParams.#ctor(KS.Reactor.ksIEntity,KS.Reactor.ksVector3,KS.Reactor.ksIQueryFilter,KS.Reactor.ksIEntityQueryColliderFilter,System.Boolean,KS.Reactor.ksQueryFlags)">
            <summary>Construct an entity sweep from the entity position and sweeping to an end point.</summary>
            <param name="entity">Sweep entity</param>
            <param name="end">Sweep end point</param>
            <param name="filter">Query filter for filtering results.</param>
            <param name="colliderFilter">
            Query collider filter for filtering which of the entity's colliders to query with.
            </param>
            <param name="excludeSelf">Should <paramref name="entity"/> be excluded from results?</param>
            <param name="flags">Query flags for filtering results.</param>
        </member>
        <member name="M:KS.Reactor.ksSweepParams.#ctor(KS.Reactor.ksIEntity,KS.Reactor.ksVector3,KS.Reactor.ksQuaternion,KS.Reactor.ksVector3,System.Single,KS.Reactor.ksIQueryFilter,KS.Reactor.ksIEntityQueryColliderFilter,System.Boolean,KS.Reactor.ksQueryFlags)">
            <summary>
            Construct an entity sweep from a specified origin and rotation and sweeping over a direction and distance.
            </summary>
            <param name="entity">Sweep entity</param>
            <param name="origin">Sweep origin</param>
            <param name="rotation">Sweep rotation</param>
            <param name="direction">Sweep direction</param>
            <param name="distance">Sweep distance</param>
            <param name="filter">Query filter for filtering results.</param>
            <param name="colliderFilter">
            Query collider filter for filtering which of the entity's colliders to query with.
            </param>
            <param name="excludeSelf">Should <paramref name="entity"/> be excluded from results?</param>
            <param name="flags">Query flags for filtering results.</param>
        </member>
        <member name="M:KS.Reactor.ksSweepParams.#ctor(KS.Reactor.ksIEntity,KS.Reactor.ksVector3,KS.Reactor.ksVector3,KS.Reactor.ksQuaternion,KS.Reactor.ksIQueryFilter,KS.Reactor.ksIEntityQueryColliderFilter,System.Boolean,KS.Reactor.ksQueryFlags)">
            <summary>
            Construct an entity sweep from a specified origin and rotation and sweeping to an end point.
            </summary>
            <param name="entity">Sweep entity</param>
            <param name="origin">Sweep origin</param>
            <param name="end">Sweep end point</param>
            <param name="rotation">Sweep rotation</param>
            <param name="filter">Query filter for filtering results.</param>
            <param name="colliderFilter">
            Query collider filter for filtering which of the entity's colliders to query with.
            </param>
            <param name="excludeSelf">Should <paramref name="entity"/> be excluded from results?</param>
            <param name="flags">Query flags for filtering results.</param>
        </member>
        <member name="M:KS.Reactor.ksSweepParams.#ctor(KS.Reactor.ksICollider,KS.Reactor.ksVector3,System.Single,KS.Reactor.ksIQueryFilter,System.Boolean,KS.Reactor.ksQueryFlags)">
            <summary>
            Construct a collider sweep from the entity position and sweeping over a direction and distance.
            </summary>
            <param name="collider">Sweep collider</param>
            <param name="direction">Sweep direction</param>
            <param name="distance">Sweep distance</param>
            <param name="filter">Query filter for filtering results.</param><param name="excludeColliderEntity">
            Should <paramref name="collider"/>'s entity be excluded from results?
            </param>
            <param name="flags">Query flags for filtering results.</param>
        </member>
        <member name="M:KS.Reactor.ksSweepParams.#ctor(KS.Reactor.ksICollider,KS.Reactor.ksVector3,KS.Reactor.ksIQueryFilter,System.Boolean,KS.Reactor.ksQueryFlags)">
            <summary>Construct a collider sweep from the entity position and sweeping to an end point.</summary>
            <param name="collider">Sweep collider</param>
            <param name="end">Sweep end point</param>
            <param name="filter">Query filter for filtering results.</param>
            <param name="excludeColliderEntity">
            Should <paramref name="collider"/>'s entity be excluded from results?
            </param>
            <param name="flags">Query flags for filtering results.</param>
        </member>
        <member name="M:KS.Reactor.ksSweepParams.#ctor(KS.Reactor.ksICollider,KS.Reactor.ksVector3,KS.Reactor.ksQuaternion,KS.Reactor.ksVector3,System.Single,KS.Reactor.ksIQueryFilter,System.Boolean,KS.Reactor.ksQueryFlags)">
            <summary>
            Construct a collider sweep from a specified origin and rotation and sweeping over a direction and distance.
            </summary>
            <param name="collider">Sweep collider</param>
            <param name="origin">Sweep origin</param>
            <param name="rotation">Sweep rotation</param>
            <param name="direction">Sweep direction</param>
            <param name="distance">Sweep distance</param>
            <param name="filter">Query filter for filtering results.</param>
            <param name="excludeColliderEntity">
            Should <paramref name="collider"/>'s entity be excluded from results?
            </param>
            <param name="flags">Query flags for filtering results.</param>
        </member>
        <member name="M:KS.Reactor.ksSweepParams.#ctor(KS.Reactor.ksICollider,KS.Reactor.ksVector3,KS.Reactor.ksVector3,KS.Reactor.ksQuaternion,KS.Reactor.ksIQueryFilter,System.Boolean,KS.Reactor.ksQueryFlags)">
            <summary>
            Construct a collider sweep from a specified origin and rotation and sweeping to an end point.
            </summary>
            <param name="collider">Sweep collider</param>
            <param name="origin">Sweep origin</param>
            <param name="end">Sweep end point</param>
            <param name="rotation">Sweep rotation</param>
            <param name="filter">Query filter for filtering results.</param>
            <param name="excludeColliderEntity">
            Should <paramref name="collider"/>'s entity be excluded from results?
            </param>
            <param name="flags">Query flags for filtering results.</param>
        </member>
        <member name="M:KS.Reactor.ksSweepParams.CopyTo(KS.Reactor.ksSweepParams)">
            <summary>Copies the values from this object to the <paramref name="target"/>.</summary>
            <param name="target">Target to copy to.</param>
        </member>
        <member name="T:KS.Reactor.ksSweepResult">
            <summary>Result of a sweep scene query.</summary>
        </member>
        <member name="P:KS.Reactor.ksSweepResult.QueryCollider">
            <summary>The collider used in the query. Null for shape queries.</summary>
        </member>
        <member name="P:KS.Reactor.ksSweepResult.Entity">
            <summary>Entity hit by the sweep.</summary>
        </member>
        <member name="P:KS.Reactor.ksSweepResult.Collider">
            <summary>Collider hit by the sweep.</summary>
        </member>
        <member name="P:KS.Reactor.ksSweepResult.Point">
            <summary>Point on the surface of the entity where the sweep instersected</summary>
        </member>
        <member name="P:KS.Reactor.ksSweepResult.Normal">
            <summary>Normal of the surface where the sweep point is.</summary>
        </member>
        <member name="P:KS.Reactor.ksSweepResult.Distance">
            <summary>Distance along the sweep when the intersection was detected.</summary>
        </member>
        <member name="P:KS.Reactor.ksSweepResult.IsValid">
            <summary>A sweep result is only valid if it includes an entity reference.</summary>
        </member>
        <member name="P:KS.Reactor.ksSweepResult.IsInitialOverlap">
            <summary>Is the entity/collider overlapping with the sweep origin?</summary>
        </member>
        <member name="T:KS.Reactor.ksSweepSlideParams">
            <summary>
            Paramters for sweep-and-slide movement. When a sweep hits something, the remaining movement vector is projected
            onto the plane perpendicuar to the surface normal to get a new movement vector which is used to sweep
            recursively.
            </summary>
        </member>
        <member name="T:KS.Reactor.ksSweepSlideParams.CollideHandler">
            <summary>Callback for when the sweep hits something.</summary>
            <param name="hit">Sweep hit result</param>
            <param name="args">
            Parameters for the next sweep. You can use this to change the parameters for the next sweep.
            </param>
            <param name="direction">The direction of the sweep that resulted in this collision.</param>
            <param name="state">
            Indicates if there will be another sweep, or the reason sweep-and-slide movement is stopping.
            </param>
            <returns>False to stop sliding.</returns>
        </member>
        <member name="T:KS.Reactor.ksSweepSlideParams.CallbackStates">
            <summary>
            Enum passed to <see cref="F:KS.Reactor.ksSweepSlideParams.CollideCallback"/> to indicate if there will be a new sweep, or the reason there
            will not be another sweep.
            </summary>
        </member>
        <member name="F:KS.Reactor.ksSweepSlideParams.MAX_SLIDE_ANGLE">
            <summary>Default value for <see cref="P:KS.Reactor.ksSweepSlideParams.MaxSlideAngle"/></summary>
        </member>
        <member name="F:KS.Reactor.ksSweepSlideParams.MAX_TOTAL_SLIDE_ANGLE">
            <summary>Default value for <see cref="P:KS.Reactor.ksSweepSlideParams.MaxTotalSlideAngle"/></summary>
        </member>
        <member name="F:KS.Reactor.ksSweepSlideParams.SEPARATION_OFFSET">
            <summary>Default value for <see cref="F:KS.Reactor.ksSweepSlideParams.SeparationOffset"/></summary>
        </member>
        <member name="F:KS.Reactor.ksSweepSlideParams.MAX_ITERATIONS">
            <summary>Default value for <see cref="F:KS.Reactor.ksSweepSlideParams.MaxIterations"/></summary>
        </member>
        <member name="P:KS.Reactor.ksSweepSlideParams.MaxSlideAngle">
            <summary>
            Do not allow slides that change the movement direction by more than this angle in degrees. Less than zero
            for no limit.
            </summary>
        </member>
        <member name="P:KS.Reactor.ksSweepSlideParams.CosMaxSlideAngle">
            <summary>Cosine of <see cref="P:KS.Reactor.ksSweepSlideParams.MaxSlideAngle"/>. NaN if <see cref="P:KS.Reactor.ksSweepSlideParams.MaxSlideAngle"/> is negative.</summary>
        </member>
        <member name="P:KS.Reactor.ksSweepSlideParams.MaxTotalSlideAngle">
            <summary>
            Do not allow sliding in a direction that differs from the original direction by more than this angle in
            degrees. Less than zero for no limit.
            </summary>
        </member>
        <member name="P:KS.Reactor.ksSweepSlideParams.CosMaxTotalSlideAngle">
            <summary>
            Cosine of <see cref="P:KS.Reactor.ksSweepSlideParams.MaxTotalSlideAngle"/>. NaN if <see cref="P:KS.Reactor.ksSweepSlideParams.MaxTotalSlideAngle"/> is negative.
            </summary>
        </member>
        <member name="F:KS.Reactor.ksSweepSlideParams.SeparationOffset">
            <summary>
            When the sweep hits something, offset the position by this much in the direction of the surface normal.
            Helps prevent penetrations.
            </summary>
        </member>
        <member name="F:KS.Reactor.ksSweepSlideParams.MaxIterations">
            <summary>
            Maximum number of sweep-and-slide iterations. One to stop after the first sweep without sliding.
            </summary>
        </member>
        <member name="F:KS.Reactor.ksSweepSlideParams.CollideCallback">
            <summary>
            Callback to call for each object collided with during the sweep and slide. Return false to prevent further
            sweep-and-slide movement.
            </summary>
        </member>
        <member name="M:KS.Reactor.ksSweepSlideParams.#ctor">
            <summary>Constructor</summary>
        </member>
        <member name="M:KS.Reactor.ksSweepSlideParams.#ctor(KS.Reactor.ksShape,KS.Reactor.ksVector3,KS.Reactor.ksQuaternion,KS.Reactor.ksVector3,System.Single,KS.Reactor.ksIQueryFilter,KS.Reactor.ksIEntity,KS.Reactor.ksQueryFlags,System.Single,System.Single,System.Single,System.Int32,KS.Reactor.ksSweepSlideParams.CollideHandler)">
            <summary>Construct a shape sweep using an origin point, direction and distance.</summary>
            <param name="shape">Sweep shape</param>
            <param name="origin">Sweep origin</param>
            <param name="rotation">Shape rotation</param>
            <param name="direction">Sweep direction</param>
            <param name="distance">Sweep distance</param>
            <param name="filter">Query filter for filtering results.</param>
            <param name="excludeEntity">Exclude this entity from results.</param>
            <param name="flags">Query flags for filtering results.</param>
            <param name="maxSlideAngle">
            Do not allow sliding in a direction that differs from the original direction by more than this angle in
            degrees. Less than zero for no limit.
            </param>
            <param name="maxTotalSlideAngle">
            Do not allow sliding in a direction that differs from the original direction by more than this angle in
            degrees. Less than zero for no limit.
            </param>
            <param name="separationOffset">
            When the sweep hits something, offset the position by this much in the direction of the surface normal.
            Helps prevent penetrations.
            </param>
            <param name="maxIterations">Maximum number of sweep-and-slide iterations.</param>
            <param name="collideCallback">
            Callback to call for each object collided with during the sweep and slide. Return false to prevent further
            sweep-and-slide movement.
            </param>
        </member>
        <member name="M:KS.Reactor.ksSweepSlideParams.#ctor(KS.Reactor.ksShape,KS.Reactor.ksVector3,KS.Reactor.ksVector3,KS.Reactor.ksQuaternion,KS.Reactor.ksIQueryFilter,KS.Reactor.ksIEntity,KS.Reactor.ksQueryFlags,System.Single,System.Single,System.Single,System.Int32,KS.Reactor.ksSweepSlideParams.CollideHandler)">
            <summary>Construct a shape sweep using an origin and end point.</summary>
            <param name="shape">Sweep shape</param>
            <param name="origin">Sweep origin</param>
            <param name="end">Sweep end point</param>
            <param name="rotation">Shape rotation</param>
            <param name="filter">Query filter for filtering results.</param>
            <param name="excludeEntity">Exclude this entity from results.</param>
            <param name="flags">Query flags for filtering results.</param>
            <param name="maxSlideAngle">
            Do not allow sliding in a direction that differs from the original direction by more than this angle in
            degrees. Less than zero for no limit.
            </param>
            <param name="maxTotalSlideAngle">
            Do not allow sliding in a direction that differs from the original direction by more than this angle in
            degrees. Less than zero for no limit.
            </param>
            <param name="separationOffset">
            When the sweep hits something, offset the position by this much in the direction of the surface normal.
            Helps prevent penetrations.
            </param>
            <param name="maxIterations">Maximum number of sweep-and-slide iterations.</param>
            <param name="collideCallback">
            Callback to call for each object collided with during the sweep and slide. Return false to prevent further
            sweep-and-slide movement.
            </param>
        </member>
        <member name="M:KS.Reactor.ksSweepSlideParams.#ctor(KS.Reactor.ksIEntity,KS.Reactor.ksVector3,System.Single,KS.Reactor.ksIQueryFilter,KS.Reactor.ksIEntityQueryColliderFilter,System.Boolean,KS.Reactor.ksQueryFlags,System.Single,System.Single,System.Single,System.Int32,KS.Reactor.ksSweepSlideParams.CollideHandler)">
            <summary>
            Construct an entity sweep from the entity position and sweeping over a direction and distance.
            </summary>
            <param name="entity">Sweep entity</param>
            <param name="direction">Sweep direction</param>
            <param name="distance">Sweep distance</param>
            <param name="filter">Query filter for filtering results.</param>
            <param name="colliderFilter">
            Query collider filter for filtering which of the entity's colliders to query with.
            </param>
            <param name="excludeSelf">Should <paramref name="entity"/> be excluded from results?</param>
            <param name="flags">Query flags for filtering results.</param>
            <param name="maxSlideAngle">
            Do not allow sliding in a direction that differs from the original direction by more than this angle in
            degrees. Less than zero for no limit.
            </param>
            <param name="maxTotalSlideAngle">
            Do not allow sliding in a direction that differs from the original direction by more than this angle in
            degrees. Less than zero for no limit.
            </param>
            <param name="separationOffset">
            When the sweep hits something, offset the position by this much in the direction of the surface normal.
            Helps prevent penetrations.
            </param>
            <param name="maxIterations">Maximum number of sweep-and-slide iterations.</param>
            <param name="collideCallback">
            Callback to call for each object collided with during the sweep and slide. Return false to prevent further
            sweep-and-slide movement.
            </param>
        </member>
        <member name="M:KS.Reactor.ksSweepSlideParams.#ctor(KS.Reactor.ksIEntity,KS.Reactor.ksVector3,KS.Reactor.ksIQueryFilter,KS.Reactor.ksIEntityQueryColliderFilter,System.Boolean,KS.Reactor.ksQueryFlags,System.Single,System.Single,System.Single,System.Int32,KS.Reactor.ksSweepSlideParams.CollideHandler)">
            <summary>Construct an entity sweep from the entity position and sweeping to an end point.</summary>
            <param name="entity">Sweep entity</param>
            <param name="end">Sweep end point</param>
            <param name="filter">Query filter for filtering results.</param>
            <param name="colliderFilter">
            Query collider filter for filtering which of the entity's colliders to query with.
            </param>
            <param name="excludeSelf">Should <paramref name="entity"/> be excluded from results?</param>
            <param name="flags">Query flags for filtering results.</param>
            <param name="maxSlideAngle">
            Do not allow sliding in a direction that differs from the original direction by more than this angle in
            degrees. Less than zero for no limit.
            </param>
            <param name="maxTotalSlideAngle">
            Do not allow sliding in a direction that differs from the original direction by more than this angle in
            degrees. Less than zero for no limit.
            </param>
            <param name="separationOffset">
            When the sweep hits something, offset the position by this much in the direction of the surface normal.
            Helps prevent penetrations.
            </param>
            <param name="maxIterations">Maximum number of sweep-and-slide iterations.</param>
            <param name="collideCallback">
            Callback to call for each object collided with during the sweep and slide. Return false to prevent further
            sweep-and-slide movement.
            </param>
        </member>
        <member name="M:KS.Reactor.ksSweepSlideParams.#ctor(KS.Reactor.ksIEntity,KS.Reactor.ksVector3,KS.Reactor.ksQuaternion,KS.Reactor.ksVector3,System.Single,KS.Reactor.ksIQueryFilter,KS.Reactor.ksIEntityQueryColliderFilter,System.Boolean,KS.Reactor.ksQueryFlags,System.Single,System.Single,System.Single,System.Int32,KS.Reactor.ksSweepSlideParams.CollideHandler)">
            <summary>
            Construct an entity sweep from a specified origin and rotation and sweeping over a direction and distance.
            </summary>
            <param name="entity">Sweep entity</param>
            <param name="origin">Sweep origin</param>
            <param name="rotation">Sweep rotation</param>
            <param name="direction">Sweep direction</param>
            <param name="distance">Sweep distance</param>
            <param name="filter">Query filter for filtering results.</param>
            <param name="colliderFilter">
            Query collider filter for filtering which of the entity's colliders to query with.
            </param>
            <param name="excludeSelf">Should <paramref name="entity"/> be excluded from results?</param>
            <param name="flags">Query flags for filtering results.</param>
            <param name="maxSlideAngle">
            Do not allow sliding in a direction that differs from the original direction by more than this angle in
            degrees. Less than zero for no limit.
            </param>
            <param name="maxTotalSlideAngle">
            Do not allow sliding in a direction that differs from the original direction by more than this angle in
            degrees. Less than zero for no limit.
            </param>
            <param name="separationOffset">
            When the sweep hits something, offset the position by this much in the direction of the surface normal.
            Helps prevent penetrations.
            </param>
            <param name="maxIterations">Maximum number of sweep-and-slide iterations.</param>
            <param name="collideCallback">
            Callback to call for each object collided with during the sweep and slide. Return false to prevent further
            sweep-and-slide movement.
            </param>
        </member>
        <member name="M:KS.Reactor.ksSweepSlideParams.#ctor(KS.Reactor.ksIEntity,KS.Reactor.ksVector3,KS.Reactor.ksVector3,KS.Reactor.ksQuaternion,KS.Reactor.ksIQueryFilter,KS.Reactor.ksIEntityQueryColliderFilter,System.Boolean,KS.Reactor.ksQueryFlags,System.Single,System.Single,System.Single,System.Int32,KS.Reactor.ksSweepSlideParams.CollideHandler)">
            <summary>
            Construct an entity sweep from a specified origin and rotation and sweeping to an end point.
            </summary>
            <param name="entity">Sweep entity</param>
            <param name="origin">Sweep origin</param>
            <param name="end">Sweep end point</param>
            <param name="rotation">Sweep rotation</param>
            <param name="filter">Query filter for filtering results.</param>
            <param name="colliderFilter">
            Query collider filter for filtering which of the entity's colliders to query with.
            </param>
            <param name="excludeSelf">Should <paramref name="entity"/> be excluded from results?</param>
            <param name="flags">Query flags for filtering results.</param>
            <param name="maxSlideAngle">
            Do not allow sliding in a direction that differs from the original direction by more than this angle in
            degrees. Less than zero for no limit.
            </param>
            <param name="maxTotalSlideAngle">
            Do not allow sliding in a direction that differs from the original direction by more than this angle in
            degrees. Less than zero for no limit.
            </param>
            <param name="separationOffset">
            When the sweep hits something, offset the position by this much in the direction of the surface normal.
            Helps prevent penetrations.
            </param>
            <param name="maxIterations">Maximum number of sweep-and-slide iterations.</param>
            <param name="collideCallback">
            Callback to call for each object collided with during the sweep and slide. Return false to prevent further
            sweep-and-slide movement.
            </param>
        </member>
        <member name="M:KS.Reactor.ksSweepSlideParams.#ctor(KS.Reactor.ksICollider,KS.Reactor.ksVector3,System.Single,KS.Reactor.ksIQueryFilter,System.Boolean,KS.Reactor.ksQueryFlags,System.Single,System.Single,System.Single,System.Int32,KS.Reactor.ksSweepSlideParams.CollideHandler)">
            <summary>
            Construct a collider sweep from the entity position and sweeping over a direction and distance.
            </summary>
            <param name="collider">Sweep collider</param>
            <param name="direction">Sweep direction</param>
            <param name="distance">Sweep distance</param>
            <param name="filter">Query filter for filtering results.</param>
            <param name="excludeColliderEntity">
            Should <paramref name="collider"/>'s entity be excluded from results?
            </param>
            <param name="flags">Query flags for filtering results.</param>
            <param name="maxSlideAngle">
            Do not allow sliding in a direction that differs from the original direction by more than this angle in
            degrees. Less than zero for no limit.
            </param>
            <param name="maxTotalSlideAngle">
            Do not allow sliding in a direction that differs from the original direction by more than this angle in
            degrees. Less than zero for no limit.
            </param>
            <param name="separationOffset">
            When the sweep hits something, offset the position by this much in the direction of the surface normal.
            Helps prevent penetrations.
            </param>
            <param name="maxIterations">Maximum number of sweep-and-slide iterations.</param>
            <param name="collideCallback">
            Callback to call for each object collided with during the sweep and slide. Return false to prevent further
            sweep-and-slide movement.
            </param>
        </member>
        <member name="M:KS.Reactor.ksSweepSlideParams.#ctor(KS.Reactor.ksICollider,KS.Reactor.ksVector3,KS.Reactor.ksIQueryFilter,System.Boolean,KS.Reactor.ksQueryFlags,System.Single,System.Single,System.Single,System.Int32,KS.Reactor.ksSweepSlideParams.CollideHandler)">
            <summary>Construct a collider sweep from the entity position and sweeping to an end point.</summary>
            <param name="collider">Sweep collider</param>
            <param name="end">Sweep end point</param>
            <param name="filter">Query filter for filtering results.</param>
            <param name="excludeColliderEntity">
            Should <paramref name="collider"/>'s entity be excluded from results?
            </param>
            <param name="flags">Query flags for filtering results.</param>
            <param name="maxSlideAngle">
            Do not allow sliding in a direction that differs from the original direction by more than this angle in
            degrees. Less than zero for no limit.
            </param>
            <param name="maxTotalSlideAngle">
            Do not allow sliding in a direction that differs from the original direction by more than this angle in
            degrees. Less than zero for no limit.
            </param>
            <param name="separationOffset">
            When the sweep hits something, offset the position by this much in the direction of the surface normal.
            Helps prevent penetrations.
            </param>
            <param name="maxIterations">Maximum number of sweep-and-slide iterations.</param>
            <param name="collideCallback">
            Callback to call for each object collided with during the sweep and slide. Return false to prevent further
            sweep-and-slide movement.
            </param>
        </member>
        <member name="M:KS.Reactor.ksSweepSlideParams.#ctor(KS.Reactor.ksICollider,KS.Reactor.ksVector3,KS.Reactor.ksQuaternion,KS.Reactor.ksVector3,System.Single,KS.Reactor.ksIQueryFilter,System.Boolean,KS.Reactor.ksQueryFlags,System.Single,System.Single,System.Single,System.Int32,KS.Reactor.ksSweepSlideParams.CollideHandler)">
            <summary>
            Construct a collider sweep from a specified origin and rotation and sweeping over a direction and distance.
            </summary>
            <param name="collider">Sweep collider</param>
            <param name="origin">Sweep origin</param>
            <param name="rotation">Sweep rotation</param>
            <param name="direction">Sweep direction</param>
            <param name="distance">Sweep distance</param>
            <param name="filter">Query filter for filtering results.</param>
            <param name="excludeColliderEntity">
            Should <paramref name="collider"/>'s entity be excluded from results?
            </param>
            <param name="flags">Query flags for filtering results.</param>
            <param name="maxSlideAngle">
            Do not allow sliding in a direction that differs from the original direction by more than this angle in
            degrees. Less than zero for no limit.
            </param>
            <param name="maxTotalSlideAngle">
            Do not allow sliding in a direction that differs from the original direction by more than this angle in
            degrees. Less than zero for no limit.
            </param>
            <param name="separationOffset">
            When the sweep hits something, offset the position by this much in the direction of the surface normal.
            Helps prevent penetrations.
            </param>
            <param name="maxIterations">Maximum number of sweep-and-slide iterations.</param>
            <param name="collideCallback">
            Callback to call for each object collided with during the sweep and slide. Return false to prevent further
            sweep-and-slide movement.
            </param>
        </member>
        <member name="M:KS.Reactor.ksSweepSlideParams.#ctor(KS.Reactor.ksICollider,KS.Reactor.ksVector3,KS.Reactor.ksVector3,KS.Reactor.ksQuaternion,KS.Reactor.ksIQueryFilter,System.Boolean,KS.Reactor.ksQueryFlags,System.Single,System.Single,System.Single,System.Int32,KS.Reactor.ksSweepSlideParams.CollideHandler)">
            <summary>
            Construct a collider sweep from a specified origin and rotation and sweeping to an end point.
            </summary>
            <param name="collider">Sweep collider</param>
            <param name="origin">Sweep origin</param>
            <param name="end">Sweep end point</param>
            <param name="rotation">Sweep rotation</param>
            <param name="filter">Query filter for filtering results.</param>
            <param name="excludeColliderEntity">
            Should <paramref name="collider"/>'s entity be excluded from results?
            </param>
            <param name="flags">Query flags for filtering results.</param>
            <param name="maxSlideAngle">
            Do not allow sliding in a direction that differs from the original direction by more than this angle in
            degrees. Less than zero for no limit.
            </param>
            <param name="maxTotalSlideAngle">
            Do not allow sliding in a direction that differs from the original direction by more than this angle in
            degrees. Less than zero for no limit.
            </param>
            <param name="separationOffset">
            When the sweep hits something, offset the position by this much in the direction of the surface normal.
            Helps prevent penetrations.
            </param>
            <param name="maxIterations">Maximum number of sweep-and-slide iterations.</param>
            <param name="collideCallback">
            Callback to call for each object collided with during the sweep and slide. Return false to prevent further
            sweep-and-slide movement.
            </param>
        </member>
        <member name="M:KS.Reactor.ksSweepSlideParams.CopyTo(KS.Reactor.ksSweepSlideParams)">
            <summary>Copies the values from this object to the <paramref name="target"/>.</summary>
            <param name="target">Target to copy to.</param>
        </member>
        <member name="M:KS.Reactor.ksSweepSlideParams.CosDeg(System.Single)">
            <summary>
            Calculates the cosine of <paramref name="degrees"/>, or NaN if <paramref name="degrees"/> is outside the
            range [0, 180).
            </summary>
            <param name="degrees">Angle in degrees. If negative, returns NaN.</param>
            <returns>
            Cosine of <paramref name="degrees"/>, or NaN if <paramref name="degrees"/> is outside the range [0, 180).
            </returns>
        </member>
        <member name="T:KS.Reactor.ksTime">
            <summary>Holds time data that is common to the client and server.</summary>
        </member>
        <member name="F:KS.Reactor.ksTime.m_zero">
            <summary>Time with zero for all values.</summary>
        </member>
        <member name="P:KS.Reactor.ksTime.Delta">
            <summary>Local simulated game time in seconds since the last update.</summary>
        </member>
        <member name="P:KS.Reactor.ksTime.UnscaledDelta">
            <summary>Simulated game time in seconds unscaled by time scaling since the last update.</summary>
        </member>
        <member name="P:KS.Reactor.ksTime.Time">
            <summary>Total simluated game time in seconds.</summary>
        </member>
        <member name="P:KS.Reactor.ksTime.RealTime">
            <summary>Real time in seconds that the game has been running.</summary>
        </member>
        <member name="P:KS.Reactor.ksTime.TimeScale">
            <summary>Time scale applied to simulation steps.</summary>
        </member>
        <member name="P:KS.Reactor.ksTime.Frame">
            <summary>Server frame number.</summary>
        </member>
        <member name="P:KS.Reactor.ksTime.FramesPerSync">
            <summary>The number of server frames between each network update sent to clients.</summary>
        </member>
        <member name="T:KS.Reactor.ksTransform">
            <summary>
            Transform with methods for moving entities. Their are two kinds of movement: teleportation and moving. Moving will
            test for collisions along the way and teleportation will not. If you make more than one move call in a frame,
            the collision check will be along a straight path from the position at the start of the frame to the end position.
            You cannot do a move and a teleport in the same frame. If you make both calls the entity will teleport.
            </summary>
        </member>
        <member name="T:KS.Reactor.ksTransform.UpdateCallback">
            <summary>Callback invoked when a transform updates.</summary>
            <param name="transform">The transform modified.</param>
            <param name="flag">Dirty flag indicating the field that was changed.</param>
        </member>
        <member name="E:KS.Reactor.ksTransform.OnUpdate">
            <summary>Static tranform update event.</summary>
        </member>
        <member name="F:KS.Reactor.ksTransform.PositionTolerance">
            <summary>
            Position tolerance defines the minimum position delta necessary for the translation to be applied. A higher
            value will have the effect of stabilizing objects at the cost of positional accuracy.
            </summary>
        </member>
        <member name="F:KS.Reactor.ksTransform.RotationTolerance">
            <summary>
            Rotation tolerance defines the minimum delta on any one of the x,y,z,w parts of a quaternion rotation
            necessary for the rotation to be applied. A higher value will have the effect of stabilizing objects at the
            cost of rotational accuracy.
            </summary>
        </member>
        <member name="F:KS.Reactor.ksTransform.ScaleTolerance">
            <summary>
            Scale tolerance defines the minimum position delta necessary for the scale to be applied. A higher
            value will have the effect of stabilizing objects at the cost of positional accuracy.
            </summary>
        </member>
        <member name="T:KS.Reactor.ksTransform.DirtyFlags">
            <summary>Flags used to indicate that a field has changed.</summary>
        </member>
        <member name="F:KS.Reactor.ksTransform.DirtyFlags.TRACKED">
            <summary>Is this transform tracked in the modified transform list?</summary>
        </member>
        <member name="F:KS.Reactor.ksTransform.DirtyFlags.NETWORK_FLAGS">
            <summary>Flags that are relevant to network syncing.</summary>
        </member>
        <member name="M:KS.Reactor.ksTransform.#ctor">
            <summary>Default constructor.</summary>
        </member>
        <member name="M:KS.Reactor.ksTransform.#ctor(KS.Reactor.ksVector3,KS.Reactor.ksQuaternion,KS.Reactor.ksVector3)">
            <summary>Constructor.</summary>
            <param name="position"></param>
            <param name="rotation"></param>
            <param name="scale"></param>
        </member>
        <member name="P:KS.Reactor.ksTransform.EntityId">
            <summary>ID of the entity this transform is attached to.</summary>
        </member>
        <member name="M:KS.Reactor.ksTransform.SetTransformDirty">
            <summary>A dirty transform requires 3 sync updates to clear.</summary>
        </member>
        <member name="M:KS.Reactor.ksTransform.IsDirty(KS.Reactor.ksTransform.DirtyFlags)">
            <summary>Checks if a property is dirty.</summary>
            <param name="flag">Dirty flag to check.</param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksTransform.SetDirty(KS.Reactor.ksTransform.DirtyFlags)">
            <summary>Sets a dirty flag.</summary>
            <param name="flag">Dirty flag to set.</param>
        </member>
        <member name="M:KS.Reactor.ksTransform.ClearDirty(KS.Reactor.ksTransform.DirtyFlags)">
            <summary>Clears the dirty flag for a field.</summary>
            <param name="flag">Dirty flag to clear.</param>
        </member>
        <member name="P:KS.Reactor.ksTransform.Position">
            <summary>Position.</summary>
        </member>
        <member name="P:KS.Reactor.ksTransform.Rotation">
            <summary>Rotation.</summary>
        </member>
        <member name="P:KS.Reactor.ksTransform.Scale">
            <summary>Scale.</summary>
        </member>
        <member name="P:KS.Reactor.ksTransform.IsPermanent">
            <summary>
            Is this a permanent entity? Permanent entities are static entities that cannot be moved or deleted.
            They are not sent to clients since clients will already know where they are.
            </summary>
        </member>
        <member name="P:KS.Reactor.ksTransform.Teleported">
            <summary>
            Indicator for the encoder if the entity was moved using the Teleport method.
            If this value is true, the next sync frame will tell clients to skip
            interpolation of this transform when updating the entity position on the
            client. This value is cleared after every network sync.
            </summary>
        </member>
        <member name="P:KS.Reactor.ksTransform.IsSyncReady">
            <summary>Sets whether this entity is ready to sync to clients.</summary>
        </member>
        <member name="M:KS.Reactor.ksTransform.Move(KS.Reactor.ksVector3)">
            <summary>Adds a delta to the transform position.</summary>
            <param name="delta">Delta to add to position.</param>
        </member>
        <member name="M:KS.Reactor.ksTransform.MoveTo(KS.Reactor.ksVector3)">
            <summary>Moves the entity to a new position.</summary>
            <param name="position">Position to move to.</param>
        </member>
        <member name="M:KS.Reactor.ksTransform.MoveTowards(KS.Reactor.ksVector3,System.Single)">
            <summary>Moves the transform towards a position.</summary>
            <param name="position">Target to move towards.</param>
            <param name="delta">
            Delta to move by. It will not overshoot the target. Negative values will move away from the target.
            </param>
        </member>
        <member name="M:KS.Reactor.ksTransform.Teleport(KS.Reactor.ksVector3)">
            <summary>Teleports the entity to a location.</summary>
            <param name="position">Position to teleport to.</param>
        </member>
        <member name="M:KS.Reactor.ksTransform.RotateTo(KS.Reactor.ksQuaternion)">
            <summary>Sets the rotation.</summary>
            <param name="rotation">Rotation to rotate to.</param>
        </member>
        <member name="M:KS.Reactor.ksTransform.ScaleTo(KS.Reactor.ksVector3)">
            <summary>Sets the scale.</summary>
            <param name="scale"></param>
        </member>
        <member name="M:KS.Reactor.ksTransform.Rotate(KS.Reactor.ksQuaternion)">
            <summary>Rotates the transform.</summary>
            <param name="rotation">Rotation to rotate by.</param>
        </member>
        <member name="M:KS.Reactor.ksTransform.RotateLocal(KS.Reactor.ksQuaternion)">
            <summary>Rotates the transform in local space.</summary>
            <param name="rotation">Rotation to rotate by.</param>
        </member>
        <member name="M:KS.Reactor.ksTransform.Rotate(KS.Reactor.ksVector3)">
            <summary>Rotates the transform using euler angles.</summary>
            <param name="euler">Euler angles in degrees.</param>
        </member>
        <member name="M:KS.Reactor.ksTransform.RotateRadians(KS.Reactor.ksVector3)">
            <summary>Rotates the transform using euler angles.</summary>
            <param name="euler">Euler angles in radians.</param>
        </member>
        <member name="M:KS.Reactor.ksTransform.RotateLocal(KS.Reactor.ksVector3)">
            <summary>Rotates the transform locally using euler angles.</summary>
            <param name="euler">Euler angles in degrees.</param>
        </member>
        <member name="M:KS.Reactor.ksTransform.RotateLocalRadians(KS.Reactor.ksVector3)">
            <summary>Rotates the transform locally user euler angles.</summary>
            <param name="euler">Euler angles in radians.</param>
        </member>
        <member name="M:KS.Reactor.ksTransform.Rotate(KS.Reactor.ksVector3,System.Single)">
            <summary>Rotates the transform.</summary>
            <param name="axis">Axis of rotation.</param>
            <param name="angle">Angle to rotate in degrees.</param>
        </member>
        <member name="M:KS.Reactor.ksTransform.RotateRadians(KS.Reactor.ksVector3,System.Single)">
            <summary>Rotates the transform.</summary>
            <param name="axis">Axis of rotation.</param>
            <param name="angle">Angle to rotate in radians.</param>
        </member>
        <member name="M:KS.Reactor.ksTransform.LookAt(KS.Reactor.ksVector3)">
            <summary>
            Rotates the transform to look at a position. It will try to orient local up to be ksVector3.Up.
            </summary>
            <param name="position">Position in world space to look at.</param>
        </member>
        <member name="M:KS.Reactor.ksTransform.LookAt(KS.Reactor.ksVector3,KS.Reactor.ksVector3)">
            <summary>Rotates the transform to look at a position.</summary>
            <param name="position">Position in world space to look at.</param>
            <param name="up">Up vector to try and orient local up to.</param>
        </member>
        <member name="M:KS.Reactor.ksTransform.RotateTowards(KS.Reactor.ksQuaternion,System.Single)">
            <summary>Rotates the transform towards a rotation.</summary>
            <param name="target">Target to rotate towards.</param>
            <param name="deltaAngle">
            Delta angle in degrees to rotate. It will not overshoot the target.
            Negative values will rotate away from the target.
            </param>
        </member>
        <member name="M:KS.Reactor.ksTransform.RotateTowards(KS.Reactor.ksVector3,System.Single)">
            <summary>
            Rotates the transform towards a position. It will try to orient local up to be ksVector3.Up.
            </summary>
            <param name="position">Position in world space to rotate towards.</param>
            <param name="deltaAngle">
            Delta angle in degrees to rotate. It will not overshoot the target.
            Negative values will rotate away from the target.
            </param>
        </member>
        <member name="M:KS.Reactor.ksTransform.RotateTowards(KS.Reactor.ksVector3,KS.Reactor.ksVector3,System.Single)">
            <summary>Rotates the transform towards a position.</summary>
            <param name="position">Position in world space to rotate towards.</param>
            <param name="up">Up vector to try and orient local up to.</param>
            <param name="deltaAngle">
            Delta angle in degrees to rotate. It will not overshoot the target.
            Negative values will rotate away from the target.
            </param>
        </member>
        <member name="M:KS.Reactor.ksTransform.RotateTowardsRadians(KS.Reactor.ksQuaternion,System.Single)">
            <summary>Rotates the transform towards a rotation.</summary>
            <param name="target">Target to rotate towards.</param>
            <param name="deltaAngle">
            Delta angle in radians to rotate. It will not overshoot the target.
            Negative values will rotate away from the target.
            </param>
        </member>
        <member name="M:KS.Reactor.ksTransform.RotateTowardsRadians(KS.Reactor.ksVector3,System.Single)">
            <summary>
            Rotates the transform towards a position. It will try to orient local up to be ksVector3.Up.
            </summary>
            <param name="position">Position in world space to rotate towards.</param>
            <param name="deltaAngle">
            Delta angle in radians to rotate. It will not overshoot the target.
            Negative values will rotate away from the target.
            </param>
        </member>
        <member name="M:KS.Reactor.ksTransform.RotateTowardsRadians(KS.Reactor.ksVector3,KS.Reactor.ksVector3,System.Single)">
            <summary>Rotates the transform towards a position.</summary>
            <param name="position">Position in world space to rotate towards.</param>
            <param name="up">Up vector to try and orient local up to.</param>
            <param name="deltaAngle">
            Delta angle in radians to rotate. It will not overshoot the target.
            Negative values will rotate away from the target.
            </param>
        </member>
        <member name="M:KS.Reactor.ksTransform.AddAngularDisplacement(KS.Reactor.ksVector3)">
            <summary>Rotates the transform using angular displacement.</summary>
            <param name="angularDisplacement">Angular displacement in degrees.</param>
        </member>
        <member name="M:KS.Reactor.ksTransform.AddAngularDisplacementRadians(KS.Reactor.ksVector3)">
            <summary>Rotates the transform using angular displacement.</summary>
            <param name="angularDisplacement">Angular displacement in radians.</param>
        </member>
        <member name="M:KS.Reactor.ksTransform.Pitch(System.Single)">
            <summary>Rotates the transform through the world right axis.</summary>
            <param name="angle">Angle to rotate in degrees.</param>
        </member>
        <member name="M:KS.Reactor.ksTransform.PitchRadians(System.Single)">
            <summary>Rotates the transform through the world right axis.</summary>
            <param name="angle">Angle to rotate in radians.</param>
        </member>
        <member name="M:KS.Reactor.ksTransform.PitchLocal(System.Single)">
            <summary>Rotates the transform through the local right axis.</summary>
            <param name="angle">Angle to rotate in degrees.</param>
        </member>
        <member name="M:KS.Reactor.ksTransform.PitchLocalRadians(System.Single)">
            <summary>Rotates the transform through the local right axis.</summary>
            <param name="angle">Angle to rotate in radians.</param>
        </member>
        <member name="M:KS.Reactor.ksTransform.Yaw(System.Single)">
            <summary>Rotates the transform through the world up axis.</summary>
            <param name="angle">Angle to rotate in degrees.</param>
        </member>
        <member name="M:KS.Reactor.ksTransform.YawRadians(System.Single)">
            <summary>Rotates the transform through the world up axis.</summary>
            <param name="angle">Angle to rotate in radians.</param>
        </member>
        <member name="M:KS.Reactor.ksTransform.YawLocal(System.Single)">
            <summary>Rotates the transform through the local up axis.</summary>
            <param name="angle">Angle to rotate in degrees.</param>
        </member>
        <member name="M:KS.Reactor.ksTransform.YawLocalRadians(System.Single)">
            <summary>Rotates the transform through the local up axis.</summary>
            <param name="angle">Angle to rotate in radians.</param>
        </member>
        <member name="M:KS.Reactor.ksTransform.Roll(System.Single)">
            <summary>Rotates the transform through the world forward axis.</summary>
            <param name="angle">Angle to rotate in degrees.</param>
        </member>
        <member name="M:KS.Reactor.ksTransform.RollRadians(System.Single)">
            <summary>Rotates the transform through the world forward axis.</summary>
            <param name="angle">Angle to rotate in radians.</param>
        </member>
        <member name="M:KS.Reactor.ksTransform.RollLocal(System.Single)">
            <summary>Rotates the transform through the local forward axis.</summary>
            <param name="angle">Angle to rotate in degrees.</param>
        </member>
        <member name="M:KS.Reactor.ksTransform.RollLocalRadians(System.Single)">
            <summary>Rotates the transform through the local forward axis.</summary>
            <param name="angle">Angle to rotate in radians.</param>
        </member>
        <member name="T:KS.Reactor.ksTransform2D">
            <summary>
            Transform with methods for moving entities in 2 dimensions. There are two kinds of movement: teleportation and
            moving. Moving will test for collisions along the way and teleportation will not. If you make more than one
            move call in a frame, the collision check will be along a straight path from the position at the start of the
            frame to the end position. You cannot do a move and a teleport in the same frame. If you make both calls the
            entity will teleport.
            </summary>
        </member>
        <member name="M:KS.Reactor.ksTransform2D.#ctor(KS.Reactor.ksTransform)">
            <summary>Constructs a 2D transform which uses a 3D transform data source.</summary>
            <param name="transform">Transform data source.</param>
        </member>
        <member name="P:KS.Reactor.ksTransform2D.Position">
            <summary>Position.</summary>
        </member>
        <member name="P:KS.Reactor.ksTransform2D.Rotation">
            <summary>Rotation in degrees.</summary>
        </member>
        <member name="P:KS.Reactor.ksTransform2D.RotationRadians">
            <summary>Rotation in radians.</summary>
        </member>
        <member name="P:KS.Reactor.ksTransform2D.Scale">
            <summary>Scale.</summary>
        </member>
        <member name="M:KS.Reactor.ksTransform2D.Move(KS.Reactor.ksVector2)">
            <summary>Adds a delta to the transform position.</summary>
            <param name="delta">Delta to add to position.</param>
        </member>
        <member name="M:KS.Reactor.ksTransform2D.MoveTo(KS.Reactor.ksVector2)">
            <summary>Moves the entity to a new position.</summary>
            <param name="position">Position to move to.</param>
        </member>
        <member name="M:KS.Reactor.ksTransform2D.MoveTowards(KS.Reactor.ksVector2,System.Single)">
            <summary>Moves the transform towards a position.</summary>
            <param name="position">Target to move towards.</param>
            <param name="delta">
            Delta to move by. It will not overshoot the target. Negative values will move away from the target.
            </param>
        </member>
        <member name="M:KS.Reactor.ksTransform2D.Teleport(KS.Reactor.ksVector2)">
            <summary>Teleports the entity to a location.</summary>
            <param name="position">Position to teleport to.</param>
        </member>
        <member name="M:KS.Reactor.ksTransform2D.RotateTo(System.Single)">
            <summary>Sets the rotation.</summary>
            <param name="rotation">Rotation in degrees.</param>
        </member>
        <member name="M:KS.Reactor.ksTransform2D.RotateToRadians(System.Single)">
            <summary>Sets the rotation.</summary>
            <param name="rotation">Rotation in radians.</param>
        </member>
        <member name="M:KS.Reactor.ksTransform2D.ScaleTo(KS.Reactor.ksVector2)">
            <summary>Sets the scale.</summary>
            <param name="scale"></param>
        </member>
        <member name="M:KS.Reactor.ksTransform2D.Rotate(System.Single)">
            <summary>Rotates the transform.</summary>
            <param name="rotation">Rotation to add in degrees.</param>
        </member>
        <member name="M:KS.Reactor.ksTransform2D.RotateRadians(System.Single)">
            <summary>Rotates the transform.</summary>
            <param name="rotation">Rotation to add in radians.</param>
        </member>
        <member name="M:KS.Reactor.ksTransform2D.LookAt(KS.Reactor.ksVector2)">
            <summary>Rotates the transform to look at a position.</summary>
            <param name="position">Position in world space to look at.</param>
        </member>
        <member name="M:KS.Reactor.ksTransform2D.RotateTowards(System.Single,System.Single)">
            <summary>Rotates the transform towards a rotation.</summary>
            <param name="target">Target angle to rotate towards in degrees.</param>
            <param name="deltaAngle">
            Delta angle in degrees to rotate. It will not overshoot the target.
            Negative values will rotate away from the target.
            </param>
        </member>
        <member name="M:KS.Reactor.ksTransform2D.RotateTowards(KS.Reactor.ksVector2,System.Single)">
            <summary>Rotates the transform towards a position.</summary>
            <param name="position">Position in world space to rotate towards.</param>
            <param name="deltaAngle">
            Delta angle in degrees to rotate. It will not overshoot the target.
            Negative values will rotate away from the target.
            </param>
        </member>
        <member name="M:KS.Reactor.ksTransform2D.RotateTowardsRadians(System.Single,System.Single)">
            <summary>Rotates the transform towards a rotation.</summary>
            <param name="target">Target angle to rotate towards in radians.</param>
            <param name="deltaAngle">
            Delta angle in radians to rotate. It will not overshoot the target.
            Negative values will rotate away from the target.
            </param>
        </member>
        <member name="M:KS.Reactor.ksTransform2D.RotateTowardsRadians(KS.Reactor.ksVector2,System.Single)">
            <summary>Rotates the transform towards a position.</summary>
            <param name="position">Position in world space to rotate towards.</param>
            <param name="deltaAngle">
            Delta angle in radians to rotate. It will not overshoot the target.
            Negative values will rotate away from the target.
            </param>
        </member>
        <member name="T:KS.Reactor.ksUnityTagAttribute">
            <summary>
            Tag server fields, properties, classes or structs to add arbitrary Unity tags to their generated proxies.
            Fields and properties tagged with this attribute will be editable in the inspector even if they aren't tagged
            with <see cref="T:KS.Reactor.ksEditableAttribute"/>. Note that if <see cref="P:KS.Reactor.ksUnityTagAttribute.Tag"/> is not valid code, it will generate
            proxies that have compiler errors.
            </summary>
            <example>
            <code>
            [ksUnityTag("[TextArea]")]
            public string Text;
            </code>
            This creates an editable text field with the [TextArea] tag to make it a text area in Unity's inspector.
            </example>
        </member>
        <member name="P:KS.Reactor.ksUnityTagAttribute.Tag">
            <summary>
            Code to insert above the class, struct, field, or property declaration in the generated proxy. Usually a
            Unity tag. This proxy script will have a compile error if this is not valid code.
            </summary>
        </member>
        <member name="M:KS.Reactor.ksUnityTagAttribute.#ctor(System.String)">
            <summary>Constructor</summary>
            <param name="tag">
            Code to insert above the class, struct, field, or property declaration in the generated proxy. Usually a
            Unity tag. This proxy script will have a compile error if this is not valid code.
            </param>
        </member>
        <member name="T:KS.Reactor.ksVector2">
            <summary>Vector2 struct.</summary>
            <summary>Vector struct</summary>
        </member>
        <member name="F:KS.Reactor.ksVector2.m_one">
            <summary>One.</summary>
        </member>
        <member name="F:KS.Reactor.ksVector2.m_zero">
            <summary>Zero.</summary>
        </member>
        <member name="M:KS.Reactor.ksVector2.#ctor(System.Single,System.Single)">
            <summary>Constructor.</summary>
            <param name="x">X value.</param>
            <param name="y">Y value.</param>
        </member>
        <member name="M:KS.Reactor.ksVector2.op_Implicit(KS.Reactor.ksVector2)~System.Single[]">
            <summary>Implicit conversion from ksVector2 to float[2].</summary>
            <param name="value"></param>
        </member>
        <member name="M:KS.Reactor.ksVector2.op_Implicit(System.Single[])~KS.Reactor.ksVector2">
            <summary>Implicit conversion from float[] to ksVector2.</summary>
            <param name="value"></param>
        </member>
        <member name="P:KS.Reactor.ksVector2.X">
            <summary>X value.</summary>
        </member>
        <member name="P:KS.Reactor.ksVector2.Y">
            <summary>Y value.</summary>
        </member>
        <member name="P:KS.Reactor.ksVector2.Item(System.Int32)">
            <summary>Indexer.</summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksVector2.Magnitude">
            <summary>Gets the magnitude.</summary>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksVector2.MagnitudeSquared">
            <summary>Gets the magnitude squared.</summary>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksVector2.Normalized">
            <summary>Gets a normalized copy of this vector.</summary>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksVector2.Normalize">
            <summary>Normalizes this vector.</summary>
            <returns>False if the vector could not be normalized because it's the zero vector.</returns>
        </member>
        <member name="M:KS.Reactor.ksVector2.Clamped(System.Single)">
            <summary>Returns a copy of this vector with its magnitude clamped to maxLength.</summary>
            <param name="maxMagnitude">Max magnitude to clamp magnitude to.</param>
            <returns>Clamped vector.</returns>
        </member>
        <member name="M:KS.Reactor.ksVector2.Clamp(System.Single)">
            <summary>Clamps the magnitude of this vector.</summary>
            <param name="maxMagnitude">Max magnitude to clamp magnitude to.</param>
        </member>
        <member name="M:KS.Reactor.ksVector2.ToDegrees">
            <summary>Converts the direction of the vector to an angle.</summary>
            <returns>Angle in degrees [0, 360).</returns>
        </member>
        <member name="M:KS.Reactor.ksVector2.ToRadians">
            <summary>Converts the direction of the vector to an angle.</summary>
            <returns>Angle in radians [0, 2PI).</returns>
        </member>
        <member name="M:KS.Reactor.ksVector2.FromDegrees(System.Single,System.Single)">
            <summary>Constructs a Vector2 from an angle.</summary>
            <param name="angle">Angle in degrees.</param>
            <param name="magnitude">Magnitude</param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksVector2.FromRadians(System.Single,System.Single)">
            <summary>Constructs a Vector2 from an angle.</summary>
            <param name="angle">Angle in radians.</param>
            <param name="magnitude">Magnitude.</param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksVector2.Abs">
            <summary>Absolute value vector.</summary>
            <returns>New vector where all components are absolue values of this vector.</returns>
        </member>
        <member name="M:KS.Reactor.ksVector2.MaxValue(System.Boolean)">
            <summary>Gets the maximum component in the vector.</summary>
            <param name="absolute">Return the max absolute value.</param>
            <returns>Max component value.</returns>
        </member>
        <member name="M:KS.Reactor.ksVector2.MinValue(System.Boolean)">
            <summary>Gets the minimum component in the vector.</summary>
            <param name="absolute">Return the min absolute value.</param>
            <returns>Min component value.</returns>
        </member>
        <member name="M:KS.Reactor.ksVector2.ReplaceNaNs(System.Single)">
            <summary>Replaces NaN values in the vector.</summary>
            <param name="value">Replacement value.</param>
            <returns>True if any of the values was replaced.</returns>
        </member>
        <member name="M:KS.Reactor.ksVector2.ToString">
            <summary>Returns a string that represents the current Vector2.</summary>
            <returns>A string that represents the current Vector2.</returns>
        </member>
        <member name="M:KS.Reactor.ksVector2.ToString(System.String)">
            <summary>Returns a string respresentation of the vector.</summary>
            <param name="format"></param>
            <returns>Representation of the vector.</returns>
        </member>
        <member name="M:KS.Reactor.ksVector2.ToString(System.IFormatProvider)">
            <summary>Returns a string respresentation of the vector.</summary>
            <param name="provider"></param>
            <returns>Representation of the vector.</returns>
        </member>
        <member name="M:KS.Reactor.ksVector2.DeltaDegrees(KS.Reactor.ksVector2,KS.Reactor.ksVector2)">
            <summary>Returns the angle in degrees between two vectors.</summary>
            <param name="from">The angle extends round from this vector.</param>
            <param name="to">The angle extends round to this vector.</param>
            <returns>Angle in degrees.</returns>
        </member>
        <member name="M:KS.Reactor.ksVector2.DeltaRadians(KS.Reactor.ksVector2,KS.Reactor.ksVector2)">
            <summary>Returns the angle in radians between two vectors.</summary>
            <param name="from">The angle extends round from this vector.</param>
            <param name="to">The angle extends round to this vector.</param>
            <returns>Angle in radians.</returns>
        </member>
        <member name="M:KS.Reactor.ksVector2.Dot(KS.Reactor.ksVector2,KS.Reactor.ksVector2)">
            <summary>Computes the dot product of two vectors.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns>Dot product.</returns>
        </member>
        <member name="M:KS.Reactor.ksVector2.Max(KS.Reactor.ksVector2,KS.Reactor.ksVector2)">
            <summary>Returns a vector that is made from the largest components of two vectors.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns>Max vector.</returns>
        </member>
        <member name="M:KS.Reactor.ksVector2.Min(KS.Reactor.ksVector2,KS.Reactor.ksVector2)">
            <summary>Returns a vector that is made from the smallest components of two vectors.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns>Min vector.</returns>
        </member>
        <member name="M:KS.Reactor.ksVector2.Project(KS.Reactor.ksVector2,KS.Reactor.ksVector2)">
            <summary>Projects a vector onto another vector.</summary>
            <param name="vector">Vector to project.</param>
            <param name="target">Target to project onto.</param>
            <returns>Projection result.</returns>
        </member>
        <member name="M:KS.Reactor.ksVector2.Reflect(KS.Reactor.ksVector2,KS.Reactor.ksVector2)">
            <summary>Reflects a vector off the plane defined by a normal.</summary>
            <param name="direction">Direction to reflect.</param>
            <param name="normal">Normal of plane to reflect off of.</param>
            <returns>Reflected vector.</returns>
        </member>
        <member name="M:KS.Reactor.ksVector2.Lerp(KS.Reactor.ksVector2,KS.Reactor.ksVector2,System.Single)">
            <summary>Linearly interpolates between two vectors.</summary>
            <param name="from">Vector to interpolate from.</param>
            <param name="to">Vector to interpolate to.</param>
            <param name="t">Value between 0 and 1 that determines the amount of interpolation.</param>
            <returns>Interpolated vector.</returns>
        </member>
        <member name="M:KS.Reactor.ksVector2.Slerp(KS.Reactor.ksVector2,KS.Reactor.ksVector2,System.Single,System.Boolean)">
            <summary>Spherically interpolates between from and to by t.</summary>
            <param name="from">Vector to interpolate from.</param>
            <param name="to">Vector to interpolate to.</param>
            <param name="t">Value between 0 and 1 that determines the amount of interpolation.</param>
            <param name="lerpMagnitude">If false, magnitude won't be interpolated.</param>
            <returns>Interpolated vector.</returns>
        </member>
        <member name="M:KS.Reactor.ksVector2.MoveTowards(KS.Reactor.ksVector2,KS.Reactor.ksVector2,System.Single)">
            <summary>Moves a point towards a target point.</summary>
            <param name="start">start point.</param>
            <param name="target">target to move towards.</param>
            <param name="delta">
            Delta distance to move. It will not overshoot the target. Negative values will move away from the target.</param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksVector2.Rotate(KS.Reactor.ksVector2,System.Single)">
            <summary>Rotates a vector by an angle.</summary>
            <param name="direction">Direction to rotate.</param>
            <param name="angle">Angle in degrees.</param>
            <returns>Rotated vector.</returns>
        </member>
        <member name="M:KS.Reactor.ksVector2.RotateRadians(KS.Reactor.ksVector2,System.Single)">
            <summary>Rotates a vector by an angle.</summary>
            <param name="direction">Direction to rotate.</param>
            <param name="angle">Angle in radians.</param>
            <returns>Rotated vector.</returns>
        </member>
        <member name="M:KS.Reactor.ksVector2.Scale(KS.Reactor.ksVector2,KS.Reactor.ksVector2)">
            <summary>Multiplies two vectors component-wise.</summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksVector2.op_Subtraction(KS.Reactor.ksVector2,KS.Reactor.ksVector2)">
            <summary>Subtracts one vector from another.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksVector2.op_UnaryNegation(KS.Reactor.ksVector2)">
            <summary>
            Multiplies the vector by -1.</summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksVector2.op_Multiply(KS.Reactor.ksVector2,System.Single)">
            <summary>
            Multiplies a ksVector2 by a number. Multiplies each component of Vector2 by a number scale.
            </summary>
            <param name="vector"></param>
            <param name="scale"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksVector2.op_Multiply(System.Single,KS.Reactor.ksVector2)">
            <summary>
            Multiplies a ksVector2 by a number. Multiplies each component of Vector2 by a number scale.
            </summary>
            <param name="scale"></param>
            <param name="vector"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksVector2.op_Division(KS.Reactor.ksVector2,System.Single)">
            <summary>Divides a ksVector2 by a number.</summary>
            <param name="vector"></param>
            <param name="scale"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksVector2.op_Division(System.Single,KS.Reactor.ksVector2)">
            <summary>Divides a number by a ksVector2.</summary>
            <param name="number"></param>
            <param name="vector"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksVector2.op_Addition(KS.Reactor.ksVector2,KS.Reactor.ksVector2)">
            <summary>Adds two ksVector2.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksVector2.op_Equality(KS.Reactor.ksVector2,KS.Reactor.ksVector2)">
            <summary>Checks if two vectors are equal.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns>True if the vectors are equal.</returns>
        </member>
        <member name="M:KS.Reactor.ksVector2.op_Inequality(KS.Reactor.ksVector2,KS.Reactor.ksVector2)">
            <summary>Checks if two vectors are not equal</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns>True if the vectors are not equal.</returns>
        </member>
        <member name="M:KS.Reactor.ksVector2.Equals(System.Object)">
            <summary>Checks if this vector is equal to an object.</summary>
            <param name="obj">Object to compare with this vector.</param>
            <returns>True if this vector is equal to the object.</returns>
        </member>
        <member name="M:KS.Reactor.ksVector2.Equals(KS.Reactor.ksVector2)">
            <summary>Checks if this vector is equal to another.</summary>
            <param name="other">Other vector to compare with.</param>
            <returns>True if the vectors are equal.</returns>
        </member>
        <member name="M:KS.Reactor.ksVector2.GetHashCode">
            <summary>Gets the hash code for this vector.</summary>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksVector2.op_Implicit(KS.Reactor.ksVector2)~UnityEngine.Vector2">
            <summary>Implicit conversion from <see cref="T:KS.Reactor.ksVector2"/> to Unity <see cref="T:UnityEngine.Vector2"/>.</summary>
            <param name="value">Reactor vector</param>
            <returns>Unity vector</returns>
        </member>
        <member name="M:KS.Reactor.ksVector2.op_Implicit(UnityEngine.Vector2)~KS.Reactor.ksVector2">
            <summary>Implicit conversion from Unity <see cref="T:UnityEngine.Vector2"/> to <see cref="T:KS.Reactor.ksVector2"/>.</summary>
            <param name="value">Unity vector</param>
            <returns>Reactor vector</returns>
        </member>
        <member name="M:KS.Reactor.ksVector2.op_Addition(KS.Reactor.ksVector2,UnityEngine.Vector2)">
            <summary>Vector addition with <see cref="T:KS.Reactor.ksVector2"/> and Unity <see cref="T:UnityEngine.Vector2"/>.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns><paramref name="lhs"/> + <paramref name="rhs"/></returns>
        </member>
        <member name="M:KS.Reactor.ksVector2.op_Addition(UnityEngine.Vector2,KS.Reactor.ksVector2)">
            <summary>Vector addition with Unity <see cref="T:UnityEngine.Vector2"/> and <see cref="T:KS.Reactor.ksVector2"/>.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns><paramref name="lhs"/> + <paramref name="rhs"/></returns>
        </member>
        <member name="M:KS.Reactor.ksVector2.op_Subtraction(KS.Reactor.ksVector2,UnityEngine.Vector2)">
            <summary>Vector subtraction with <see cref="T:KS.Reactor.ksVector2"/> and Unity <see cref="T:UnityEngine.Vector2"/>.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns><paramref name="lhs"/> - <paramref name="rhs"/></returns>
        </member>
        <member name="M:KS.Reactor.ksVector2.op_Subtraction(UnityEngine.Vector2,KS.Reactor.ksVector2)">
            <summary>Vector subtraction with Unity <see cref="T:UnityEngine.Vector2"/> and <see cref="T:KS.Reactor.ksVector2"/>.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns><paramref name="lhs"/> - <paramref name="rhs"/></returns>
        </member>
        <member name="M:KS.Reactor.ksVector2.op_Equality(KS.Reactor.ksVector2,UnityEngine.Vector2)">
            <summary>Equality comparison with with <see cref="T:KS.Reactor.ksVector2"/> and Unity <see cref="T:UnityEngine.Vector2"/>.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns><paramref name="lhs"/> == <paramref name="rhs"/></returns>
        </member>
        <member name="M:KS.Reactor.ksVector2.op_Equality(UnityEngine.Vector2,KS.Reactor.ksVector2)">
            <summary>Equality comparison with Unity <see cref="T:UnityEngine.Vector2"/> and <see cref="T:KS.Reactor.ksVector2"/>.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns><paramref name="lhs"/> == <paramref name="rhs"/></returns>
        </member>
        <member name="M:KS.Reactor.ksVector2.op_Inequality(KS.Reactor.ksVector2,UnityEngine.Vector2)">
            <summary>Inequality comparison with with <see cref="T:KS.Reactor.ksVector2"/> and Unity <see cref="T:UnityEngine.Vector2"/>.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns><paramref name="lhs"/> != <paramref name="rhs"/></returns>
        </member>
        <member name="M:KS.Reactor.ksVector2.op_Inequality(UnityEngine.Vector2,KS.Reactor.ksVector2)">
            <summary>Inequality comparison with Unity <see cref="T:UnityEngine.Vector2"/> and <see cref="T:KS.Reactor.ksVector2"/>.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns><paramref name="lhs"/> != <paramref name="rhs"/></returns>
        </member>
        <member name="T:KS.Reactor.ksVector3">
            <summary>ksVector3 struct.</summary>
            <summary>Vector struct</summary>
        </member>
        <member name="P:KS.Reactor.ksVector3.One">
            <summary>One.</summary>
        </member>
        <member name="P:KS.Reactor.ksVector3.Zero">
            <summary>Zero.</summary>
        </member>
        <member name="P:KS.Reactor.ksVector3.Forward">
            <summary>World forward direction.</summary>
        </member>
        <member name="P:KS.Reactor.ksVector3.Up">
            <summary>World up direction.</summary>
        </member>
        <member name="P:KS.Reactor.ksVector3.Right">
            <summary>World right direction.</summary>
        </member>
        <member name="P:KS.Reactor.ksVector3.Backwards">
            <summary>World backwards direction.</summary>
        </member>
        <member name="P:KS.Reactor.ksVector3.Down">
            <summary>World down direction.</summary>
        </member>
        <member name="P:KS.Reactor.ksVector3.Left">
            <summary>World left direction.</summary>
        </member>
        <member name="M:KS.Reactor.ksVector3.#ctor(System.Single,System.Single)">
            <summary>Constructor that takes x and y values and set z to 0.</summary>
            <param name="x">X value.</param>
            <param name="y">Y value.</param>
        </member>
        <member name="M:KS.Reactor.ksVector3.#ctor(System.Single,System.Single,System.Single)">
            <summary>Constructor.</summary>
            <param name="x">X value.</param>
            <param name="y">Y value.</param>
            <param name="z">Z value.</param>
        </member>
        <member name="M:KS.Reactor.ksVector3.op_Implicit(KS.Reactor.ksVector3)~System.Single[]">
            <summary>Implicit conversion from ksVector3 to float[3].</summary>
            <param name="value"></param>
        </member>
        <member name="M:KS.Reactor.ksVector3.op_Implicit(System.Single[])~KS.Reactor.ksVector3">
            <summary>Implicit conversion from float[] to ksVector3.</summary>
            <param name="value"></param>
        </member>
        <member name="P:KS.Reactor.ksVector3.X">
            <summary>X value.</summary>
        </member>
        <member name="P:KS.Reactor.ksVector3.Y">
            <summary>Y value.</summary>
        </member>
        <member name="P:KS.Reactor.ksVector3.Z">
            <summary>Z value.</summary>
        </member>
        <member name="P:KS.Reactor.ksVector3.XY">
            <summary>X and Y values as a ksVector2</summary>
        </member>
        <member name="P:KS.Reactor.ksVector3.XZ">
            <summary>X and Z values as a ksVector2</summary>
        </member>
        <member name="P:KS.Reactor.ksVector3.YZ">
            <summary>Y and Z values as a ksVector2</summary>
        </member>
        <member name="P:KS.Reactor.ksVector3.Item(System.Int32)">
            <summary>Indexer.</summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksVector3.Magnitude">
            <summary>Returns the magnitude.</summary>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksVector3.MagnitudeSquared">
            <summary>Returns the magnitude squared.</summary>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksVector3.Normalized">
            <summary>Returns the a normalized copy of this vector.</summary>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksVector3.Normalize">
            <summary>Normalizes this vector.</summary>
            <returns>False if the vector could not be normalized because it's the zero vector.</returns>
        </member>
        <member name="M:KS.Reactor.ksVector3.Clamped(System.Single)">
            <summary>Returns a copy of this vector with its magnitude clamped to maxLength.</summary>
            <param name="maxMagnitude">Max magnitude to clamp magnitude to.</param>
            <returns>Clamped vector.</returns>
        </member>
        <member name="M:KS.Reactor.ksVector3.Clamp(System.Single)">
            <summary>Clamps the magnitude of this vector.</summary>
            <param name="maxMagnitude">Max magnitude to clamp magnitude to.</param>
        </member>
        <member name="M:KS.Reactor.ksVector3.Abs">
            <summary>Absolute value vector.</summary>
            <returns>New vector where all components are absolue values of this vector.</returns>
        </member>
        <member name="M:KS.Reactor.ksVector3.MaxValue(System.Boolean)">
            <summary>Gets the maximum component in the vector.</summary>
            <param name="absolute">If ture, returns the max absolute value.</param>
            <returns>Max component value.</returns>
        </member>
        <member name="M:KS.Reactor.ksVector3.MinValue(System.Boolean)">
            <summary>Gets the minimum component in the vector.</summary>
            <param name="absolute">If true, return sthe min absolute value.</param>
            <returns>Min component value.</returns>
        </member>
        <member name="M:KS.Reactor.ksVector3.ReplaceNaNs(System.Single)">
            <summary>Replaces NaN values in the vector.</summary>
            <param name="value">Replacement value.</param>
            <returns>True if any of the values was replaced.</returns>
        </member>
        <member name="M:KS.Reactor.ksVector3.ToString">
            <summary>Returns a string that represents the current ksVector3.</summary>
            <returns>A string that represents the current ksVector3</returns>
        </member>
        <member name="M:KS.Reactor.ksVector3.ToString(System.String)">
            <summary>Returns a string respresentation of the vector.</summary>
            <param name="format"></param>
            <returns>String representation of the vector.</returns>
        </member>
        <member name="M:KS.Reactor.ksVector3.ToString(System.IFormatProvider)">
            <summary>Returns a string respresentation of the vector.</summary>
            <param name="provider"></param>
            <returns>String representation of the vector.</returns>
        </member>
        <member name="M:KS.Reactor.ksVector3.DeltaDegrees(KS.Reactor.ksVector3,KS.Reactor.ksVector3)">
            <summary>Returns the angle in degrees between to vectors.</summary>
            <param name="from">The angle extends round from this vector.</param>
            <param name="to">The angle extends round to this vector.</param>
            <returns>Angle in degrees.</returns>
        </member>
        <member name="M:KS.Reactor.ksVector3.DeltaRadians(KS.Reactor.ksVector3,KS.Reactor.ksVector3)">
            <summary>Returns the angle in degrees between to vectors.</summary>
            <param name="from">The angle extends round from this vector.</param>
            <param name="to">The angle extends round to this vector.</param>
            <returns>Angle in radians.</returns>
        </member>
        <member name="M:KS.Reactor.ksVector3.Dot(KS.Reactor.ksVector3,KS.Reactor.ksVector3)">
            <summary>Computes the dot product of two vectors.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns>Dot product.</returns>
        </member>
        <member name="M:KS.Reactor.ksVector3.Cross(KS.Reactor.ksVector3,KS.Reactor.ksVector3)">
            <summary>Computes the cross product of two vectors.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns>Cross product.</returns>
        </member>
        <member name="M:KS.Reactor.ksVector3.Max(KS.Reactor.ksVector3,KS.Reactor.ksVector3)">
            <summary>Returns a vector that is made from the largest components of two vectors.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns>Max vector.</returns>
        </member>
        <member name="M:KS.Reactor.ksVector3.Min(KS.Reactor.ksVector3,KS.Reactor.ksVector3)">
            <summary>Returns a vector that is made from the smallest components of two vectors</summary>
            <param name="lhs"></param>
            <param name="rhs">Min vector.</param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksVector3.OrthoNormalize(KS.Reactor.ksVector3@,KS.Reactor.ksVector3@)">
            <summary>Normalizes vectors and makes tangent orthoganol to normal.</summary>
            <param name="normal"></param>
            <param name="tangent"></param>
        </member>
        <member name="M:KS.Reactor.ksVector3.Project(KS.Reactor.ksVector3,KS.Reactor.ksVector3)">
            <summary>Projects a vector onto another vector.</summary>
            <param name="vector">Vector to project.</param>
            <param name="target">Target to project onto.</param>
            <returns>Projection result.</returns>
        </member>
        <member name="M:KS.Reactor.ksVector3.Reflect(KS.Reactor.ksVector3,KS.Reactor.ksVector3)">
            <summary>Reflects a vector off the plane defined by a normal.</summary>
            <param name="direction">Direction to reflect.</param>
            <param name="normal">Normal of plane to reflect off of.</param>
            <returns>Reflected vector.</returns>
        </member>
        <member name="M:KS.Reactor.ksVector3.Lerp(KS.Reactor.ksVector3,KS.Reactor.ksVector3,System.Single)">
            <summary>Linearly Interpolates between two vectors.</summary>
            <param name="from">Vector to interpolate from.</param>
            <param name="to">Vector to interpolate to.</param>
            <param name="t">Value between 0 and 1 that determines the amount of interpolation.</param>
            <returns>Interpolated vector.</returns>
        </member>
        <member name="M:KS.Reactor.ksVector3.Slerp(KS.Reactor.ksVector3,KS.Reactor.ksVector3,System.Single,System.Boolean)">
            <summary>Spherically interpolates between from and to by t.</summary>
            <param name="from">Vector to interpolate from.</param>
            <param name="to">Vector to interpolate to.</param>
            <param name="t">Value between 0 and 1 that determines the amount of interpolation.</param>
            <param name="lerpMagnitude">If false, magnitude won't be interpolated.</param>
            <returns>Interpolated vector.</returns>
        </member>
        <member name="M:KS.Reactor.ksVector3.MoveTowards(KS.Reactor.ksVector3,KS.Reactor.ksVector3,System.Single)">
            <summary>Moves a point towards a target point.</summary>
            <param name="start">Start point.</param>
            <param name="target">Target to move towards.</param>
            <param name="delta">
            delta distance to move. It will not overshoot the target. Negative values will move away from the target.
            </param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksVector3.RotateTowards(KS.Reactor.ksVector3,KS.Reactor.ksVector3,System.Single)">
            <summary>Rotates a vector towards a direction.</summary>
            <param name="vector">Vector to rotate.</param>
            <param name="direction">Direction to rotate towards.</param>
            <param name="deltaDegrees">Max amount in degrees to rotate the vector.</param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksVector3.RotateTowardsRadians(KS.Reactor.ksVector3,KS.Reactor.ksVector3,System.Single)">
            <summary>Rotates a vector towards a direction.</summary>
            <param name="vector">Vector to rotate.</param>
            <param name="direction">Direction to rotate towards.</param>
            <param name="deltaRadians">Max amount in radians to rotate the vector.</param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksVector3.Scale(KS.Reactor.ksVector3,KS.Reactor.ksVector3)">
            <summary>Multiplies two vectors component-wise.</summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksVector3.op_Subtraction(KS.Reactor.ksVector3,KS.Reactor.ksVector3)">
            <summary>Subtracts one vector from another.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksVector3.op_UnaryNegation(KS.Reactor.ksVector3)">
            <summary>Multiplies the vector by -1.</summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksVector3.op_Multiply(KS.Reactor.ksVector3,System.Single)">
            <summary>
            Multiplies a ksVector3 by a number. Multiplies each component of ksVector3 by a number scale.
            </summary>
            <param name="vector"></param>
            <param name="scale"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksVector3.op_Multiply(System.Single,KS.Reactor.ksVector3)">
            <summary>
            Multiplies a ksVector3 by a number. Multiplies each component of ksVector3 by a number scale.
            </summary>
            <param name="scale"></param>
            <param name="vector"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksVector3.op_Division(KS.Reactor.ksVector3,System.Single)">
            <summary>Divides a ksVector3 by a number.</summary>
            <param name="vector"></param>
            <param name="scale"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksVector3.op_Division(System.Single,KS.Reactor.ksVector3)">
            <summary>Dives a number by a ksVector3.</summary>
            <param name="number"></param>
            <param name="vector"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksVector3.op_Addition(KS.Reactor.ksVector3,KS.Reactor.ksVector3)">
            <summary>Adds two KSVector3s.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksVector3.op_Equality(KS.Reactor.ksVector3,KS.Reactor.ksVector3)">
            <summary>Checks if two vectors are equal.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns>True if the vectors are equal.</returns>
        </member>
        <member name="M:KS.Reactor.ksVector3.op_Inequality(KS.Reactor.ksVector3,KS.Reactor.ksVector3)">
            <summary>Checks if two vectors are not equal.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns>True if the vectors are not equal.</returns>
        </member>
        <member name="M:KS.Reactor.ksVector3.Equals(System.Object)">
            <summary>Checks if this vector is equal to an object.</summary>
            <param name="obj">Object to compare with this vector.</param>
            <returns>True if this vector is equal to the object.</returns>
        </member>
        <member name="M:KS.Reactor.ksVector3.Equals(KS.Reactor.ksVector3)">
            <summary>Checks if this vector is equal to another.</summary>
            <param name="other">Other vector to compare with.</param>
            <returns>True if the vectors are equal.</returns>
        </member>
        <member name="M:KS.Reactor.ksVector3.GetHashCode">
            <summary>Gets the hash code for this vector.</summary>
            <returns></returns>
        </member>
        <member name="M:KS.Reactor.ksVector3.op_Implicit(KS.Reactor.ksVector3)~UnityEngine.Vector3">
            <summary>Implicit conversion from <see cref="T:KS.Reactor.ksVector3"/> to Unity <see cref="T:UnityEngine.Vector3"/>.</summary>
            <param name="value">Reactor vector</param>
            <returns>Unity vectory</returns>
        </member>
        <member name="M:KS.Reactor.ksVector3.op_Implicit(UnityEngine.Vector3)~KS.Reactor.ksVector3">
            <summary>Implicit conversion from Unity <see cref="T:UnityEngine.Vector3"/> to <see cref="T:KS.Reactor.ksVector3"/>.</summary>
            <param name="value">Unity vector</param>
            <returns>Reactor vector</returns>
        </member>
        <member name="M:KS.Reactor.ksVector3.op_Addition(KS.Reactor.ksVector3,UnityEngine.Vector3)">
            <summary>Vector addition with <see cref="T:KS.Reactor.ksVector3"/> and Unity <see cref="T:UnityEngine.Vector3"/>.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns><paramref name="lhs"/> + <paramref name="rhs"/></returns>
        </member>
        <member name="M:KS.Reactor.ksVector3.op_Addition(UnityEngine.Vector3,KS.Reactor.ksVector3)">
            <summary>Vector addition with Unity <see cref="T:UnityEngine.Vector3"/> and <see cref="T:KS.Reactor.ksVector3"/>.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns><paramref name="lhs"/> + <paramref name="rhs"/></returns>
        </member>
        <member name="M:KS.Reactor.ksVector3.op_Subtraction(KS.Reactor.ksVector3,UnityEngine.Vector3)">
            <summary>Vector subtraction with <see cref="T:KS.Reactor.ksVector3"/> and Unity <see cref="T:UnityEngine.Vector3"/>.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns><paramref name="lhs"/> - <paramref name="rhs"/></returns>
        </member>
        <member name="M:KS.Reactor.ksVector3.op_Subtraction(UnityEngine.Vector3,KS.Reactor.ksVector3)">
            <summary>Vector subtraction with Unity <see cref="T:UnityEngine.Vector3"/> and <see cref="T:KS.Reactor.ksVector3"/>.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns><paramref name="lhs"/> - <paramref name="rhs"/></returns>
        </member>
        <member name="M:KS.Reactor.ksVector3.op_Equality(KS.Reactor.ksVector3,UnityEngine.Vector3)">
            <summary>Equality comparison with with <see cref="T:KS.Reactor.ksVector3"/> and Unity <see cref="T:UnityEngine.Vector3"/>.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns><paramref name="lhs"/> == <paramref name="rhs"/></returns>
        </member>
        <member name="M:KS.Reactor.ksVector3.op_Equality(UnityEngine.Vector3,KS.Reactor.ksVector3)">
            <summary>Equality comparison with Unity <see cref="T:UnityEngine.Vector3"/> and <see cref="T:KS.Reactor.ksVector3"/>.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns><paramref name="lhs"/> == <paramref name="rhs"/></returns>
        </member>
        <member name="M:KS.Reactor.ksVector3.op_Inequality(KS.Reactor.ksVector3,UnityEngine.Vector3)">
            <summary>Inequality comparison with with <see cref="T:KS.Reactor.ksVector3"/> and Unity <see cref="T:UnityEngine.Vector3"/>.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns><paramref name="lhs"/> != <paramref name="rhs"/></returns>
        </member>
        <member name="M:KS.Reactor.ksVector3.op_Inequality(UnityEngine.Vector3,KS.Reactor.ksVector3)">
            <summary>Inequality comparison with Unity <see cref="T:UnityEngine.Vector3"/> and <see cref="T:KS.Reactor.ksVector3"/>.</summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns>l<paramref name="lhs"/> != <paramref name="rhs"/></returns>
        </member>
        <member name="T:KS.Reactor.ksWebRequest">
            <summary>Asynchronous web request class using HTTP Web Request.</summary>
        </member>
        <member name="T:KS.Reactor.ksWebRequest.OnCompleteCallback">
            <summary>Callback for completed web requests.</summary>
            <param name="response">Completed web request.</param>
        </member>
        <member name="P:KS.Reactor.ksWebRequest.Method">
            <summary>Method.</summary>
        </member>
        <member name="P:KS.Reactor.ksWebRequest.URL">
            <summary>URL.</summary>
        </member>
        <member name="P:KS.Reactor.ksWebRequest.JSON">
            <summary>JSON data.</summary>
        </member>
        <member name="P:KS.Reactor.ksWebRequest.Headers">
            <summary>Headers.</summary>
        </member>
        <member name="P:KS.Reactor.ksWebRequest.IsDone">
            <summary>Checks if the request has completed.</summary>
        </member>
        <member name="P:KS.Reactor.ksWebRequest.Response">
            <summary>Response.</summary>
        </member>
        <member name="P:KS.Reactor.ksWebRequest.OnComplete">
            <summary>Completion handler.</summary>
        </member>
        <member name="P:KS.Reactor.ksWebRequest.SendTime">
            <summary>Time in ticks when the request was sent.</summary>
        </member>
        <member name="P:KS.Reactor.ksWebRequest.HttpWebRequest">
            <summary>Underlying .Net request object.</summary>
        </member>
        <member name="P:KS.Reactor.ksWebRequest.MultiPartBoundary">
            <summary>Multi-part boundary string.</summary>
        </member>
        <member name="P:KS.Reactor.ksWebRequest.MultiPartFiles">
            <summary>Multi-part file list.</summary>
        </member>
        <member name="M:KS.Reactor.ksWebRequest.#ctor(System.String,System.Net.WebHeaderCollection,System.String,KS.Reactor.ksJSON,KS.Reactor.ksWebResponse.Handler,System.Object)">
            <summary>Constructor specific requests.</summary>
            <param name="url">URL.</param>
            <param name="headers">Request string.</param>
            <param name="method">Request method.</param>
            <param name="jsonRequest">JSON request.</param>
            <param name="onComplete">Optional completion handler.</param>
            <param name="stateObject">User defined state tracking object.</param>
        </member>
        <member name="M:KS.Reactor.ksWebRequest.Send(System.String,System.Net.WebHeaderCollection,System.String,KS.Reactor.ksJSON,KS.Reactor.ksWebResponse.Handler,System.Object)">
            <summary>Sends an asynchronous web request.</summary>
            <param name="url">URL.</param>
            <param name="headers">Request string.</param>
            <param name="method">Request method.</param>
            <param name="jsonRequest">JSON request data.</param>
            <param name="onComplete">Optional completion handler.</param>
            <param name="stateObject">User defined state tracking object.</param>
        </member>
        <member name="M:KS.Reactor.ksWebRequest.#ctor(System.String,System.IO.FileInfo[],KS.Reactor.ksJSON,KS.Reactor.ksWebResponse.Handler)">
            <summary>Sends a request and upload files.</summary>
            <param name="url">URL</param>
            <param name="files">List of files to upload.</param>
            <param name="jsonRequest">JSON request data.</param>
            <param name="onComplete">Optional completion handler.</param>
        </member>
        <member name="M:KS.Reactor.ksWebRequest.CertValidation(System.Object,System.Security.Cryptography.X509Certificates.X509Certificate,System.Security.Cryptography.X509Certificates.X509Chain,System.Net.Security.SslPolicyErrors)">
            <summary>Validates SSL certificates.</summary>
            <param name="sender"></param>
            <param name="certificate"></param>
            <param name="chain"></param>
            <param name="sslPolicyErrors"></param>
            <returns>True the certificate is valid.</returns>
        </member>
        <member name="M:KS.Reactor.ksWebRequest.OnGetFileRequestStream(System.IAsyncResult)">
            <summary>Called when the request stream is available. Sends http request.</summary>
            <param name="asyncResult"></param>
        </member>
        <member name="M:KS.Reactor.ksWebRequest.WriteToStream(System.String,System.IO.Stream)">
            <summary>Converts a string to a UTF8 byte array and write it to a stream.</summary>
            <param name="stringData">String to write.</param>
            <param name="stream">Output stream.</param>
        </member>
        <member name="M:KS.Reactor.ksWebRequest.OnGetRequestStream(System.IAsyncResult)">
            <summary>Called when the request stream is available. Sends http request.</summary>
            <param name="asyncResult"></param>
        </member>
        <member name="M:KS.Reactor.ksWebRequest.OnGetResponse(System.IAsyncResult)">
            <summary>Called when the response is received.</summary>
            <param name="asyncResult"></param>
        </member>
        <member name="M:KS.Reactor.ksWebRequest.CleanJson(System.String)">
            <summary>Cleans up json responses. Replaces any back-slash quotes with plain quotes.</summary>
            <param name="json">JSON string.</param>
            <returns>JSON string.</returns>
        </member>
        <member name="T:KS.Reactor.MultiTypeSerializer">
            <summary>A class that serializes/deserializes the multi type.</summary>
        </member>
        <member name="M:KS.Reactor.MultiTypeSerializer.Serialize(KS.Reactor.ksMultiType,KS.Reactor.ksBitOStream)">
            <summary>Serializes a multi type.</summary>
            <param name="multiType">Multi type to serialize.</param>
            <param name="output">Output to write to.</param>
        </member>
        <member name="M:KS.Reactor.MultiTypeSerializer.Deserialize(KS.Reactor.ksMultiType,KS.Reactor.ksBitIStream)">
            <summary>Deserializes a multi type.</summary>
            <param name="multiType">Multi type to deserialize to.</param>
            <param name="input">Input to read from.</param>
        </member>
        <member name="T:KS.Reactor.PreserveAttribute">
            <summary>
            Prevents whatever it tags from being stripped from IL2CPP builds. Unity looks for any attribute named
            PreserveAttribute when deciding what to strip. Preserve an entire assembly using [assembly: Preserve].
            </summary>
        </member>
        <member name="T:KS.Reactor.RingBuffer`1">
            <summary>
            A fixed-size ring buffer. The oldest values will be removed as new ones are added when the buffer is full.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:KS.Reactor.RingBuffer`1.#ctor(System.Int32)">
            <summary>Constructor.</summary>
            <param name="size">Size of the buffer.</param>
        </member>
        <member name="P:KS.Reactor.RingBuffer`1.Count">
            <summary>Number of values in the buffer.</summary>
        </member>
        <member name="P:KS.Reactor.RingBuffer`1.Size">
            <summary>Max capacity of the buffer.</summary>
        </member>
        <member name="P:KS.Reactor.RingBuffer`1.Item(System.Int32)">
            <summary>
            Access the value at an index. Values are indexed from newest to oldest starting at index 0.
            </summary>
        </member>
        <member name="M:KS.Reactor.RingBuffer`1.Add(`0)">
            <summary>Adds a value to the buffer. Removes the oldest value if the buffer is full.</summary>
            <param name="value">Value to add.</param>
            <returns>
            Value removed from the buffer, or default(T) if no value was removed because the buffer was not full.
            </returns>
        </member>
        <member name="M:KS.Reactor.RingBuffer`1.Add(`0,`0)">
            <summary>Adds a value to the buffer. Removes the oldest value if the buffer is full.</summary>
            <param name="value">Value to add.</param>
            <param name="defaultReturn">Value if no value was removed because the buffer was not full.</param>
            <returns>Value removed from the buffer, or defaultReturn if no value was removed.</returns>
        </member>
        <member name="M:KS.Reactor.RingBuffer`1.Clear">
            <summary>Clears the buffer.</summary>
        </member>
        <member name="T:KS.Reactor.UnityProxyAttribute">
            <summary>
            Server scripts tagged with this will not have Unity proxy scripts generated for them and will use
            <see cref="P:KS.Reactor.UnityProxyAttribute.Name"/> as the proxy class. <see cref="P:KS.Reactor.UnityProxyAttribute.Name"/> should refer to an existing class. If
            <see cref="P:KS.Reactor.UnityProxyAttribute.Name"/> is null or empty, a proxy will still be generated and this tag does nothing.
            </summary>
        </member>
        <member name="P:KS.Reactor.UnityProxyAttribute.Name">
            <summary>Name of type to use as the proxy for the tagged class in Unity.</summary>
        </member>
        <member name="P:KS.Reactor.UnityProxyAttribute.CanInherit">
             <summary>
             Should the proxies generated for classes that derive from the class with this tag inherit from
             <see cref="P:KS.Reactor.UnityProxyAttribute.Name"/>?
            </summary>
             <example>
             Class A has the attribute `[UnityProxy("ProxyA", true)]`. Class B derives from A and does not have a
             UnityProxy tag. The proxy generated for B will inherit from ProxyA. If class A were instead tagged with
             `[[UnityProxy("ProxyA", false)]`, then the proxy generated for B would inherit from the proxy for A's base
             class.
             </example>
        </member>
        <member name="M:KS.Reactor.UnityProxyAttribute.#ctor(System.String,System.Boolean)">
            <summary>Constructor</summary>
            <param name="name">Name of the proxy for this class.</param>
            <param name="canInherit"></param>
        </member>
        <member name="T:KS.LZMA.ksICompressionTask">
            Public compression task interface
        </member>
        <member name="T:KS.LZMA.CompressionTask">
            Compression task created by LZMA Compress and Decompress requests.
        </member>
        <member name="P:KS.LZMA.CompressionTask.Progress">
            @return  float value between 0.0 and 1.0 representing the task progress.
        </member>
        <member name="P:KS.LZMA.CompressionTask.IsComplete">
            @return  bool true if the task is complete
        </member>
        <member name="P:KS.LZMA.CompressionTask.Exception">
            @return  Exception the last exception encountered
        </member>
        <member name="P:KS.LZMA.CompressionTask.IsCompression">
            @return  bool true if this is a compression task
        </member>
        <member name="P:KS.LZMA.CompressionTask.IsDecompression">
            @return  bool true if this is a decompression task
        </member>
        <member name="P:KS.LZMA.CompressionTask.RawSize">
            @return  long raw data size. Return -1 if is decompression and it is not done yet.
        </member>
        <member name="P:KS.LZMA.CompressionTask.EncodedSize">
            @return  long encoded data size. Return -1 if is compression and it is not done yet.
        </member>
        <member name="M:KS.LZMA.CompressionTask.#ctor(System.Byte[],KS.LZMA.ksLZMA.OnCompleteHandler,System.Boolean)">
            Byte array constructor
            
            @param   byte[] input data
            @param   OnCompleteHandler completion callback
        </member>
        <member name="M:KS.LZMA.CompressionTask.#ctor(System.IO.Stream,System.IO.Stream,KS.LZMA.ksLZMA.OnCompleteHandler,System.Boolean)">
            Input/Output stream constructor
            
            @param   Stream - input stream
            @param   Stream - output stream
            @param   OnCompleteHandler completion callback
            @param   bool - compress
        </member>
        <member name="M:KS.LZMA.CompressionTask.Start">
            Start the compression / decompression task
        </member>
        <member name="M:KS.LZMA.CompressionTask.SetProgress(System.Int64,System.Int64)">
            Update the compress/decompression progress
            LZMA Interface method.
            
            @param   long number of input bytes processed.
            @param   long number of output bytes processed.
        </member>
        <member name="M:KS.LZMA.CompressionTask.Compress">
            Compression
        </member>
        <member name="M:KS.LZMA.CompressionTask.Decompress">
            Decompression
        </member>
        <member name="M:KS.LZMA.CompressionTask.TryGetEncodedData(System.Byte[]@)">
            Try to get the encoded data.  If this is a compression task and the task is not complete then this function 
            will return false and initialize encodedData to null.
            
            @param   byte[] out encoded data
            @return  bool true if the encodedData was updated.
        </member>
        <member name="M:KS.LZMA.CompressionTask.TryGetRawData(System.Byte[]@)">
            Try to get the raw data.  If this is a decompression task and the task is not complete then this function 
            will return false and initialize rawData to null.
            
            @param   byte[] out encoded data
            @return  bool true if the encodedData was updated.
        </member>
        <member name="T:KS.LZMA.ksLZMA">
            <summary>Wrapper class of LZMA.</summary>
        </member>
        <member name="M:KS.LZMA.ksLZMA.GetCompressTask(System.Byte[],KS.LZMA.ksLZMA.OnCompleteHandler)">
            <summary>
            Compresses the given data with LZMA on a seperate thread and returns the compression task.
            Calls the given callback method after the compression task is completed.
            </summary>
            <param name="data">Data to be compressed</param>
            <param name="callback">Callback to call</param>
            <returns>Compression task</returns>
        </member>
        <member name="M:KS.LZMA.ksLZMA.GetCompressTask(System.IO.Stream,System.IO.Stream,KS.LZMA.ksLZMA.OnCompleteHandler)">
            <summary>
            Compresses the given data with LZMA on a seperate thread and returns the compression task.
            Calls the given callback method after the compression task is completed.
            </summary>
            <param name="inputStream">input stream</param>
            <param name="outputStream">output stream</param>
            <param name="callback">callback</param>
            <returns>Compression task</returns>
        </member>
        <member name="M:KS.LZMA.ksLZMA.GetDecompressTask(System.Byte[],KS.LZMA.ksLZMA.OnCompleteHandler)">
            <summary>
            Decompresses the given data with LZMA on a seperate thread and returns the compression task.
            Calls the given callback method after the decompression task is completed.
            </summary>
            <param name="data">Data to be decompressed</param>
            <param name="callback">Callback to call</param>
            <returns>Compression task</returns>
        </member>
        <member name="M:KS.LZMA.ksLZMA.GetDecompressTask(System.IO.Stream,System.IO.Stream,KS.LZMA.ksLZMA.OnCompleteHandler)">
            <summary>
            Decompresses the given data with LZMA on a seperate thread and returns the compression task.
            Calls the given callback method after the compression task is completed.
            </summary>
            <param name="inputStream">input stream</param>
            <param name="outputStream">output stream</param>
            <param name="callback">callback</param>
            <returns>Compression task</returns>
        </member>
        <member name="M:KS.LZMA.ksLZMA.Compress(System.Byte[])">
            <summary>Compresses the given data with LZMA.</summary>
            <param name="rawData">rawData to be compressed.</param>
            <returns>compressed data</returns>
        </member>
        <member name="M:KS.LZMA.ksLZMA.Compress(System.IO.Stream,System.IO.Stream)">
            <summary>Compresses the given data with LZMA.</summary>
            <param name="rawStream">rawStream to be compressed.</param>
            <param name="encodedStream">encoded stream</param>
        </member>
        <member name="M:KS.LZMA.ksLZMA.Compress(System.IO.Stream,System.IO.Stream,System.Int64@,System.Int64@)">
            <summary>Compresses the given data with LZMA.</summary>
            <param name="rawStream">raw stream to read from</param>
            <param name="encodedStream">encoded stream to write to</param>
            <param name="rawSize">raw size</param>
            <param name="encodedSize">encoded size</param>
        </member>
        <member name="M:KS.LZMA.ksLZMA.Compress(System.IO.Stream,System.IO.Stream,SevenZip.ICodeProgress,System.Int64@,System.Int64@)">
            <summary>Compresses the given data with LZMA.</summary>
            <param name="rawStream">raw stream to read from</param>
            <param name="encodedStream">encoded stream to write to</param>
            <param name="progress">will receive progress callbacks. May be null.</param>
            <param name="rawSize">raw size</param>
            <param name="encodedSize">encoded size</param>
        </member>
        <member name="M:KS.LZMA.ksLZMA.Decompress(System.Byte[])">
            <summary>Decompresses the given data with LZMA.</summary>
            <param name="encodedData">encodedData to be decompressed.</param>
            <returns>decompressed data</returns>
        </member>
        <member name="M:KS.LZMA.ksLZMA.Decompress(System.IO.Stream,System.IO.Stream,System.Int64@,System.Int64@)">
            <summary>Decompresses the given data with LZMA.</summary>
            <param name="encodedStream">raw stream to write to</param>
            <param name="rawStream">encoded stream to read from</param>
            <param name="encodedSize">encoded size</param>
            <param name="rawSize">raw size</param>
        </member>
        <member name="M:KS.LZMA.ksLZMA.Decompress(System.IO.Stream,System.IO.Stream,SevenZip.ICodeProgress,System.Int64@,System.Int64@)">
            <summary>Decompresses the given data with LZMA.</summary>
            <param name="encodedStream">raw stream to write to</param>
            <param name="rawStream">encoded stream to read from</param>
            <param name="progress">will receive progress callbacks. May be null.</param>
            <param name="encodedSize">encoded size</param>
            <param name="rawSize">raw size</param>
        </member>
        <member name="T:KS.LZMA.ksLZW">
            <summary>
            LZW Based Decompressor - basic algorithm used as described on Mark Nelson's website  http://marknelson.us
            </summary>
        </member>
        <member name="M:KS.LZMA.ksLZW.Initialize">
            <summary>
            Used to blank out the bit buffer incase this class is called to comprss and decompress from the same instance.
            </summary>
        </member>
        <member name="M:KS.LZMA.ksLZW.Compress(System.IO.Stream,System.IO.Stream)">
            <summary>
            Read data from an input stream and write the compressed data to an output stream.
            </summary>
            <param name="input">Uncompressed input stream.</param>
            <param name="output">Compressed output stream.</param>
        </member>
        <member name="M:KS.LZMA.ksLZW.FindMatch(System.Int32,System.Int32)">
            <summary>
            Hashing function, tries to find index of prefix+char, if not found returns -1 to signify space available
            </summary>
            <param name="pPrefix"></param>
            <param name="pChar"></param>
            <returns></returns>
        </member>
        <member name="M:KS.LZMA.ksLZW.WriteCode(System.IO.Stream,System.Int32)">
            <summary>
            Write code to an output stream.
            </summary>
            <param name="output">Output stream</param>
            <param name="code">Code</param>
        </member>
        <member name="M:KS.LZMA.ksLZW.Decompress(System.IO.Stream,System.IO.Stream)">
            <summary>
            Read compressed data from an input stream and write the uncompressed data to an output stream.
            </summary>
            <param name="input">Uncompressed input stream.</param>
            <param name="output">Compressed output stream.</param>
        </member>
        <member name="M:KS.LZMA.ksLZW.ReadCode(System.IO.Stream)">
            <summary>
            Read a code from an input stream
            </summary>
            <param name="input">Input stream</param>
        </member>
        <member name="M:KS.LZMA.ksLZW.Compress(System.Byte[])">
            <summary>
            Synchrounously Compress a byte array using LZW compression
            </summary>
            <param name="data">Data to compress</param>
            <returns>Compressed data.</returns>
        </member>
        <member name="M:KS.LZMA.ksLZW.Decompress(System.Byte[])">
            <summary>
            Synchrounously decompress a byte array using LZW decompression
            </summary>
            <param name="data">Data to decompress</param>
            <returns>Decompressed data.</returns>
        </member>
        <member name="T:SevenZip.DataErrorException">
            <summary>
            The exception that is thrown when an error in input stream occurs during decoding.
            </summary>
        </member>
        <member name="T:SevenZip.InvalidParamException">
            <summary>
            The exception that is thrown when the value of an argument is outside the allowable range.
            </summary>
        </member>
        <member name="M:SevenZip.ICodeProgress.SetProgress(System.Int64,System.Int64)">
            <summary>
            Callback progress.
            </summary>
            <param name="inSize">
            input size. -1 if unknown.
            </param>
            <param name="outSize">
            output size. -1 if unknown.
            </param>
        </member>
        <member name="M:SevenZip.ICoder.Code(System.IO.Stream,System.IO.Stream,System.Int64,System.Int64,SevenZip.ICodeProgress)">
            <summary>
            Codes streams.
            </summary>
            <param name="inStream">
            input Stream.
            </param>
            <param name="outStream">
            output Stream.
            </param>
            <param name="inSize">
            input Size. -1 if unknown.
            </param>
            <param name="outSize">
            output Size. -1 if unknown.
            </param>
            <param name="progress">
            callback progress reference.
            </param>
            <exception cref="T:SevenZip.DataErrorException">
            if input stream is not valid
            </exception>
        </member>
        <member name="T:SevenZip.CoderPropID">
            <summary>
            Provides the fields that represent properties idenitifiers for compressing.
            </summary>
        </member>
        <member name="F:SevenZip.CoderPropID.DefaultProp">
            <summary>
            Specifies default property.
            </summary>
        </member>
        <member name="F:SevenZip.CoderPropID.DictionarySize">
            <summary>
            Specifies size of dictionary.
            </summary>
        </member>
        <member name="F:SevenZip.CoderPropID.UsedMemorySize">
            <summary>
            Specifies size of memory for PPM*.
            </summary>
        </member>
        <member name="F:SevenZip.CoderPropID.Order">
            <summary>
            Specifies order for PPM methods.
            </summary>
        </member>
        <member name="F:SevenZip.CoderPropID.BlockSize">
            <summary>
            Specifies Block Size.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:SevenZip.CoderPropID.PosStateBits" -->
        <!-- Badly formed XML comment ignored for member "F:SevenZip.CoderPropID.LitContextBits" -->
        <!-- Badly formed XML comment ignored for member "F:SevenZip.CoderPropID.LitPosBits" -->
        <member name="F:SevenZip.CoderPropID.NumFastBytes">
            <summary>
            Specifies number of fast bytes for LZ*.
            </summary>
        </member>
        <member name="F:SevenZip.CoderPropID.MatchFinder">
            <summary>
            Specifies match finder. LZMA: "BT2", "BT4" or "BT4B".
            </summary>
        </member>
        <member name="F:SevenZip.CoderPropID.MatchFinderCycles">
            <summary>
            Specifies the number of match finder cyckes.
            </summary>
        </member>
        <member name="F:SevenZip.CoderPropID.NumPasses">
            <summary>
            Specifies number of passes.
            </summary>
        </member>
        <member name="F:SevenZip.CoderPropID.Algorithm">
            <summary>
            Specifies number of algorithm.
            </summary>
        </member>
        <member name="F:SevenZip.CoderPropID.NumThreads">
            <summary>
            Specifies the number of threads.
            </summary>
        </member>
        <member name="F:SevenZip.CoderPropID.EndMarker">
            <summary>
            Specifies mode with end marker.
            </summary>
        </member>
    </members>
</doc>
